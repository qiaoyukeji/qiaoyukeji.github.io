<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.gitnote.cn/</id>
    <title>巧遇个人博客</title>
    <updated>2024-09-10T09:45:07.934Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.gitnote.cn/"/>
    <link rel="self" href="https://blog.gitnote.cn/atom.xml"/>
    <subtitle>他日若遂凌云志，敢笑黄巢不丈夫！&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;code-v9TubG0Cv1&quot; /&gt;&lt;meta name=&quot;msvalidate.01&quot; content=&quot;8B5B1D4FCE1CBCBCD2836739B32F2960&quot; /&gt;</subtitle>
    <logo>https://blog.gitnote.cn/images/avatar.png</logo>
    <icon>https://blog.gitnote.cn/favicon.ico</icon>
    <rights>All rights reserved 2024, 巧遇个人博客</rights>
    <entry>
        <title type="html"><![CDATA[博客网站运行 1100 天记录]]></title>
        <id>https://blog.gitnote.cn/post/run_1100_day/</id>
        <link href="https://blog.gitnote.cn/post/run_1100_day/">
        </link>
        <updated>2024-09-10T09:39:12.000Z</updated>
        <content type="html"><![CDATA[<p>本博客自 2021年9月6日我即将进入研究生阶段学习前夕建立，建立的初衷是记录我的日常的学习与生活。</p>
<p>截止到2024年9月10日，博客网站已正常运行 1100 天，本博客贯穿了我的整个研究生生涯，记录了我的研究生学习期间的种种内容。</p>
<p>说真的，在最开始的时候，我真的从未曾想象过我的博客能够持续运行这么长的时间，我居然能够坚持整整 3 年不断地在博客中撰写各类内容。这其中的坚持与付出，现在回想起来都觉得有些不可思议。而且，我的博客在全平台的阅读量竟然也超过了 50 万，它意味着我的文字和经历在一定程度上得到了大家的关注与认可。</p>
<p>在研究生期间，因为大部分时间都沉浸在学习与研究之中，而我本身对新鲜事物又有着浓厚的兴趣。每当遇到那些新奇的领域或者独特的观点时，我总会不由自主地深入其中进行探索与研究。得益于研究生相对灵活的时间安排，我有足够的时间将这些研究成果整理归纳，最终形成一篇篇有价值的博客文章。</p>
<p>如今，我已经顺利地从研究生毕业，正式进入了企业开始上班。然而，企业的工作模式和校园有着很大的不同。在这里，一切都显得比较按部就班，很少有新奇的事物出现，也不需要我像在学校那样去深入地研究与探索。或许正是因为这样相对平淡的工作环境，导致我在近期都没有再撰写新的博客。</p>
<p>但我始终认为，撰写博客是一件极具意义的事情，尤其是撰写技术博客。它就像是把我们所学的知识，通过文字、图片等生动形象的方式记录下来，最终形成一篇完整的、具有可复现性的文档。在这个撰写的过程中，我们其实是在对相关的技术进行一次深入的复习与巩固。而当我们完成博客之后，它不仅可以为其他有需要的人提供宝贵的参考资料，同时也可以当作我们自己的一份独特的学习笔记，在未来的日子里随时翻阅。</p>
<p>我会继续保持积极的学习姿态，不断地学习新的知识与技能。并且，我会将这些学习成果认真地整理、汇总，然后将它们以博客内容的形式分享给每一位关注我的朋友。让我们一起在知识的海洋中遨游，共同进步！</p>
<p>最后，与大家共勉！</p>
<hr>
<p>写于 2024年9月10日，巧遇！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[24届毕业季——我的找工作之旅纪实]]></title>
        <id>https://blog.gitnote.cn/post/find_jobs_in_2024/</id>
        <link href="https://blog.gitnote.cn/post/find_jobs_in_2024/">
        </link>
        <updated>2024-07-05T10:41:20.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705220218.jpg" alt="" loading="lazy"></figure>
<hr>
<h2 id="1-个人介绍">1. 个人介绍</h2>
<p>本人是2021年9月入学、2024年6月毕业的一名计算机科学与技术专业硕士研究生，就读于省会城市的一所一本院校。</p>
<p>本人在2023年9月开始陆续投递简历，之后进入了投简历、笔试、面试的无限循环之中，本文是我找工作以来的一些记录。</p>
<h2 id="2-找工作流水记录">2. 找工作流水记录</h2>
<p>下面是本人从秋招到春招以来笔试和面试的公司（不完全），部分企业公司笔面试时间相同冲突时只选择其中一个参加。</p>
<p>部分保密单位笔、面试未列出。</p>
<ul>
<li>2023年8月13日，兆易创新，嵌入式软件工程师，笔试。</li>
<li>2023年8月17日，基恩士，技术工程师，一面。</li>
<li>2023年8月19日，京东集团，前端开发工程师，笔试。</li>
<li>2023年9月2日，小米，软件开发（JS），笔试。</li>
<li>2023年9月3日，微众银行，网络技术，笔试。</li>
<li>2023年9月14日，锐捷网络，嵌入式开发，笔试。</li>
<li>2023年9月16日，58同城，前端开发，笔试。</li>
<li>2023年9月21日，同程旅行，前端开发，笔试。</li>
<li>2023年10月10日，中信银行，信息科技，全球统一笔试（第一批）。</li>
<li>2023年10月14日，上海银行，信息科技，笔试。</li>
<li>2024年10月14日，小米，嵌入式开发，笔试。</li>
<li>2023年10月15日，咪咕文化，软件工程师，笔试。</li>
<li>2023年10月19号，民生银行上海分行，信息科技，笔试。</li>
<li>2023年10月31日，太平洋寿险，信息科技（前端方向），笔试。</li>
<li>2023年11月3日，阅文集团，前端开发，笔试。</li>
<li>2023年11月6日，民生银行上海分行，首轮线上面试。</li>
<li>2023年11月15日，保利集团校园招聘开放日，<strong>中奖</strong>，J20模型。</li>
<li>2023年12月3日，国家电网安徽，计算机类，笔试。</li>
<li>2023年12月9日，南方电网，信息通信类，统一线下笔试。</li>
<li>2023年12月9日，国家电网安徽，计算机类，<strong>面试</strong>。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705172518.png" alt="" loading="lazy"></li>
<li>2023年12月9日，教育部直属事业单位，笔试。</li>
<li>2023年12月25日，南方电网超高压，计算机类，<strong>面试</strong>。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705173848.jpg" alt="" loading="lazy"></li>
<li>2024年1月12日，南方电网广东，计算机类，<strong>面试</strong>。</li>
<li>2024年2月27日，中国建筑集团，信息类，统一笔试。</li>
<li>2024年3月6日，美团，前端开发，笔试。</li>
<li>2024年3月8日，携程，SRE工程师，笔试。</li>
<li>2024年3月12日，湖北中烟，信息类，笔试。</li>
<li>2024年3月14日，金山WPS，前端开发，笔试。</li>
<li>2024年3月15日，CVTE，嵌入式开发，笔试。</li>
<li>2024年3月23日，中国银行，信息科技类，线下统一笔试。</li>
<li>2024年3月20日，中国极地研究中心，电子工程师，<strong>二面</strong>。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705173127.png" alt="" loading="lazy"></li>
<li>2024年3月20日，小米，SER工程师，面试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705214748.png" alt="" loading="lazy"></li>
<li>2024年3月24日，TCL实业，笔试。</li>
<li>2024年3月30日，上海市事业单位联考，笔试。</li>
<li>2024年4月2日，安徽江淮汽车，软件系统岗，面试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705214947.png" alt="" loading="lazy"></li>
<li>2024年4月3日，小米，前端开发，面试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705214102.png" alt="" loading="lazy"></li>
<li>2024年4月10日，华夏银行，信息科技类，笔试。</li>
<li>2024年4月11日，国家计算机<code>********</code>中心，网络安全，笔试。</li>
<li>2024年4月15日，江苏交控，信息科技类，笔试。</li>
<li>2024年4月20日，浙江中烟，信息科技类，笔试。</li>
<li>2024年4月21日，中国工商银行，信息科技类，笔试。</li>
<li>2024年4月21日，应急管理部上海消防研究所，信息科技类，笔试。</li>
<li>2024年4月24日，三峡集团上海勘测设计研究院，信息科技类，面谈。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705214225.png" alt="" loading="lazy"></li>
<li>2024年4月25日，山东黄金集团，信息科技类，笔试。</li>
<li>2024年4月26日，民生银行上海分行，信息科技类，笔试。</li>
<li>2024年4月30日，水利部淮委通信总站，信息岗，笔试。</li>
<li>2024年5月7日，广东广电，信息岗，笔试。</li>
<li>2024年5月8日，中国工商银行软件开发中心（上海），信息科技类，<strong>面试</strong>。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705173255.png" alt="" loading="lazy"></li>
<li>2024年5月12日，国家能源集团，信息科技类，笔试。</li>
<li>2024年5月13日，中国工商银行合肥分行，科技精英，面试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705214446.png" alt="" loading="lazy"></li>
<li>2024年5月16日，民生银行上海分行，信息科技类，面试。</li>
<li>2024年5月14日，山东黄金集团山金期货，信息类，面试意向。</li>
<li>2024年5月14日，国家计算机<code>********</code>中心，网络安全，专业加试。</li>
<li>2024年5月14日，国家计算机<code>********</code>中心，网络安全，<strong>面试</strong>。</li>
<li>2024年5月18日，水利部淮委通信总站，信息岗，<strong>面试</strong>。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705173526.png" alt="" loading="lazy"></li>
<li>2024年5月28日，国家能源集团，计算机岗，<strong>面试</strong>。</li>
<li>2024年5月31日，上海审计科学研究所，计算机岗，<strong>面试</strong>。</li>
<li>2024年6月4日，广铁集团，软件开发岗，笔试。</li>
<li>2024年6月5日，安徽省交规院，信息岗，面试。</li>
<li>2024年6月14日，上海华讯网络，云计算工程师，笔试。</li>
<li>2024年6月14日，上海大数据中心，区块链工程师，笔试。</li>
<li>2024年6月18日，上海华讯网络，云计算工程师，面试<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705215142.png" alt="" loading="lazy"></li>
<li>2024年6月27日，上海电机学院，图书馆档案管理，笔试。</li>
<li>2024年6月30日，安徽工程大学，计算机学院教师，笔试。</li>
<li>2024年6月30日，浙江交院，数字化建设工程师，笔试。</li>
</ul>
<h2 id="3-总结">3. 总结</h2>
<p>在这段被冠以“史上最艰难就业”之名的毕业季里（或许 25 届会更艰难🤣），本人参加了众多公司的笔试，也历经了诸多公司的面试，然而一直处于陪跑状态。不少单位面试都是5进1、3进1，单位最终都选择了 985、211 院校的学生，本人学校于此方面不具优势。在这些面试经历中，我深切地感受到就业的沉重压力，此压力自上而下影响着每一个人。</p>
<p>毕业离校之际，本人手中空无一 Offer，目睹身边同学相继收获喜讯，那份焦虑与不安难以言表。最终，在毕业离校 20 多天后，一个省属国企向我伸出了橄榄枝，本人总算拿到了一个 Offer。有了 Offer 在手，内心压力顿时减轻不少，求职之路也暂告一段落。</p>
<p>回顾这段求职之旅，我心存感激；在求职之路上，众多师兄、同门、同学及朋友们无私的援助与鼓励，为我提供了莫大的支持，在此深表感激！但在这漫长的求职期间，本人也留下诸多遗憾，在此也就不展开了。</p>
<p>最后，衷心希望每个人都能收获理想的 Offer。</p>
<p>———— 写于2024年7月5日。</p>
<hr>
<p>附一个工作投递的记录（部分）：<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705183838.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是 websocket？—— websocket 使用与简介]]></title>
        <id>https://blog.gitnote.cn/post/what_is_websocket/</id>
        <link href="https://blog.gitnote.cn/post/what_is_websocket/">
        </link>
        <updated>2024-07-01T06:25:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-什么是-websocket">1. 什么是 websocket</h2>
<h3 id="11-什么是-websocket">1.1 什么是 websocket</h3>
<p>WebSocket是一种在单个 TCP 连接上进行<mark>全双工通信</mark>的协议。<br>
WebSocket 使得浏览器（客户端）和服务器之间的数据交换变得更加简单，允许<mark>服务端主动向客户端推送数据</mark>。</p>
<h3 id="12-websocket-与-http-的区别">1.2 websocket 与 http 的区别</h3>
<p>常规的 http 协议的网站与应用中，一般都是<mark>浏览器（客户端）主动</mark>发送请求到服务端获取数据，服务端<mark>无法</mark>主动推送数据到浏览器（客户端）。</p>
<p>服务端想要发送数据到浏览器（客户端），都是使用<mark>http轮询</mark>的方式实现，即浏览器（客户端）主动发送请求到服务端，服务端将数据返回浏览器（客户端）中。</p>
<p>http轮询模式有很大的缺点，需要浏览器（客户端）一直向服务端发送请求，以获取服务器中的最新数据到浏览器（客户端）中，当服务器数据又不一定一直变化，这就造成了很多的浏览器（客户端）发送的请求是无效请求，造成了资源的严重浪费。</p>
<p>Websocket 协议和 HTTP 协议主要有以下区别：</p>
<ul>
<li>连接方式
<ul>
<li>HTTP 协议：基于请求-响应模式，客户端发起请求，服务器响应。每次请求和响应都需要建立和关闭连接。</li>
<li>Websocket 协议：建立一次连接后，保持连接状态，允许双向通信，无需频繁建立和关闭连接。</li>
</ul>
</li>
<li>数据传输方向
<ul>
<li>HTTP 协议：通常是客户端向服务器发送请求，服务器返回响应，数据传输方向主要是客户端到服务器。</li>
<li>Websocket 协议：支持服务器主动向客户端推送数据，实现双向实时通信。</li>
</ul>
</li>
<li>开销
<ul>
<li>HTTP 协议：每次请求和响应都包含较多的头部信息，造成一定的开销。</li>
<li>Websocket 协议：建立连接后的通信开销相对较小。</li>
</ul>
</li>
<li>实时性
<ul>
<li>HTTP 协议：不太适合实时数据的传输，实时性相对较差。</li>
<li>Websocket 协议：能够实现实时的数据交互，实时性强。</li>
</ul>
</li>
<li>应用场景
<ul>
<li>HTTP 协议：适用于大多数一般性的网页浏览、数据获取等。</li>
<li>Websocket 协议：常用于在线聊天、实时游戏、金融行情实时推送等需要实时交互的场景。</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="2-为什么需要-websocket">2. 为什么需要 websocket</h2>
<p>为了解决使用 http 协议的浏览器（客户端）无法快速获取服务器端的数据，websocket 就被发明了出来。</p>
<p>websocket 协议有如下优点：</p>
<ol>
<li>双向通信：允许服务器主动向客户端推送数据，实现实时交互，无需客户端频繁请求。</li>
<li>低延迟：建立连接后，数据传输的延迟相对较低，能够快速响应。</li>
<li>更少的开销：相比传统的 HTTP 请求-响应模式，减少了连接建立和关闭的开销。</li>
<li>高效的数据传输：可以发送二进制数据，提高了数据传输的效率。</li>
<li>保持连接：连接一旦建立，除非出现异常，否则会一直保持，节省了重新建立连接的时间和资源。</li>
<li>实时性强：适用于需要实时更新数据的应用，如在线游戏、实时监控等。</li>
</ol>
<h2 id="3-websocket-如何使用">3. websocket 如何使用</h2>
<p>websocket 具体使用需要客户端与服务器端的双重支持。</p>
<h3 id="31-websocket-服务器端代码是使用">3.1 websocket 服务器端代码是使用</h3>
<pre><code class="language-javascript">// 引入 websocket 库；可以使用 npm install ws 安装库
const WebSocket = require('ws');
// 创建一个 WebSocket 服务器，并监听 8080 端口
const wss = new WebSocket.Server({ port: 8080 });

// 当有客户端连接成功时触发此事件
wss.on('connection', (ws) =&gt; {
  // 当接收到客户端发送的消息时触发此事件
  ws.on('message', (message) =&gt; {
    // 打印接收到的消息
    console.log(`Received: ${message}`);
    // 向客户端发送一条消息
    ws.send(`You sent: ${message} , 这是一个服务器返回的消息`);
  });
  // 向刚连接的客户端发送一条欢迎消息
  ws.send('Welcome to the WebSocket server!');
});
</code></pre>
<p>在目录里新建一个名为 <code>app.js</code> 的文件，将上述代码拷贝进去保存；之后在当前目录中打开终端，在终端中输入 <code>node app.js</code> 即可运行一个 websocket 测试版服务端。</p>
<h3 id="32-浏览器客户端代码与使用">3.2 浏览器（客户端）代码与使用</h3>
<h4 id="321-浏览器端使用一">3.2.1 浏览器端使用一</h4>
<p>浏览器端可以使用第三方网站来测试与 3.1 中的 websocket 服务器端是否通联成功。<br>
测试网址为：<a href="http://www.websocket-test.com">http://www.websocket-test.com/</a></p>
<p>打开网址后在左上角输入 websocket 服务端地址与端口号，示例为：ws://127.0.0.1:8080</p>
<p>之后即可发送内容测试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/07/01/20240701141359.png" alt="" loading="lazy"></p>
<h4 id="322-浏览器使用二">3.2.2 浏览器使用二</h4>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;WebSocket Test&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;h2&gt;WebSocket 测试&lt;/h2&gt;
  &lt;div id=&quot;message&quot;&gt;&lt;/div&gt;

  &lt;script&gt;
    // 创建 WebSocket 连接
    var socket = new WebSocket(&quot;ws://localhost:8080&quot;);

    // 连接打开时触发
    socket.onopen = function (event) {
      var p = document.createElement('p');
      p.textContent = '连接已打开';
      document.getElementById('message').appendChild(p);
      socket.send('Hello, WebSocket!');
    };

    // 接收到消息时触发
    socket.onmessage = function (event) {
      var p = document.createElement('p');
      p.textContent = '收到消息: '+ event.data;
      document.getElementById('message').appendChild(p);
    };

    // 连接关闭时触发
    socket.onclose = function (event) {
      var p = document.createElement('p');
      p.textContent = '连接已关闭';
      document.getElementById('message').appendChild(p);
    };

    // 发生错误时触发
    socket.onerror = function (error) {
      var p = document.createElement('p');
      p.textContent = '错误: '+ error.message;
      document.getElementById('message').appendChild(p);
    };
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>在目录中新建一个文件 <code>index.html</code> ,将上述代码复制到 <code>index.html</code> 中，然后使用浏览器打开该文件。</p>
<figure data-type="image" tabindex="1"><img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F01%2F20240701141938.png" alt="" loading="lazy"></figure>
<h2 id="4-总结">4. 总结</h2>
<p>本文档是本人学习使用 websocket 的一点记录，文中的代码片段仅为最基础的测试代码，仅用于测试 websocket 双向通联是否成功。</p>
<p>写于：2024.07.01</p>
<hr>
<p>参考文档：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/690282564">https://zhuanlan.zhihu.com/p/690282564</a></li>
<li><a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html">https://www.cnblogs.com/chyingp/p/websocket-deep-in.html</a></li>
<li><a href="https://www.runoob.com/html/html5-websocket.html">https://www.runoob.com/html/html5-websocket.html</a></li>
<li><a href="http://www.websocket-test.com/">http://www.websocket-test.com/</a></li>
<li><a href="https://www.doubao.com/">https://www.doubao.com/</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构建NPS内网穿透服务客户端GUI界面]]></title>
        <id>https://blog.gitnote.cn/post/nps_gui/</id>
        <link href="https://blog.gitnote.cn/post/nps_gui/">
        </link>
        <updated>2024-04-07T09:18:40.000Z</updated>
        <summary type="html"><![CDATA[<p>本教程使用 PySimpleGUI 绘制内网穿透服务客户端 GUI页面，使用 pyinstaller 打包构建出 exe 程序，适用于windows 操作系统</p>
]]></summary>
        <content type="html"><![CDATA[<p>本教程使用 PySimpleGUI 绘制内网穿透服务客户端 GUI页面，使用 pyinstaller 打包构建出 exe 程序，适用于windows 操作系统</p>
<!-- more -->
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E9%97%AE%E9%A2%98%E6%9D%A5%E6%BA%90">1、问题来源</a></li>
<li><a href="#2-%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B">2、操作教程</a>
<ul>
<li><a href="#21-%E5%8E%9F%E7%90%86">2.1 原理</a></li>
<li><a href="#22-nps_gui%E7%95%8C%E9%9D%A2%E4%BB%A3%E7%A0%81">2.2 NPS_GUI界面代码</a></li>
<li><a href="#23-python-%E7%A8%8B%E5%BA%8F%E8%BD%AC-exe-%E7%A8%8B%E5%BA%8F">2.3 python 程序转 exe 程序</a></li>
</ul>
</li>
<li><a href="#3-%E6%80%BB%E7%BB%93">3、总结</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="1-问题来源">1、问题来源</h2>
<p>本人之前撰写过一个 <a href="https://blog.gitnote.cn/post/nps/">使用nps搭建内网穿透并配置泛域名解析</a>的教程，但其中的运行客户端程序使用的是 CMD 命令行进行操作，并且需要配置的参数较多，总是记不住。<br>
<img src="https://md.gitnote.cn/nps%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-1673272870029-20231922117.png" alt="" loading="lazy"></p>
<p>所以就在考虑是否能将 cmd 命令程序转成 EXE GUI程序，方便配置参数运行。本教程就营运而生了。</p>
<h2 id="2-操作教程">2、操作教程</h2>
<h3 id="21-原理">2.1 原理</h3>
<p>PySimpleGUI是一个用于创建图形用户界面（GUI）的Python模块。本教程使用 PySimpleGUI 为 NPS内网穿透客户端程序(v0.26.0)制作了一个GUI界面。</p>
<h3 id="22-nps_gui界面代码">2.2 NPS_GUI界面代码</h3>
<p>首先新建一个目录为 <code>nps_gui</code> ，在目录中新建一个 <code>main.py</code> 程序，并将与 <code>nps</code> 服务端配套的 <code>npc.exe</code> 文件复制到该目录下。<br>
<code>main.py</code> 程序为主程序，用来绘制 GUI 界面，调用 CMD 命令运行程序。<br>
<code>main.py</code> 程序内容如下：</p>
<pre><code class="language-python"># main.py

import subprocess
import threading
import PySimpleGUI as sg

# 定义版本号和作者信息
version = &quot;0.0.1&quot;
author = &quot;巧遇科技工作室&quot;
about_me = &quot;本程序是NPS内网穿透服务的GUI界面，用来辅助NPS内网穿透服务客户端进行使用，与之配套的NPS版本为0.26.10。&quot;

def read_output(process, output_element):
    &quot;&quot;&quot;
    读取子进程的输出并将其传递给GUI线程显示的函数
    &quot;&quot;&quot;
    for line in process.stdout:
        output_element.print(line.strip())

    for line in process.stderr:
        output_element.print(line.strip())

# 定义GUI布局
layout = [
    [sg.Menu([['关于', ['本程序介绍','版本号', '作者']]])],
    [sg.Text(&quot;服务端地址(IP):&quot;), sg.Input(default_text=&quot;nps.qiaoyukeji.cn&quot;,key=&quot;-ADDRESS-&quot;)],
    [sg.Text(&quot;服务端端口号:&quot;), sg.Input(default_text=&quot;28024&quot;,key=&quot;-PORT-&quot;)],
    [sg.Text(&quot;验证密钥(vkey):&quot;), sg.Input(key=&quot;-VKEY-&quot;)],
    [sg.Text(&quot;连接方式:&quot;), sg.Input(default_text=&quot;tcp&quot;,key=&quot;-TYPE-&quot;)],
    [sg.Button(&quot;连接远程穿透服务器&quot;), sg.Button(&quot;退出&quot;)],
    [sg.Output(size=(60, 10), key=&quot;-OUTPUT-&quot;)]
]

# 创建窗口
window = sg.Window(&quot;NPS内网穿透GUI工具（v0.0.1）&quot;, layout)
output_element = window[&quot;-OUTPUT-&quot;]

# 事件循环
while True:
    event, values = window.read()

    if event == sg.WINDOW_CLOSED or event == &quot;退出&quot;:
        break

    if event == &quot;连接远程穿透服务器&quot;:
        address = values[&quot;-ADDRESS-&quot;]
        port = values[&quot;-PORT-&quot;]
        vkey = values[&quot;-VKEY-&quot;]
        type = values[&quot;-TYPE-&quot;]

        command = f&quot;npc.exe -server={address}:{port} -vkey={vkey} -type={type}&quot;
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
            startupinfo=startupinfo,
            creationflags=subprocess.CREATE_NO_WINDOW
        )

        # 创建线程读取子进程输出并传递给GUI线程显示
        output_thread = threading.Thread(target=read_output, args=(process, output_element), daemon=True)
        output_thread.start()

    if event == &quot;版本号&quot;:
        sg.popup(f&quot;版本号: {version}&quot;)

    if event == &quot;作者&quot;:
        sg.popup(f&quot;作者: {author}&quot;)
    if event == &quot;本程序介绍&quot;:
        sg.popup(f&quot;{about_me}&quot;)

# 关闭窗口
window.close()
</code></pre>
<p>目录下输入 <code>python main.py</code> 运行程序，程序的运行图如下所示。</p>
<figure data-type="image" tabindex="1"><img src="http://img.upy.qiaoyukeji.cn/2024/04/06/20240406214012.png" alt="" loading="lazy"></figure>
<p>填写好自己的 nps 服务端的 网址(IP)、端口、验证密钥(vkey)与连接方式，点击连接显示连接成功。</p>
<figure data-type="image" tabindex="2"><img src="http://img.upy.qiaoyukeji.cn/2024/04/07/20240407164854.png" alt="" loading="lazy"></figure>
<p>至此，python 代码版的 nps 客户端 GUI 程序已完成。</p>
<h3 id="23-python-程序转-exe-程序">2.3 python 程序转 exe 程序</h3>
<p>python 版的程序虽然已经完成，但是需要电脑先安装 python 运行环境，并且安装对应的 python 库，之后运行 python 代码才能正真的运行起来程序，对于普通人来说过于麻烦与繁琐了。</p>
<p>能不能打包成 exe 文件，无需安装，双击就能运行呢？</p>
<p>答案是肯定的，就是使用 <code>pyinstaller</code> 。<br>
PyInstaller 是一个用于将 Python 应用程序打包成可执行文件的工具。它可以将 Python 脚本及其依赖的库、资源文件等打包成一个独立的可执行文件，方便在没有 Python 解释器的环境中运行。</p>
<p>首先安装使用 <code>pip install pyinstaller</code> 安装 <code>pyinstaller</code> ；<br>
之后在上面的目录中运行 PyInstaller 打包程序；</p>
<pre><code class="language-bash">pyinstaller --onefile --hidden-import PySimpleGUI main.py --name &quot;NPS内网穿透客户端GUI程序&quot;  --noconsole
</code></pre>
<blockquote>
<p>--onefile：指定生成一个单个的可执行文件，而不是生成一个文件夹包含多个文件。这意味着所有的依赖项将被打包到一个可执行文件中。</p>
<p>--hidden-import PySimpleGUI：指定需要导入的额外模块或库。在这个例子中，指定了需要导入PySimpleGUI库，因为脚本&quot;main.py&quot;中使用了PySimpleGUI。这样PyInstaller会确保将该库包含在生成的可执行文件中。</p>
<p>main.py：要打包的Python脚本的文件名或路径。在这个例子中，指定了&quot;main.py&quot;作为要打包的脚本。</p>
<p>--name &quot;NPS内网穿透客户端GUI程序&quot;：指定生成的可执行文件的名称。在这个例子中，指定了生成的可执行文件的名称为&quot;NPS内网穿透客户端GUI程序&quot;。</p>
<p>--noconsole：指定生成的可执行文件在运行时不显示控制台窗口。这适用于图形用户界面（GUI）应用程序，因为它们通常不需要显示控制台输出。</p>
</blockquote>
<p>上述打包程序就可以在目录下生成一个 <code>dist</code> 目录、将 <code>main.py</code> 打包成一个 <code>exe</code> 程序放置在 <code>dist</code> 目录中，然后我们需要将 <code>npc.exe</code> 也复制一份到 <code>dist</code> 目录中。</p>
<p><img src="http://img.upy.qiaoyukeji.cn/2024/04/07/20240407170648.png" alt="" loading="lazy"><br>
在 <code>dist</code> 目录中双击 <code>NPS内网穿透客户端GUI程序.exe</code> 即可正常运行 NPS_GUI 程序。</p>
<p>我们可以将  <code>NPS内网穿透客户端GUI程序.exe</code>  与 <code>npc.exe</code> 两个文件打包成一个压缩包发送给他人，他人无需安装配置运行环境、仅需解压缩后双击程序即可运行程序。</p>
<p>至此 nps 客户端程序 GUI 界面程序已全部完成。</p>
<h2 id="3-总结">3、总结</h2>
<p>本教程已在 Gitee、Github中进行开源。<br>
Gitee：https://gitee.com/qiaoyukeji/nps_gui<br>
Github：https://github.com/qiaoyukeji/nps_gui</p>
<p>本教程使用的是 <code>PySimpleGUI</code> 绘制 GUI 界面，由于 <code>PySimpleGUI</code>  库本身的问题，第一次使用会提示<mark>填入授权码</mark>或者<mark>选择忽略跳过</mark>。<br>
授权码 <code>PySimpleGUI</code> 官方免费提供，但需要注册领取，填入注册授权码后可一直免费使用。<br>
选择忽略将导致 <code>PySimpleGUI</code> 绘制的程序将只能试用31天，注册填入授权码即可解决</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nanopc-T4硬件连接与数据采集上传物联网平台交接文档（内部交接使用）]]></title>
        <id>https://blog.gitnote.cn/post/inside_001/</id>
        <link href="https://blog.gitnote.cn/post/inside_001/">
        </link>
        <updated>2024-04-03T12:41:17.000Z</updated>
        <summary type="html"><![CDATA[<p>本文档为实验室内部交接文档，无其他含义</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文档为实验室内部交接文档，无其他含义</p>
<!-- more -->
<h1 id="nanopc-t4硬件连接与数据采集上传">nanopc-T4硬件连接与数据采集上传</h1>
<p>内容：硬件交接（nanopc-T4）<br>
时间：2024.04.01</p>
<h2 id="一-nanopc-t4硬件连接">一、nanopc-T4硬件连接</h2>
<p>需要硬件：nanopc-T4、罗技C920摄像头、氨气传感器、四合一传感器等、RS485</p>
<h2 id="二-nanopc-t4运行软件">二、nanopc-T4运行软件</h2>
<h3 id="21-使用ssh协议连接nanopc-t4">2.1 使用SSH协议连接nanopc-T4</h3>
<p>将 nanopc-T4 与电脑连接到同一个网段（路由器）中，在电脑中安装 xshell 软件连接到 nanopc-T4。<br>
普通账号密码：pi，pi<br>
root账号密码：root，fa</p>
<h3 id="22-获取运行程序并修改设备id">2.2 获取运行程序并修改设备ID</h3>
<p>在nanopc-T4 中下载需要运行的程序，通过 Git 获取运行程序，https://gitee.com/qiaoyukeji/nanopc2jetlinks4mqtt，<br>
所有要运行的具体内容都在程序的 <code>test_008_mqttControl</code> 目录中，修改运行程序中的设备 ID</p>
<h3 id="23-设置程序的自动启动与nanopc-t4的自动重启">2.3 设置程序的自动启动与nanopc-T4的自动重启</h3>
<p>设置程序的自启动等方法在 <code>test_008_mqttControl</code> 中的 readme.md 中</p>
<h2 id="三-物联网平台相关操作">三、物联网平台相关操作</h2>
<p>平台网址：http://aau.aau506.cn<br>
账号密码：</p>
<h3 id="31-新建设备">3.1 新建设备</h3>
<p>按前期标准设置 id 号</p>
<h3 id="32-设置连接密钥并配置物模型">3.2 设置连接密钥并配置物模型</h3>
<p>设置好连接的账号密码、并配置好属性定义物模型与功能定义物模型</p>
<h2 id="四-视频实时采集">四、视频实时采集</h2>
<h3 id="41-腾讯云直播仅需第一次修改">4.1 腾讯云直播（仅需第一次修改）</h3>
<p>添加推流域名，领取免费的20G测试流量</p>
<h3 id="42-域名解析仅需第一次修改">4.2 域名解析（仅需第一次修改）</h3>
<h3 id="43-nanopc-t4端运行">4.3 nanopc-T4端运行</h3>
<p>运行程序在 <code>test_009_onlyFFmpeg</code> 目录中</p>
<h3 id="44-可视化展示端修改程序展示仅需第一次修改">4.4 可视化展示端修改程序展示（仅需第一次修改）</h3>
<p>修改 大数据可视化界面的 <code>play.js</code><br>
平台网址：http://1.117.229.138:8888/qiaoyu<br>
账号密码：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023年年度总结回顾（流水账）]]></title>
        <id>https://blog.gitnote.cn/post/2023/</id>
        <link href="https://blog.gitnote.cn/post/2023/">
        </link>
        <updated>2024-01-03T03:08:10.000Z</updated>
        <summary type="html"><![CDATA[<p>2023年是难忘的一年，前半年主要在改小论文、写程序、调试开发板；后半年主要找工作、准备考试等，时间过的非常的匆忙，以至于比以前少了很多的乐趣，本次将 2023 年的一些我的日常活动做个流水账总结，自我勉励。</p>
]]></summary>
        <content type="html"><![CDATA[<p>2023年是难忘的一年，前半年主要在改小论文、写程序、调试开发板；后半年主要找工作、准备考试等，时间过的非常的匆忙，以至于比以前少了很多的乐趣，本次将 2023 年的一些我的日常活动做个流水账总结，自我勉励。</p>
<!-- more -->
<blockquote>
<p>待到秋来九月八，我花开后百花杀。冲天香阵透长安，满城尽带黄金甲。</p>
</blockquote>
<h1 id="一-年度数据总结">一、 年度数据总结</h1>
<h2 id="博客文章">博客文章：</h2>
<p>2023年，本人共撰写博客教程 17 篇，分别发布在本人博客、CSDN、知乎、掘金等平台上；个人博客浏览量 14562，CSDN 浏览量 16217，知乎浏览量 3.7 万，掘金浏览量 5624 ，总浏览量（不完全统计）7.5万，总收藏量 300+ 。</p>
<h2 id="githubgitee">Github&amp;Gitee：</h2>
<p>2023年，本人在 Github/Gitee 平台开源项目 4个，提交代码 100+ 次，收获 Star 14 个，fork 2 次。</p>
<figure data-type="image" tabindex="1"><img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102194729.png" alt="" loading="lazy"></figure>
<h1 id="二-年度流水账">二、年度流水账</h1>
<p>由于2022年年底众所周知的原因，学校提前放假，我也早早的回家了。</p>
<ul>
<li>
<p>2023年1月1日，老家，干枯的池塘。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/03/20240103194921.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年1月15日，老家，下雪了。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/03/20240103195112.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年1月19日，老家，年前一起炸糯米圆子。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102142956.jpg" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年1月30日，独秀山一日游 + 家乡池塘网鱼。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102143307.png" alt="" loading="lazy"><img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102143452.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年2月11日，开学了，实验室一起吃火锅。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102143722.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年2月18，在学校，已毕业的师兄组局请吃饭。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102144112.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年2月20日~2023年2月22日，实验室一起出差去合作的养殖基地。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102144450.png" alt="" loading="lazy"><br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102144546.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年3月4日，实验室小伙伴们一起植物园一日游。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102144819.png" alt="" loading="lazy"></p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102144918.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>2023年3月11日，和小伙伴们一起牛蛙铜火锅搞起。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102145231.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年3月13日~2023年3月14日，第二次出差去养殖基地安装设备。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102145531.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年3月30日，去医院拔牙齿，拔完最后一颗歪的智齿，吃了一周流食。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102165905.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年4月7日，由于元旦提前放假了，没有一起吃饭，老师补请吃饭。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102170221.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年4月9日，实验室一行十多人出发去往巢湖姆山岛一日游。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102170429.png" alt="" loading="lazy"><br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102170533.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年5月20日，研一开题结束，实验室一行去火锅撸串。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102170859.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年5月27日，在实验室看恐怖片。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102184625.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年6月2日，无线电台执照 GET。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102184850.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年6月4日，实验室毕业答辩通过聚餐。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102185101.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年6月17日，师兄们毕业请吃饭。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102185258.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年7月1日，杏花公园相亲角。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102185702.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年7月、8月、9月、10月部分数据丢失。</p>
</li>
<li>
<p>2023年11月22日，工作没找到，却收到了智联招聘邮寄的 J20 模型。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102190519.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年11月26日，参加 2024年国家公务员考试，考试内容非常难，试卷都没有写完；考试地点也非常远，连车都打不到。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102191420.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年12月3日，参加国家电网校园招聘统一考试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102192111.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年12月9日，参加南方电网校园招聘统一考试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102192415.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年12月16日，考完四六级小伙伴们一起吃火锅。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102192625.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年12月18日，下大雪了。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102192803.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年12月31日，跨年夜吃饭等了好久，有两个多小时，庐州太太给打了 8.5 折。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102193053.png" alt="" loading="lazy"></p>
</li>
</ul>
<hr>
<p>2023年下半年非常之忙，一边投简历找工作、一边准备各项考试。投简历投了大概 100+ 家，收到笔试没多少，面试更是寥寥无几，工作难找呀。</p>
<p>希望 2024 年找工作能够顺风顺水，论文写作也能够一帆风顺。</p>
<figure data-type="image" tabindex="3"><img src="http://img.upy.qiaoyukeji.cn/2024/01/03/20240103101742.png" alt="" loading="lazy"></figure>
<blockquote>
<p>他日若遂凌云志，敢笑黄巢不丈夫。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust编程入门——第三章_通用编程概念]]></title>
        <id>https://blog.gitnote.cn/post/rust_learn_003/</id>
        <link href="https://blog.gitnote.cn/post/rust_learn_003/">
        </link>
        <updated>2023-12-26T12:59:57.000Z</updated>
        <summary type="html"><![CDATA[<p>一门赋予每个人构建可靠且高效软件能力的语言。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一门赋予每个人构建可靠且高效软件能力的语言。</p>
<!-- more -->
<h2 id="第三章-通用编程概念">第三章  通用编程概念</h2>
<ul>
<li>变量与可变性</li>
<li>数据类型
<ul>
<li>标量类型</li>
<li>符合类型</li>
</ul>
</li>
<li>函数</li>
<li>注释</li>
<li>控制流</li>
</ul>
<h3 id="31-变量与可变性">3.1 变量与可变性</h3>
<h4 id="311-变量">3.1.1 变量</h4>
<ul>
<li>申明变量使用 <code>let</code> 关键字</li>
<li>默认情况下，变量是不可变的（<code>immutable</code>）</li>
</ul>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    let x: i32=5;
    println!(&quot;the value of x is {}&quot;,x);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://img.upy.qiaoyukeji.cn/2023/12/25/20231225152936.png" alt="" loading="lazy"></figure>
<ul>
<li>申明变量时，在变量前面加上 <code>mut</code>，就可以使变量可变</li>
</ul>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    let mut x: i32=5;
    x=8;
    println!(&quot;the value of x is {}&quot;,x);
}
</code></pre>
<h4 id="312-常量">3.1.2 常量</h4>
<ul>
<li>常量（<code>constant</code>），常量在绑定值以后是不可变的，但是让他与不可变的变量有很多区别：
<ul>
<li>不可以使用 <code>mut</code> ，常量永远都是不可变的</li>
<li>申明常量使用 <code>const</code> 关键字，它的类型必须被标注</li>
<li>常量可以在任何作用域内申明，包括全局作用域</li>
<li>常量只能绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算的值</li>
</ul>
</li>
<li>在程序运行期间，常量在其申明的作用域内一直有效</li>
<li>命名规范：<code>Rust</code> 里常量使用全大写字母，每个单词之间用下划线分开，例如：
<ul>
<li><code>MAX_POINTS</code></li>
<li><code>const MAX_POINTS:u32 = 100_000;</code></li>
</ul>
</li>
</ul>
<pre><code class="language-rust">const MAX_POINTS:u32 = 100_000;

fn main() {
    println!(&quot;Hello, world!&quot;);
    println!(&quot;the number is {}&quot;,MAX_POINTS)
}

</code></pre>
<h4 id="313-shadowing隐藏">3.1.3 <code>Shadowing</code>（隐藏）</h4>
<ul>
<li>可以使用相同的名字申明新的变量，新的变量就会 <code>Shadow</code>（隐藏）之前申明的同名变量
<ul>
<li>在后续的代码中这个变量名代表的就是新的变量</li>
</ul>
</li>
</ul>
<pre><code class="language-rust">const MAX_POINTS:u32 = 100_000;

fn main() {
    println!(&quot;Hello, world!&quot;);

    println!(&quot;the number is {}&quot;,MAX_POINTS)
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://img.upy.qiaoyukeji.cn/2023/12/25/20231225154756.png" alt="" loading="lazy"></figure>
<ul>
<li><code>Shadow</code> 和把变量标记为 <code>mut</code> 是不一样的：
<ul>
<li>如果不使用 <code>let</code> 关键字，那么重新给非 <code>mut</code> 的变量赋值会导致编译错误</li>
<li>而使用 <code>let</code> 申明的同名新变量，也是不可变的</li>
<li>使用 <code>let</code> 申明的同名新变量，他的类型可以与之前不同</li>
</ul>
</li>
</ul>
<pre><code class="language-rust">fn main() {
    let spaces = &quot;    &quot;;
    let spaces=spaces.len();
    
    println!(&quot;the number is {}&quot;, spaces)  // 4
}
</code></pre>
<h3 id="32-数据类型">3.2 数据类型</h3>
<ul>
<li>标量和复合类型</li>
<li><code>Rust</code> 是静态编译语言，在编译时必须知道所有变量的类型
<ul>
<li>基于使用的值，编译器通常能够推断出它的具体类型</li>
<li>但如果可能的类型较多（如将 <code>String</code> 转为整数的 <code>parse</code> 方法），就必须添加类型的标注，否则编译会报错</li>
</ul>
</li>
</ul>
<pre><code class="language-rust">fn main() {
    let guess:i32 = &quot;42&quot;.parse().expect(&quot;not a number&quot;);

    println!(&quot;number is {}&quot;,guess);
}
</code></pre>
<h4 id="321-标量类型">3.2.1 标量类型</h4>
<ul>
<li>一个标量类型代表一个单个的值</li>
<li>Rust 有四个主要的标量类型：
<ul>
<li>整数类型</li>
<li>浮点类型</li>
<li>布尔类型</li>
<li>字符类型</li>
</ul>
</li>
</ul>
<h4 id="322-整数类型">3.2.2 整数类型</h4>
<h5 id="3221-基础介绍">3.2.2.1 基础介绍</h5>
<ul>
<li>
<p>整数类型没有小数部分</p>
</li>
<li>
<p>例如 <code>u32</code> 就是一个无符号的整数类型，占据32位空间</p>
</li>
<li>
<p>无符号整数类型以 <code>u</code> 开头</p>
</li>
<li>
<p>有符号整数类型以 <code>i</code> 开头</p>
</li>
<li>
<p>Rust 的整数类型列表如图：</p>
<ul>
<li>每种都分为 i 和 u ，以及固定位数</li>
<li>有符号的范围： -2<sup>(n-1)~2</sup>(n-1)-1</li>
<li>无符号的范围：0~2^n-1</li>
</ul>
<figure data-type="image" tabindex="3"><img src="http://img.upy.qiaoyukeji.cn/2023/12/25/20231225185142.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h5 id="3222-isize-和-usize">3.2.2.2 <code>isize</code> 和 <code>usize</code></h5>
<ul>
<li><code>isize</code> 和 <code>usize</code> 类型的位数由程序运行的计算机的架构所决定的：</li>
<li>如果是 64 位计算机，那就是 64 位的</li>
<li>使用 <code>isize</code> 和 <code>usize</code> 的主要场景是对某种集合进行索引操作</li>
</ul>
<h5 id="3223-整数字面值">3.2.2.3 整数字面值</h5>
<ul>
<li>除了 <code>byte</code> 类型外，所有的数值字面值都允许使用类型后缀
<ul>
<li>例如 <code>57u8</code></li>
</ul>
</li>
<li>如果不太清楚应该使用那种类型，可以使用 <code>Rust</code> 相应的默认类型</li>
<li>整数的默认类型就是 <code>i32</code>
<ul>
<li>总体上来说速冻更快，即使在 64 位系统中</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="http://img.upy.qiaoyukeji.cn/2023/12/25/20231225190417.png" alt="" loading="lazy"></figure>
<h5 id="3224-整数溢出">3.2.2.4 整数溢出</h5>
<ul>
<li>例如：u8 的范围是 0-255，如果你把一个 u8 变量的值设为 256 ，那么：
<ul>
<li>调试模式下编译：Rust 会检查整数溢出，如果发生溢出，程序在运行时就会 panic</li>
<li>发布模式下(--release)编译：Rust 不会检查可能导致 panic 的整数溢出
<ul>
<li>如果溢出发生：Rust 会执行“环绕”操作：
<ul>
<li>256 变成 0，257 变成 1 ...</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="323-浮点类型">3.2.3 浮点类型</h4>
<h5 id="3231-基础介绍">3.2.3.1 基础介绍</h5>
<ul>
<li>Rust 有两种基础的浮点类型，也就是含有小数部分的类型
<ul>
<li><code>f32</code>，32位，单精度</li>
<li><code>f64</code>，64为，双精度</li>
</ul>
</li>
<li>Rust 的浮点类型使用了 <code>IEEE-754</code> 标准来表达</li>
<li><code>f64</code> 是默认类型，因为在现代 CPU 上 <code>f64</code> 和 <code>f32</code> 的速度差不多，而且精度更高</li>
</ul>
<h5 id="3232-数值操作">3.2.3.2 数值操作</h5>
<ul>
<li>加减乘除余等</li>
</ul>
<pre><code class="language-rust">fn main() {
    let sum = 5 + 10;

    let difference = 95.5 - 4.3;

    let product = 4 * 30;

    let quotient = 56.7 / 32.2;

    let reminder = 54 % 5;
}
</code></pre>
<h4 id="324-布尔类型">3.2.4 布尔类型</h4>
<ul>
<li>Rust 的布尔类型也有两个值：true 和 false</li>
<li>一个字节大小</li>
<li>符号是 bool</li>
</ul>
<pre><code class="language-rust">fn main() {
    let t = true;
    let m: bool = false;
}
</code></pre>
<h4 id="325-字符类型">3.2.5 字符类型</h4>
<ul>
<li>Rust 语言中 char 类型被用来描述语言中最基础的单个字符。</li>
<li>字符类型的字面值使用单引号</li>
<li>占用 4 个字节大小</li>
<li>是 Unicode 标量值，可以表示比 ASCII 多得多的字符内容：拼音、中日韩文、零长度空白字符、emoji表情等。
<ul>
<li><code>U+0000</code> 到 <code>U+D7FF</code></li>
<li><code>U+E000</code> 到 <code>U+10FFFF</code></li>
</ul>
</li>
<li>但 Unicode 中并没有 “字符” 的概念，所以直觉上认为的字符也许与 Rust 中的概念并不相符</li>
</ul>
<pre><code class="language-rust">fn main() {
    let x: &amp;str = &quot;z&quot;;
    let y: char='z';
    let z: char='😂';
}
</code></pre>
<h3 id="33-复合类型">3.3 复合类型</h3>
<ul>
<li>复合类型可以将多个值放在一个类型里。</li>
<li>Rust 提供了两种基础的复合类型：元组（Tuple）、数组</li>
</ul>
<h4 id="331-元组tuple">3.3.1 元组（Tuple）</h4>
<ul>
<li>Tuple 可以将多个类型的多个值放到一个类型里</li>
<li>Tuple 的长度是固定的：一旦申明就无法改变</li>
</ul>
<h5 id="3311-创建-tuple">3.3.1.1 创建 Tuple</h5>
<ul>
<li>在小括号里，将值用逗号分开</li>
<li>Tuple 中的每一个位置都对应一个类型，Tuple 中个元素的类型不必相同</li>
</ul>
<pre><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) =(500,6.4,1);
    println!(&quot;{},{},{}&quot;,tup.0,tup.1,tup.2);
}
</code></pre>
<h5 id="3312-获取-tuple-的元素值">3.3.1.2 获取 Tuple 的元素值</h5>
<ul>
<li>可以使用模式匹配来解构（destructure）一个 Tuple 来获取元素的值</li>
</ul>
<pre><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) =(500,6.4,1);

    let (x,y,z) =tup;
    println!(&quot;{},{},{}&quot;,x,y,z);
}
</code></pre>
<h5 id="3313-访问-tuple-的元素">3.3.1.3 访问 Tuple 的元素</h5>
<ul>
<li>在 Tuple 变量使用点标记法，后接元素的索引号</li>
</ul>
<pre><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) =(500,6.4,1);
    println!(&quot;{},{},{}&quot;,tup.0,tup.1,tup.2);
}
</code></pre>
<h4 id="332-数组">3.3.2 数组</h4>
<ul>
<li>数组也可以将多个值放在同一个类型里</li>
<li>数组中每个元素的类型必须相同</li>
<li>数组的长度也是固定的</li>
</ul>
<h5 id="3321-申明数组">3.3.2.1 申明数组</h5>
<ul>
<li>在中括号里，各值用逗号分开</li>
</ul>
<pre><code class="language-rust">fn main() {
    let a = [1,2,3,4,5];
}
</code></pre>
<h5 id="3322-数组的用处">3.3.2.2 数组的用处</h5>
<ul>
<li>如果想让数据存放在 stack（栈）上而不是 heap（堆）上，或者想保证有固定数量的元素，这时使用数组更有好处</li>
<li>数组没有 Vector 灵活
<ul>
<li>Vector 和数组类似，它由标准库提供</li>
<li>Vector 的长度可以改变</li>
<li>如果你不确定应该使用数组还是 Vector ，那么估计你应该使用 Vector</li>
</ul>
</li>
</ul>
<h5 id="3323-数组的类型">3.3.2.3 数组的类型</h5>
<ul>
<li>数组的类型表示形式：[类型；长度]
<ul>
<li>例如：<code>let a:[i32;5] = [1,2,3,4,5];</code></li>
</ul>
</li>
</ul>
<h5 id="3324-另一种申明数组的方式">3.3.2.4 另一种申明数组的方式</h5>
<ul>
<li>如果数组的每个元素都相同，那么可以：
<ul>
<li>在中括号中指定初始值</li>
<li>然后是一个 &quot;;&quot;</li>
<li>最后是数组的长度</li>
<li>例如：<code>let a=[3;5];</code> 相当于 <code>let a = [3,3,3,3,3];</code></li>
</ul>
</li>
</ul>
<h5 id="3325-访问数组的元素">3.3.2.5 访问数组的元素</h5>
<ul>
<li>数组是在 stack 上分配的单个块的内存</li>
<li>可以使用索引来访问数组的元素</li>
<li>如果访问的索引<mark>超出了数组的范围</mark>，那么
<ul>
<li>编译会通过</li>
<li>运行会报错（runtime 时会 panic ）
<ul>
<li>Rust 不会允许其继续访问相应地址的内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-rust">fn main() {
    let a = [1,2,3,4,5];

    let first = a[0];
    let second = a[1];
}
</code></pre>
<h3 id="34-函数">3.4 函数</h3>
<ul>
<li>申明函数使用 fn 关键字</li>
<li>按照惯例，针对函数与变量名，Rust 使用 snake case 命名规范：
<ul>
<li>所有的字母都是小写，单词之间使用下划线分开</li>
</ul>
</li>
</ul>
<pre><code class="language-rust">fn main() {
    println!(&quot;hello world!&quot;);
    another_function();
}

fn another_function(){
    println!(&quot;Another function&quot;);
}
</code></pre>
<h4 id="341-函数的参数">3.4.1 函数的参数</h4>
<ul>
<li><code>parameters</code>、<code>arguments</code></li>
<li>在函数签名里，必须包含每个参数的类型</li>
</ul>
<pre><code class="language-rust">fn main() {
    println!(&quot;hello world!&quot;);
    another_function(5);    // argument
}

fn another_function(x:i32){    // parameter
    println!(&quot; the number is {}&quot;,x);
}
</code></pre>
<h4 id="342-函数体中的语句与表达式">3.4.2 函数体中的语句与表达式</h4>
<ul>
<li>函数体由一系列语句组成，可选的由一个表达式结束</li>
<li>Rust 是一个基于表达式的语言</li>
<li>语句是执行一些动作的指令</li>
<li>表达式会计算产生一个值</li>
<li>函数定义也是语句</li>
<li>语句不返回值，所以不可以使用 let 将一个语句赋给一个变量</li>
</ul>
<h4 id="343-函数的返回值">3.4.3 函数的返回值</h4>
<ul>
<li>在 <code>-&gt;</code> 符号后边申明函数返回值的类型，但是不可以为返回值命名</li>
<li>在 Rust 中，返回值就是函数体里面<mark>最后一个表达式的值</mark></li>
<li>若想提前返回。需使用 return 关键字，并指定一个值</li>
</ul>
<pre><code class="language-rust">fn main() {
    let x=five(1);
    println!(&quot;the number is {}&quot;,x); // 6
}

fn five(x:i32)-&gt;i32{
    x+5
}
</code></pre>
<h3 id="35-控制流-if-else">3.5 控制流 ：if else</h3>
<h4 id="351-if-表达式">3.5.1 if 表达式</h4>
<ul>
<li>if 表达式允许您根据条件来执行不同的代码分支
<ul>
<li>这个条件必须是bool类型</li>
</ul>
</li>
<li>if 表达式中，与条件相关联的代码块就叫做分支（arm）</li>
<li>可选的，在后边可以加上一个 else 表达式</li>
</ul>
<pre><code class="language-rust">fn main() {
    let num=3;
    if num&lt;5{
        println!(&quot;true&quot;);
    }else {
        println!(&quot;false&quot;);
    }
}
</code></pre>
<h4 id="352-使用-else-if-处理多重条件">3.5.2 使用 else if 处理多重条件</h4>
<ul>
<li>如果使用了多于一个 else if ，那么最好使用 match 来重构代码</li>
</ul>
<h4 id="353-在-let-语句中使用-if">3.5.3 在 let 语句中使用 if</h4>
<ul>
<li>因为 if 是一个表达式，所以可以将它放在 let 语句中等号的右边</li>
</ul>
<pre><code class="language-rust">fn main() {
    let condition = true;

    let num = if condition { 5 } else { 6 };
    
    println!(&quot;the number is {}&quot;,num);    // 5
}
</code></pre>
<h3 id="36-控制流-rust-的循环">3.6 控制流： Rust 的循环</h3>
<ul>
<li>Rust 提供了 3 中循环：loop，while 和 for</li>
</ul>
<h4 id="361-loop-循环">3.6.1 loop 循环</h4>
<ul>
<li>loop 关键字告诉 Rust 反复的执行一块代码，直到喊停</li>
<li>可以在 loop 循环中使用 break 关键字来告诉程序何时停止循环</li>
</ul>
<pre><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;the result is {}&quot;, result);    // 20
}
</code></pre>
<h4 id="362-while-条件循环">3.6.2 while 条件循环</h4>
<ul>
<li>另外一种常见的循环模式是每次执行循环体之前都判断一次条件</li>
<li>while条件循环为这种模式而生</li>
</ul>
<pre><code class="language-rust">fn main() {
    let mut counter = 3;

    while counter != 0 {
        println!(&quot;number is {}&quot;, counter);
        counter = counter - 1;
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre>
<h4 id="363-使用-for-循环遍历集合">3.6.3 使用 for 循环遍历集合</h4>
<ul>
<li>可是使用 while 或 loop 来遍历集合，但是易错且低效</li>
</ul>
<pre><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;{}&quot;, a[index]);

        index += 1;
    }
}
</code></pre>
<ul>
<li>使用 for 循环更简洁紧凑，它可以针对集合中的每个元素来执行一些代码</li>
</ul>
<pre><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    for element in a.iter(){
        println!(&quot;{}&quot;,element);
    }
}
</code></pre>
<ul>
<li>由于 for 循环的安全、简洁性，所以它在 Rust 里用的最多</li>
</ul>
<h4 id="364-range">3.6.4 Range</h4>
<ul>
<li>标准库提供</li>
<li>指定一个开始数字和一个结束数字，Range 可以生成它们之间的数字（不含结束）</li>
<li>rev 方法可以反转 Range</li>
</ul>
<pre><code class="language-rust">fn main() {
    for number in (1..4).rev(){
        println!(&quot;{}&quot;,number);
    }
    println!(&quot;LIFTOFF!!!&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++学习——01.C++基础]]></title>
        <id>https://blog.gitnote.cn/post/C++_001/</id>
        <link href="https://blog.gitnote.cn/post/C++_001/">
        </link>
        <updated>2023-10-04T09:15:04.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#c%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8">C++基础入门</a>
<ul>
<li><a href="#1-c%E5%88%9D%E8%AF%86">1 C++初识</a>
<ul>
<li><a href="#11-%E7%AC%AC%E4%B8%80%E4%B8%AAc%E7%A8%8B%E5%BA%8F">1.1  第一个C++程序</a>
<ul>
<li><a href="#111-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">1.1.1 创建项目</a></li>
<li><a href="#112-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6">1.1.2 创建文件</a></li>
<li><a href="#113-%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81">1.1.3 编写代码</a></li>
<li><a href="#114-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F">1.1.4 运行程序</a></li>
</ul>
</li>
<li><a href="#12-%E6%B3%A8%E9%87%8A">1.2 注释</a></li>
<li><a href="#14-%E5%B8%B8%E9%87%8F">1.4  常量</a></li>
<li><a href="#15-%E5%85%B3%E9%94%AE%E5%AD%97">1.5 关键字</a></li>
</ul>
</li>
<li><a href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2 数据类型</a>
<ul>
<li><a href="#21-%E6%95%B4%E5%9E%8B">2.1 整型</a></li>
<li><a href="#22-sizeof%E5%85%B3%E9%94%AE%E5%AD%97">2.2 sizeof关键字</a></li>
<li><a href="#24-%E5%AD%97%E7%AC%A6%E5%9E%8B">2.4 字符型</a></li>
<li><a href="#25-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6">2.5 转义字符</a></li>
<li><a href="#26-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B">2.6 字符串型</a></li>
<li><a href="#28-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5">2.8 数据的输入</a></li>
</ul>
</li>
<li><a href="#3-%E8%BF%90%E7%AE%97%E7%AC%A6">3 运算符</a>
<ul>
<li><a href="#31-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">3.1 算术运算符</a></li>
<li><a href="#32-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">3.2 赋值运算符</a></li>
<li><a href="#33-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6">3.3 比较运算符</a></li>
<li><a href="#34-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">3.4 逻辑运算符</a></li>
<li><a href="#41-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84">4.1 选择结构</a>
<ul>
<li><a href="#411-if%E8%AF%AD%E5%8F%A5">4.1.1 if语句</a></li>
<li><a href="#412-%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6">4.1.2 三目运算符</a></li>
<li><a href="#413-switch%E8%AF%AD%E5%8F%A5">4.1.3 switch语句</a></li>
</ul>
</li>
<li><a href="#42-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">4.2 循环结构</a>
<ul>
<li><a href="#421-while%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">4.2.1 while循环语句</a></li>
<li><a href="#422-dowhile%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">4.2.2 do...while循环语句</a></li>
<li><a href="#423-for%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">4.2.3 for循环语句</a></li>
<li><a href="#424-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF">4.2.4 嵌套循环</a></li>
</ul>
</li>
<li><a href="#43-%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5">4.3 跳转语句</a>
<ul>
<li><a href="#431-break%E8%AF%AD%E5%8F%A5">4.3.1 break语句</a></li>
<li><a href="#432-continue%E8%AF%AD%E5%8F%A5">4.3.2 continue语句</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-%E6%95%B0%E7%BB%84">5 数组</a>
<ul>
<li><a href="#51-%E6%A6%82%E8%BF%B0">5.1 概述</a></li>
<li><a href="#52-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">5.2 一维数组</a>
<ul>
<li><a href="#521-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F">5.2.1 一维数组定义方式</a></li>
<li><a href="#522-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E5%90%8D">5.2.2 一维数组数组名</a></li>
</ul>
</li>
<li><a href="#53-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">5.3 二维数组</a>
<ul>
<li><a href="#531-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F">5.3.1 二维数组定义方式</a></li>
<li><a href="#532-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E5%90%8D">5.3.2 二维数组数组名</a></li>
<li><a href="#533-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><strong>5.3.3 二维数组应用案例</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-%E5%87%BD%E6%95%B0">6 函数</a>
<ul>
<li><a href="#61-%E6%A6%82%E8%BF%B0">6.1 概述</a></li>
<li><a href="#62-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">6.2 函数的定义</a></li>
<li><a href="#64-%E5%80%BC%E4%BC%A0%E9%80%92">6.4 值传递</a></li>
<li><a href="#65-%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F"><strong>6.5 函数的常见样式</strong></a></li>
</ul>
</li>
<li><a href="#7-%E6%8C%87%E9%92%88">7 指针</a>
<ul>
<li><a href="#71-%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">7.1 指针的基本概念</a></li>
<li><a href="#72-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8">7.2 指针变量的定义和使用</a></li>
<li><a href="#76-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84">7.6 指针和数组</a></li>
<li><a href="#78-%E6%8C%87%E9%92%88-%E6%95%B0%E7%BB%84-%E5%87%BD%E6%95%B0">7.8 指针、数组、函数</a></li>
</ul>
</li>
<li><a href="#8-%E7%BB%93%E6%9E%84%E4%BD%93">8 结构体</a>
<ul>
<li><a href="#81-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">8.1 结构体基本概念</a></li>
<li><a href="#82-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8">8.2 结构体定义和使用</a></li>
<li><a href="#83-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84">8.3 结构体数组</a></li>
<li><a href="#85-%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93">8.5 结构体嵌套结构体</a></li>
<li><a href="#86-%E7%BB%93%E6%9E%84%E4%BD%93%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">8.6 结构体做函数参数</a></li>
<li><a href="#87-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD-const%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">8.7 结构体中 const使用场景</a></li>
<li><a href="#88-%E7%BB%93%E6%9E%84%E4%BD%93%E6%A1%88%E4%BE%8B">8.8 结构体案例</a>
<ul>
<li><a href="#881-%E6%A1%88%E4%BE%8B1">8.8.1 案例1</a></li>
<li><a href="#882-%E6%A1%88%E4%BE%8B2">8.8.2 案例2</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="c基础入门">C++基础入门</h1>
<h2 id="1-c初识">1 C++初识</h2>
<h3 id="11-第一个c程序">1.1  第一个C++程序</h3>
<p>编写一个C++程序总共分为4个步骤</p>
<ul>
<li>创建项目</li>
<li>创建文件</li>
<li>编写代码</li>
<li>运行程序</li>
</ul>
<h4 id="111-创建项目">1.1.1 创建项目</h4>
<p>​	Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</p>
<p><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004172903.png" alt="" loading="lazy"><br>
<img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004172929.png" alt="" loading="lazy"></p>
<h4 id="112-创建文件">1.1.2 创建文件</h4>
<p>右键源文件，选择添加-&gt;新建项</p>
<figure data-type="image" tabindex="1"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173001.png" alt="" loading="lazy"></figure>
<p>给C++文件起个名称，然后点击添加即可。</p>
<figure data-type="image" tabindex="2"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173035.png" alt="" loading="lazy"></figure>
<h4 id="113-编写代码">1.1.3 编写代码</h4>
<pre><code class="language-c++">#include&lt;iostream&gt;
using namespace std;

int main() {

	cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="114-运行程序">1.1.4 运行程序</h4>
<figure data-type="image" tabindex="3"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173103.png" alt="" loading="lazy"></figure>
<h3 id="12-注释">1.2 注释</h3>
<p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p>
<p><strong>两种格式</strong></p>
<ol>
<li><strong>单行注释</strong>：<code>// 描述信息</code>
<ul>
<li>通常放在一行代码的上方，或者一条语句的末尾，<mark>对该行代码说明</mark></li>
</ul>
</li>
<li><strong>多行注释</strong>： <code>/* 描述信息 */</code>
<ul>
<li>通常放在一段代码的上方，<mark>对该段代码做整体说明</mark></li>
</ul>
</li>
</ol>
<blockquote>
<p>提示：编译器在编译代码时，会忽略注释的内容### 1.3 变量</p>
</blockquote>
<p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p>
<p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include&lt;iostream&gt;
using namespace std;

int main() {

	//变量的定义
	//语法：数据类型  变量名 = 初始值

	int a = 10;

	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p>
</blockquote>
<h3 id="14-常量">1.4  常量</h3>
<p><strong>作用</strong>：用于记录程序中不可更改的数据</p>
<p>C++定义常量两种方式</p>
<ol>
<li><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code>
<ul>
<li><mark>通常在文件上方定义</mark>，表示一个常量2. <strong>const</strong>修饰的变量 <code>const 数据类型 常量名 = 常量值</code></li>
<li><mark>通常在变量定义前加关键字const</mark>，修饰该变量为常量，不可修改<br>
<strong>示例：</strong></li>
</ul>
</li>
</ol>
<pre><code class="language-C++">//1、宏常量
#define day 7

int main() {

	cout &lt;&lt; &quot;一周里总共有 &quot; &lt;&lt; day &lt;&lt; &quot; 天&quot; &lt;&lt; endl;
	//day = 8;  //报错，宏常量不可以修改

	//2、const修饰变量
	const int month = 12;
	cout &lt;&lt; &quot;一年里总共有 &quot; &lt;&lt; month &lt;&lt; &quot; 个月份&quot; &lt;&lt; endl;
	//month = 24; //报错，常量是不可以修改的
	
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="15-关键字">1.5 关键字</h3>
<p>**作用：**关键字是C++中预先保留的单词（标识符）</p>
<ul>
<li><strong>在定义变量或者常量时候，不要用关键字</strong><br>
C++关键字如下：</li>
</ul>
<table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code>### 1.6 标识符命名规则</p>
<p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p>
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<blockquote>
<p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p>
</blockquote>
<h2 id="2-数据类型">2 数据类型</h2>
<p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p>
<h3 id="21-整型">2.1 整型</h3>
<p><strong>作用</strong>：整型变量表示的是<mark>整数类型</mark>的数据</p>
<p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>short(短整型)</td>
<td>2字节</td>
<td>(-2^15 ~ 2^15-1)</td>
</tr>
<tr>
<td>int(整型)</td>
<td>4字节</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long(长整形)</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long long(长长整形)</td>
<td>8字节</td>
<td>(-2^63 ~ 2^63-1)</td>
</tr>
</tbody>
</table>
<h3 id="22-sizeof关键字">2.2 sizeof关键字</h3>
<p>**作用：**利用sizeof关键字可以<mark>统计数据类型所占内存大小</mark></p>
<p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	cout &lt;&lt; &quot;short 类型所占内存空间为： &quot; &lt;&lt; sizeof(short) &lt;&lt; endl;

	cout &lt;&lt; &quot;int 类型所占内存空间为： &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;

	cout &lt;&lt; &quot;long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long) &lt;&lt; endl;

	cout &lt;&lt; &quot;long long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
```&gt; **整型结论**：==short &lt; int &lt;= long &lt;= long long==
### 2.3 实型（浮点型）

**作用**：用于==表示小数==

浮点型变量分为两种：

1. 单精度float 
2. 双精度double

两者的**区别**在于表示的有效数字范围不同。

| **数据类型** | **占用空间** | **有效数字范围** |
| ------------ | ------------ | ---------------- |
| float        | 4字节        | 7位有效数字      |
| double       | 8字节        | 15～16位有效数字 |

**示例：**

```C++
int main() {

	float f1 = 3.14f;
	double d1 = 3.14;

	cout &lt;&lt; f1 &lt;&lt; endl;
	cout &lt;&lt; d1&lt;&lt; endl;

	cout &lt;&lt; &quot;float  sizeof = &quot; &lt;&lt; sizeof(f1) &lt;&lt; endl;
	cout &lt;&lt; &quot;double sizeof = &quot; &lt;&lt; sizeof(d1) &lt;&lt; endl;

	//科学计数法
	float f2 = 3e2; // 3 * 10 ^ 2 
	cout &lt;&lt; &quot;f2 = &quot; &lt;&lt; f2 &lt;&lt; endl;

	float f3 = 3e-2;  // 3 * 0.1 ^ 2
	cout &lt;&lt; &quot;f3 = &quot; &lt;&lt; f3 &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="24-字符型">2.4 字符型</h3>
<p>**作用：**字符型变量用于显示单个字符</p>
<p><strong>语法：</strong><code>char ch = 'a';</code></p>
<blockquote>
<p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p>
</blockquote>
<blockquote>
<p>注意2：单引号内只能有一个字符，不可以是字符串</p>
</blockquote>
<ul>
<li>C和C++中字符型变量只占用<mark>1个字节</mark>。</li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元<br>
示例：</li>
</ul>
<pre><code class="language-C++">int main() {
	
	char ch = 'a';
	cout &lt;&lt; ch &lt;&lt; endl;
	cout &lt;&lt; sizeof(char) &lt;&lt; endl;

	//ch = &quot;abcde&quot;; //错误，不可以用双引号
	//ch = 'abcde'; //错误，单引号内只能引用一个字符

	cout &lt;&lt; (int)ch &lt;&lt; endl;  //查看字符a对应的ASCII码
	ch = 97; //可以直接用ASCII给字符型变量赋值
	cout &lt;&lt; ch &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>ASCII码表格：</p>
<table>
<thead>
<tr>
<th><strong>ASCII</strong>值</th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>&quot;</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>/</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>/</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>=</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>`</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody>
</table>
<p>ASCII 码大致由以下<strong>两部分组</strong>成：</p>
<ul>
<li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul>
<h3 id="25-转义字符">2.5 转义字符</h3>
<p>**作用：**用于表示一些<mark>不能显示出来的ASCII字符</mark></p>
<p>现阶段我们常用的转义字符有：<code> \n  \\  \t</code></p>
<table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td><strong>\\</strong></td>
<td><strong>代表一个反斜线字符&quot;&quot;</strong></td>
<td><strong>092</strong></td>
</tr>
<tr>
<td>'</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围0<sub>9，a</sub>f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<pre><code class="language-C++">int main() {
	
	
	cout &lt;&lt; &quot;\\&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;\tHello&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;\n&quot; &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="26-字符串型">2.6 字符串型</h3>
<p><strong>作用</strong>：用于表示一串字符</p>
<p><strong>两种风格</strong></p>
<ol>
<li>
<p><strong>C风格字符串</strong>： <code>char 变量名[] = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<pre><code class="language-C++">int main() {

	char str1[] = &quot;hello world&quot;;
	cout &lt;&lt; str1 &lt;&lt; endl;
    
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
</li>
</ol>
<blockquote>
<p>注意：C风格的字符串要用双引号括起来</p>
</blockquote>
<ol>
<li>
<p><strong>C++风格字符串</strong>：  <code>string  变量名 = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<pre><code class="language-C++">int main() {

	string str = &quot;hello world&quot;;
	cout &lt;&lt; str &lt;&lt; endl;
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
</li>
</ol>
<blockquote>
<p>注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;==### 2.7 布尔类型 bool</p>
</blockquote>
<p><strong>作用：</strong> 布尔数据类型代表真或假的值</p>
<p>bool类型只有两个值：</p>
<ul>
<li>true  --- 真（本质是1）</li>
<li>false --- 假（本质是0）</li>
</ul>
<p><strong>bool类型占<mark>1个字节</mark>大小</strong></p>
<p>示例：</p>
<pre><code class="language-C++">int main() {

	bool flag = true;
	cout &lt;&lt; flag &lt;&lt; endl; // 1

	flag = false;
	cout &lt;&lt; flag &lt;&lt; endl; // 0

	cout &lt;&lt; &quot;size of bool = &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; //1
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="28-数据的输入">2.8 数据的输入</h3>
<p><strong>作用：用于从键盘获取数据</strong></p>
<p><strong>关键字：</strong> cin</p>
<p><strong>语法：</strong> <code>cin &gt;&gt; 变量 </code></p>
<p>示例：</p>
<pre><code class="language-C++">int main(){

	//整型输入
	int a = 0;
	cout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl;
	cin &gt;&gt; a;
	cout &lt;&lt; a &lt;&lt; endl;

	//浮点型输入
	double d = 0;
	cout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl;
	cin &gt;&gt; d;
	cout &lt;&lt; d &lt;&lt; endl;

	//字符型输入
	char ch = 0;
	cout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl;
	cin &gt;&gt; ch;
	cout &lt;&lt; ch &lt;&lt; endl;

	//字符串型输入
	string str;
	cout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl;
	cin &gt;&gt; str;
	cout &lt;&lt; str &lt;&lt; endl;

	//布尔类型输入
	bool flag = true;
	cout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl;
	cin &gt;&gt; flag;
	cout &lt;&lt; flag &lt;&lt; endl;
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
}
</code></pre>
<h2 id="3-运算符">3 运算符</h2>
<p><strong>作用：</strong> 用于执行代码的运算</p>
<p>本章我们主要讲解以下几类运算符：</p>
<table>
<thead>
<tr>
<th><strong>运算符类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>算术运算符</td>
<td>用于处理四则运算</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>用于将表达式的值赋给变量</td>
</tr>
<tr>
<td>比较运算符</td>
<td>用于表达式的比较，并返回一个真值或假值</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>用于根据表达式的值返回真值或假值</td>
</tr>
</tbody>
</table>
<h3 id="31-算术运算符">3.1 算术运算符</h3>
<p><strong>作用</strong>：用于处理四则运算</p>
<p>算术运算符包括以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>10 / 5</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr>
<td>++</td>
<td>前置递增</td>
<td>a=2; b=++a;</td>
<td>a=3; b=3;</td>
</tr>
<tr>
<td>++</td>
<td>后置递增</td>
<td>a=2; b=a++;</td>
<td>a=3; b=2;</td>
</tr>
<tr>
<td>--</td>
<td>前置递减</td>
<td>a=2; b=--a;</td>
<td>a=1; b=1;</td>
</tr>
<tr>
<td>--</td>
<td>后置递减</td>
<td>a=2; b=a--;</td>
<td>a=1; b=2;</td>
</tr>
</tbody>
</table>
<p><strong>示例1：</strong></p>
<pre><code class="language-C++">//加减乘除
int main() {

	int a1 = 10;
	int b1 = 3;

	cout &lt;&lt; a1 + b1 &lt;&lt; endl;
	cout &lt;&lt; a1 - b1 &lt;&lt; endl;
	cout &lt;&lt; a1 * b1 &lt;&lt; endl;
	cout &lt;&lt; a1 / b1 &lt;&lt; endl;  //两个整数相除结果依然是整数

	int a2 = 10;
	int b2 = 20;
	cout &lt;&lt; a2 / b2 &lt;&lt; endl; 

	int a3 = 10;
	int b3 = 0;
	//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0	//两个小数可以相除
	double d1 = 0.5;
	double d2 = 0.25;
	cout &lt;&lt; d1 / d2 &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：在除法运算中，除数不能为0<strong>示例2：</strong></p>
</blockquote>
<pre><code class="language-C++">//取模
int main() {

	int a1 = 10;
	int b1 = 3;

	cout &lt;&lt; 10 % 3 &lt;&lt; endl;

	int a2 = 10;
	int b2 = 20;

	cout &lt;&lt; a2 % b2 &lt;&lt; endl;

	int a3 = 10;
	int b3 = 0;

	//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0

	//两个小数不可以取模
	double d1 = 3.14;
	double d2 = 1.1;

	//cout &lt;&lt; d1 % d2 &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<blockquote>
<p>总结：只有整型变量可以进行取模运算<br>
<strong>示例3：</strong></p>
</blockquote>
<pre><code class="language-C++">//递增
int main() {

	//后置递增
	int a = 10;
	a++; //等价于a = a + 1
	cout &lt;&lt; a &lt;&lt; endl; // 11

	//前置递增
	int b = 10;
	++b;
	cout &lt;&lt; b &lt;&lt; endl; // 11

	//区别
	//前置递增先对变量进行++，再计算表达式
	int a2 = 10;
	int b2 = ++a2 * 10;
	cout &lt;&lt; b2 &lt;&lt; endl;

	//后置递增先计算表达式，后对变量进行++
	int a3 = 10;
	int b3 = a3++ * 10;
	cout &lt;&lt; b3 &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<blockquote>
<p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p>
</blockquote>
<h3 id="32-赋值运算符">3.2 赋值运算符</h3>
<p>**作用：**用于将表达式的值赋给变量</p>
<p>赋值运算符包括以下几个符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值</td>
<td>a=2; b=3;</td>
<td>a=2; b=3;</td>
</tr>
<tr>
<td>+=</td>
<td>加等于</td>
<td>a=0; a+=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>-=</td>
<td>减等于</td>
<td>a=5; a-=3;</td>
<td>a=2;</td>
</tr>
<tr>
<td>*=</td>
<td>乘等于</td>
<td>a=2; a*=2;</td>
<td>a=4;</td>
</tr>
<tr>
<td>/=</td>
<td>除等于</td>
<td>a=4; a/=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>%=</td>
<td>模等于</td>
<td>a=3; a%2;</td>
<td>a=1;</td>
</tr>
<tr>
<td><strong>示例：</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-C++">int main() {

	//赋值运算符

	// =
	int a = 10;
	a = 100;
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	// +=
	a = 10;
	a += 2; // a = a + 2;
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	// -=
	a = 10;
	a -= 2; // a = a - 2
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	// *=
	a = 10;
	a *= 2; // a = a * 2
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	// /=
	a = 10;
	a /= 2;  // a = a / 2;
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	// %=
	a = 10;
	a %= 2;  // a = a % 2;
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="33-比较运算符">3.3 比较运算符</h3>
<p><strong>作用：</strong> 用于表达式的比较，并返回一个真值或假值</p>
<p>比较运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>相等于</td>
<td>4 == 3</td>
<td>0</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>4 != 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>4 &lt;= 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>4 &gt;= 1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<pre><code class="language-C++">int main() {

	int a = 10;
	int b = 20;

	cout &lt;&lt; (a == b) &lt;&lt; endl; // 0 

	cout &lt;&lt; (a != b) &lt;&lt; endl; // 1

	cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0

	cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1

	cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0

	cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：C和C++ 语言的比较运算中， <mark>“真”用数字“1”来表示， “假”用数字“0”来表示。</mark></p>
</blockquote>
<h3 id="34-逻辑运算符">3.4 逻辑运算符</h3>
<p>**作用：**用于根据表达式的值返回真值或假值</p>
<p>逻辑运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真；  如果a为真，则!a为假。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>a || b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
</tbody>
</table>
<p>**示例1：**逻辑非</p>
<pre><code class="language-C++">//逻辑运算符  --- 非
int main() {

	int a = 10;

	cout &lt;&lt; !a &lt;&lt; endl; // 0

	cout &lt;&lt; !!a &lt;&lt; endl; // 1

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结： 真变假，假变真<strong>示例2：</strong> 逻辑与</p>
</blockquote>
<pre><code class="language-C++">//逻辑运算符  --- 与
int main() {

	int a = 10;
	int b = 10;

	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 1

	a = 10;
	b = 0;

	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 

	a = 0;
	b = 0;

	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<blockquote>
<p>总结：逻辑<mark>与</mark>运算符总结： <mark>同真为真，其余为假</mark></p>
</blockquote>
<p><strong>示例3：</strong> 逻辑或</p>
<pre><code class="language-c++">//逻辑运算符  --- 或
int main() {

	int a = 10;
	int b = 10;

	cout &lt;&lt; (a || b) &lt;&lt; endl;// 1

	a = 10;
	b = 0;

	cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 

	a = 0;
	b = 0;

	cout &lt;&lt; (a || b) &lt;&lt; endl;// 0

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>逻辑<mark>或</mark>运算符总结： <mark>同假为假，其余为真</mark>## 4 程序流程结构</p>
</blockquote>
<p>C/C++支持最基本的三种程序运行结构：<mark>顺序结构、选择结构、循环结构</mark></p>
<ul>
<li>顺序结构：程序按顺序执行，不发生跳转</li>
<li>选择结构：依据条件是否满足，有选择的执行相应功能</li>
<li>循环结构：依据条件是否满足，循环多次执行某段代码</li>
</ul>
<h3 id="41-选择结构">4.1 选择结构</h3>
<h4 id="411-if语句">4.1.1 if语句</h4>
<p>**作用：**执行满足条件的语句</p>
<p>if语句的三种形式</p>
<ul>
<li>
<p>单行格式if语句</p>
</li>
<li>
<p>多行格式if语句</p>
</li>
<li>
<p>多条件的if语句</p>
</li>
</ul>
<ol>
<li>
<p>单行格式if语句：<code>if(条件){ 条件满足执行的语句 }</code></p>
<figure data-type="image" tabindex="4"><img src="assets/clip_image002.png" alt="" loading="lazy"></figure>
<p>示例：</p>
<pre><code class="language-C++">int main() {

	//选择结构-单行if语句
	//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印

	int score = 0;
	cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl;
	cin &gt;&gt; score;

	cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl;

	//if语句
	//注意事项，在if判断语句后面，不要加分号
	if (score &gt; 600)
	{
		cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：if条件表达式后不要加分号</p>
</blockquote>
</li>
<li>
<p>多行格式if语句：<code>if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };</code><br>
示例：</p>
</li>
</ol>
<pre><code class="language-C++">int main() {

	int score = 0;

	cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;

	cin &gt;&gt; score;

	if (score &gt; 600)
	{
		cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<ol start="3">
<li>多条件的if语句：<br>
<code>if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}</code></li>
</ol>
<figure data-type="image" tabindex="5"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173156.png" alt="" loading="lazy"></figure>
<p>示例：</p>
<pre><code class="language-C++">	int main() {

	int score = 0;

	cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;

	cin &gt;&gt; score;

	if (score &gt; 600)
	{
		cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;
	}
	else if (score &gt; 500)
	{
		cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;
	}
	else if (score &gt; 400)
	{
		cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断<br>
案例需求：</p>
<ul>
<li>提示用户输入一个高考考试分数，根据分数做如下判断</li>
<li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li>
<li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。<br>
<strong>示例：</strong></li>
</ul>
<pre><code class="language-c++">int main() {

	int score = 0;

	cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;

	cin &gt;&gt; score;

	if (score &gt; 600)
	{
		cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;
		if (score &gt; 700)
		{
			cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl;
		}
		else if (score &gt; 650)
		{
			cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl;
		}
		else
		{
			cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl;
		}
		
	}
	else if (score &gt; 500)
	{
		cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;
	}
	else if (score &gt; 400)
	{
		cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>练习案例：</strong> 三只小猪称体重</p>
<p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？<br>
<img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173222.jpeg" alt="" loading="lazy"></p>
<h4 id="412-三目运算符">4.1.2 三目运算符</h4>
<p><strong>作用：</strong> 通过三目运算符实现简单的判断</p>
<p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p>
<p><strong>解释：</strong></p>
<p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p>
<p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	int a = 10;
	int b = 20;
	int c = 0;

	c = a &gt; b ? a : b;
	cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

	//C++中三目运算符返回的是变量,可以继续赋值

	(a &gt; b ? a : b) = 100;

	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p>
</blockquote>
<h4 id="413-switch语句">4.1.3 switch语句</h4>
<p>**作用：**执行多条件分支语句</p>
<p><strong>语法：</strong></p>
<pre><code class="language-C++">switch(表达式)

{

	case 结果1：执行语句;break;

	case 结果2：执行语句;break;

	...

	default:执行语句;break;

}

</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	//请给电影评分 
	//10 ~ 9   经典   
	// 8 ~ 7   非常好
	// 6 ~ 5   一般
	// 5分以下 烂片

	int score = 0;
	cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl;
	cin &gt;&gt; score;

	switch (score)
	{
	case 10:
	case 9:
		cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl;
		break;
	case 8:
		cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl;
		break;
	case 7:
	case 6:
		cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl;
		break;
	default:
		cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl;
		break;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意1：switch语句中表达式类型只能是整型或者字符型</p>
</blockquote>
<blockquote>
<p>注意2：case里如果没有break，那么程序会一直向下执行</p>
</blockquote>
<blockquote>
<p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p>
</blockquote>
<h3 id="42-循环结构">4.2 循环结构</h3>
<h4 id="421-while循环语句">4.2.1 while循环语句</h4>
<p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> while(循环条件){ 循环语句 }</code></p>
<p><strong>解释：</strong><mark>只要循环条件的结果为真，就执行循环语句</mark></p>
<figure data-type="image" tabindex="6"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173258.png" alt="" loading="lazy"></figure>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	int num = 0;
	while (num &lt; 10)
	{
		cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;
		num++;
	}
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环<br>
<strong>while循环练习案例：</strong><mark>猜数字</mark></p>
</blockquote>
<p><strong>案例描述：</strong> 系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。<br>
<img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173338.jpeg" alt="" loading="lazy"></p>
<h4 id="422-dowhile循环语句">4.2.2 do...while循环语句</h4>
<p><strong>作用：</strong>  满足循环条件，执行循环语句</p>
<p><strong>语法：</strong> <code>do{ 循环语句 } while(循环条件);</code></p>
<p>**注意：**与while的区别在于<mark>do...while会先执行一次循环语句</mark>，再判断循环条件</p>
<figure data-type="image" tabindex="7"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173414.png" alt="" loading="lazy"></figure>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	int num = 0;

	do
	{
		cout &lt;&lt; num &lt;&lt; endl;
		num++;

	} while (num &lt; 10);
	
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件</p>
</blockquote>
<p><strong>练习案例：水仙花数</strong></p>
<p>**案例描述：**水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身</p>
<p>例如：1^3 + 5^3+ 3^3 = 153</p>
<p>请利用do...while语句，求出所有3位数中的水仙花数</p>
<h4 id="423-for循环语句">4.2.3 for循环语句</h4>
<p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> for(起始表达式;条件表达式;末尾循环体) { 循环语句; }</code><br>
<strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	for (int i = 0; i &lt; 10; i++)
	{
		cout &lt;&lt; i &lt;&lt; endl;
	}
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>详解：</strong></p>
<figure data-type="image" tabindex="8"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173438.png" alt="" loading="lazy"></figure>
<blockquote>
<p>注意：for循环中的表达式，要用分号进行分隔</p>
</blockquote>
<blockquote>
<p>总结：while , do...while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用<strong>练习案例：敲桌子</strong></p>
</blockquote>
<p>案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p>
<figure data-type="image" tabindex="9"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173453.gif" alt="" loading="lazy"></figure>
<h4 id="424-嵌套循环">4.2.4 嵌套循环</h4>
<p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题</p>
<p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p>
<p><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173519.png" alt="" loading="lazy"><br>
<strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	//外层循环执行1次，内层循环执行1轮
	for (int i = 0; i &lt; 10; i++)
	{
		for (int j = 0; j &lt; 10; j++)
		{
			cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>练习案例：</strong> 乘法口诀表</p>
<p>案例描述：利用嵌套循环，实现九九乘法表</p>
<figure data-type="image" tabindex="10"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173545.jpeg" alt="" loading="lazy"></figure>
<h3 id="43-跳转语句">4.3 跳转语句</h3>
<h4 id="431-break语句">4.3.1 break语句</h4>
<p><strong>作用:</strong> 用于跳出<mark>选择结构</mark>或者<mark>循环结构</mark></p>
<p>break使用的时机：</p>
<ul>
<li>出现在switch条件语句中，作用是终止case并跳出switch</li>
<li>出现在循环语句中，作用是跳出当前的循环语句</li>
<li>出现在嵌套循环中，跳出最近的内层循环语句<br>
<strong>示例1：</strong></li>
</ul>
<pre><code class="language-C++">int main() {
	//1、在switch 语句中使用break
	cout &lt;&lt; &quot;请选择您挑战副本的难度：&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;1、普通&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;2、中等&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;3、困难&quot; &lt;&lt; endl;

	int num = 0;

	cin &gt;&gt; num;

	switch (num)
	{
	case 1:
		cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl;
		break;
	case 2:
		cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl;
		break;
	case 3:
		cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl;
		break;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>示例2：</strong></p>
<pre><code class="language-C++">int main() {
	//2、在循环语句中用break
	for (int i = 0; i &lt; 10; i++)
	{
		if (i == 5)
		{
			break; //跳出循环语句
		}
		cout &lt;&lt; i &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>示例3：</strong></p>
<pre><code class="language-C++">int main() {
	//在嵌套循环语句中使用break，退出内层循环
	for (int i = 0; i &lt; 10; i++)
	{
		for (int j = 0; j &lt; 10; j++)
		{
			if (j == 5)
			{
				break;
			}
			cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
	}
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="432-continue语句">4.3.2 continue语句</h4>
<p>**作用：**在<mark>循环语句</mark>中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	for (int i = 0; i &lt; 100; i++)
	{
		if (i % 2 == 0)
		{
			continue;
		}
		cout &lt;&lt; i &lt;&lt; endl;
	}
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：continue并没有使整个循环终止，而break会跳出循环#### 4.3.3 goto语句</p>
</blockquote>
<p>**作用：**可以无条件跳转语句<br>
<strong>语法：</strong> <code>goto 标记;</code></p>
<p>**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置<br>
<strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;

	goto FLAG;

	cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;3&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;4&quot; &lt;&lt; endl;

	FLAG:

	cout &lt;&lt; &quot;5&quot; &lt;&lt; endl;
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p>
</blockquote>
<h2 id="5-数组">5 数组</h2>
<h3 id="51-概述">5.1 概述</h3>
<p>所谓数组，就是一个集合，里面存放了相同类型的数据元素<br>
<strong>特点1：</strong> 数组中的每个<mark>数据元素都是相同的数据类型</mark></p>
<p><strong>特点2：</strong> 数组是由<mark>连续的内存</mark>位置组成的</p>
<h3 id="52-一维数组">5.2 一维数组</h3>
<h4 id="521-一维数组定义方式">5.2.1 一维数组定义方式</h4>
<p>一维数组定义的三种方式：</p>
<ol>
<li><code>数据类型  数组名[ 数组长度 ];</code></li>
<li><code>数据类型  数组名[ 数组长度 ] = { 值1，值2 ...};</code></li>
<li><code>数据类型  数组名[ ] = { 值1，值2 ...};</code><br>
示例</li>
</ol>
<pre><code class="language-C++">int main() {

	//定义方式1
	//数据类型 数组名[元素个数];
	int score[10];

	//利用下标赋值
	score[0] = 100;
	score[1] = 99;
	score[2] = 85;

	//利用下标输出
	cout &lt;&lt; score[0] &lt;&lt; endl;
	cout &lt;&lt; score[1] &lt;&lt; endl;
	cout &lt;&lt; score[2] &lt;&lt; endl;	//第二种定义方式
	//数据类型 数组名[元素个数] =  {值1，值2 ，值3 ...};
	//如果{}内不足10个数据，剩余数据用0补全
	int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 };
	
	//逐个输出
	//cout &lt;&lt; score2[0] &lt;&lt; endl;
	//cout &lt;&lt; score2[1] &lt;&lt; endl;

	//一个一个输出太麻烦，因此可以利用循环进行输出
	for (int i = 0; i &lt; 10; i++)
	{
		cout &lt;&lt; score2[i] &lt;&lt; endl;
	}

	//定义方式3
	//数据类型 数组名[] =  {值1，值2 ，值3 ...};
	int score3[] = { 100,90,80,70,60,50,40,30,20,10 };

	for (int i = 0; i &lt; 10; i++)
	{
		cout &lt;&lt; score3[i] &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p>
</blockquote>
<blockquote>
<p>总结2：数组中下标是从0开始索引</p>
</blockquote>
<h4 id="522-一维数组数组名">5.2.2 一维数组数组名</h4>
<p>一维数组名称的<strong>用途</strong>：</p>
<ol>
<li>可以统计整个数组在内存中的长度</li>
<li>可以获取数组在内存中的首地址<strong>示例：</strong></li>
</ol>
<pre><code class="language-C++">int main() {

	//数组名用途
	//1、可以获取整个数组占用内存空间大小
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };

	cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;
	cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;
	cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;

	//2、可以通过数组名获取到数组首地址
	cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl;
	cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;
	cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;

	//arr = 100; 错误，数组名是常量，因此不可以赋值	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：数组名是常量，不可以赋值</p>
</blockquote>
<blockquote>
<p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小<strong>练习案例1</strong>：五只小猪称体重</p>
</blockquote>
<p><strong>案例描述：</strong></p>
<p>在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};</p>
<p>找出并打印最重的小猪体重。<br>
**练习案例2：**数组元素逆置</p>
<p>**案例描述：**请声明一个5个元素的数组，并且将元素逆置.</p>
<p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);#### 5.2.3 冒泡排序</p>
<p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li>
<li>重复以上的步骤，每次比较次数-1，直到不需要比较<strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</li>
</ol>
<pre><code class="language-C++">int main() {

	int arr[9] = { 4,2,8,0,5,7,1,3,9 };

	for (int i = 0; i &lt; 9 - 1; i++)
	{
		for (int j = 0; j &lt; 9 - 1 - i; j++)
		{
			if (arr[j] &gt; arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}

	for (int i = 0; i &lt; 9; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; endl;
	}
    
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="53-二维数组">5.3 二维数组</h3>
<p>二维数组就是在一维数组上，多加一个维度。</p>
<figure data-type="image" tabindex="11"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173611.png" alt="" loading="lazy"></figure>
<h4 id="531-二维数组定义方式">5.3.1 二维数组定义方式</h4>
<p>二维数组定义的四种方式：</p>
<ol>
<li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};</code></li>
<li><code> 数据类型  数组名[  ][ 列数 ] = { 数据1，数据2，数据3，数据4};</code></li>
</ol>
<blockquote>
<p>建议：以上4种定义方式，利用<mark>第二种更加直观，提高代码的可读性</mark></p>
</blockquote>
<p>示例：</p>
<pre><code class="language-C++">int main() {

	//方式1  
	//数组类型 数组名 [行数][列数]
	int arr[2][3];
	arr[0][0] = 1;
	arr[0][1] = 2;
	arr[0][2] = 3;
	arr[1][0] = 4;
	arr[1][1] = 5;
	arr[1][2] = 6;

	for (int i = 0; i &lt; 2; i++)
	{
		for (int j = 0; j &lt; 3; j++)
		{
			cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
	}

	//方式2 
	//数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } };
	int arr2[2][3] =
	{
		{1,2,3},
		{4,5,6}
	};

	//方式3
	//数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4  };
	int arr3[2][3] = { 1,2,3,4,5,6 }; 

	//方式4 
	//数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4  };
	int arr4[][3] = { 1,2,3,4,5,6 };
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p>
</blockquote>
<h4 id="532-二维数组数组名">5.3.2 二维数组数组名</h4>
<ul>
<li>查看二维数组所占内存空间</li>
<li>获取二维数组首地址<strong>示例：</strong></li>
</ul>
<pre><code class="language-C++">int main() {

	//二维数组数组名
	int arr[2][3] =
	{
		{1,2,3},
		{4,5,6}
	};

	cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;

	cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl;

	//地址
	cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl;

	cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结1：二维数组名就是这个数组的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p>
</blockquote>
<h4 id="533-二维数组应用案例"><strong>5.3.3 二维数组应用案例</strong></h4>
<p><strong>考试成绩统计：</strong></p>
<p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td>100</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>李四</td>
<td>90</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>王五</td>
<td>60</td>
<td>70</td>
<td>80</td>
</tr>
</tbody>
</table>
<pre><code class="language-C++">int main() {

	int scores[3][3] =
	{
		{100,100,100},
		{90,50,100},
		{60,70,80},
	};

	string names[3] = { &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; };

	for (int i = 0; i &lt; 3; i++)
	{
		int sum = 0;
		for (int j = 0; j &lt; 3; j++)
		{
			sum += scores[i][j];
		}
		cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h2 id="6-函数">6 函数</h2>
<h3 id="61-概述">6.1 概述</h3>
<p><strong>作用：</strong> 将一段经常使用的代码封装起来，减少重复代码</p>
<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>
<h3 id="62-函数的定义">6.2 函数的定义</h3>
<p>函数的定义一般主要有5个步骤：</p>
<p>1、返回值类型</p>
<p>2、函数名</p>
<p>3、参数表列</p>
<p>4、函数体语句</p>
<p>5、return 表达式</p>
<p><strong>语法：</strong></p>
<pre><code class="language-C++">返回值类型 函数名 （参数列表）
{

       函数体语句

       return 表达式

}
</code></pre>
<ul>
<li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名称</li>
<li>参数列表：使用该函数时，传入的数据</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据<strong>示例：</strong> 定义一个加法函数，实现两个数相加</li>
</ul>
<pre><code class="language-C++">//函数定义
int add(int num1, int num2)
{
	int sum = num1 + num2;
	return sum;
}
```### 6.3 函数的调用

**功能：** 使用定义好的函数

**语法：**` 函数名（参数）`

**示例：**

```C++
//函数定义
int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参
{
	int sum = num1 + num2;
	return sum;
}

int main() {

	int a = 10;
	int b = 10;
	//调用add函数
	int sum = add(a, b);//调用时的a，b称为实际参数，简称实参
	cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;

	a = 100;
	b = 100;

	sum = add(a, b);
	cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p>
</blockquote>
<h3 id="64-值传递">6.4 值传递</h3>
<ul>
<li>所谓值传递，就是函数调用时实参将数值传入给形参</li>
<li>值传递时，<mark>如果形参发生，并不会影响实参</mark><br>
<strong>示例：</strong></li>
</ul>
<pre><code class="language-C++">void swap(int num1, int num2)
{
	cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;
	cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;

	int temp = num1;
	num1 = num2;
	num2 = temp;

	cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;
	cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;

	//return ; 当函数声明时候，不需要返回值，可以不写return
}

int main() {

	int a = 10;
	int b = 20;

	swap(a, b);

	cout &lt;&lt; &quot;mian中的 a = &quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;mian中的 b = &quot; &lt;&lt; b &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结： 值传递时，形参是修饰不了实参的</p>
</blockquote>
<h3 id="65-函数的常见样式"><strong>6.5 函数的常见样式</strong></h3>
<p>常见的函数样式有4种</p>
<ol>
<li>无参无返</li>
<li>有参无返</li>
<li>无参有返</li>
<li>有参有返</li>
</ol>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//函数常见样式
//1、 无参无返
void test01()
{
	//void a = 10; //无类型不可以创建变量,原因无法分配内存
	cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl;
	//test01(); 函数调用
}

//2、 有参无返
void test02(int a)
{
	cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
}

//3、无参有返
int test03()
{
	cout &lt;&lt; &quot;this is test03 &quot; &lt;&lt; endl;
	return 10;
}

//4、有参有返
int test04(int a, int b)
{
	cout &lt;&lt; &quot;this is test04 &quot; &lt;&lt; endl;
	int sum = a + b;
	return sum;
}
```### 6.6 函数的声明

**作用：** 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

*  函数的**声明可以多次**，但是函数的**定义只能有一次**

**示例：**

```C++
//声明可以多次，定义只能一次
//声明
int max(int a, int b);
int max(int a, int b);
//定义
int max(int a, int b)
{
	return a &gt; b ? a : b;
}

int main() {

	int a = 100;
	int b = 200;

	cout &lt;&lt; max(a, b) &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
```### 6.7 函数的分文件编写

**作用：** 让代码结构更加清晰

函数分文件编写一般有4个步骤

1. 创建后缀名为.h的头文件  
2. 创建后缀名为.cpp的源文件
3. 在头文件中写函数的声明
4. 在源文件中写函数的定义

**示例：**

```C++
//swap.h文件
#include&lt;iostream&gt;
using namespace std;

//实现两个数字交换的函数声明
void swap(int a, int b);

</code></pre>
<pre><code class="language-C++">//swap.cpp文件
#include &quot;swap.h&quot;

void swap(int a, int b)
{
	int temp = a;
	a = b;
	b = temp;

	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
}
</code></pre>
<pre><code class="language-C++">//main函数文件
#include &quot;swap.h&quot;
int main() {

	int a = 100;
	int b = 200;
	swap(a, b);

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<h2 id="7-指针">7 指针</h2>
<h3 id="71-指针的基本概念">7.1 指针的基本概念</h3>
<p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>
<ul>
<li>内存编号是从0开始记录的，一般用十六进制数字表示</li>
<li>可以利用指针变量保存地址</li>
</ul>
<h3 id="72-指针变量的定义和使用">7.2 指针变量的定义和使用</h3>
<p>指针变量定义语法： <code>数据类型 * 变量名；</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	//1、指针的定义
	int a = 10; //定义整型变量a
	
	//指针定义语法： 数据类型 * 变量名 ;
	int * p;

	//指针变量赋值
	p = &amp;a; //指针指向变量a的地址
	cout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址
	cout &lt;&lt; p &lt;&lt; endl;  //打印指针变量p

	//2、指针的使用
	//通过*操作指针变量指向的内存
	cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>指针变量和普通变量的区别</p>
<ul>
<li>普通变量存放的是数据,指针变量存放的是地址</li>
<li>指针变量可以通过&quot; * &quot;操作符，操作指针变量指向的内存空间，这个过程称为解引用</li>
</ul>
<blockquote>
<p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p>
</blockquote>
<blockquote>
<p>总结2：利用指针可以记录地址</p>
</blockquote>
<blockquote>
<p>总结3：对指针变量解引用，可以操作指针指向的内存### 7.3 指针所占内存空间<br>
提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？<br>
<strong>示例：</strong></p>
</blockquote>
<pre><code class="language-C++">int main() {

	int a = 10;

	int * p;
	p = &amp;a; //指针指向数据a的地址

	cout &lt;&lt; *p &lt;&lt; endl; //* 解引用
	cout &lt;&lt; sizeof(p) &lt;&lt; endl;
	cout &lt;&lt; sizeof(char *) &lt;&lt; endl;
	cout &lt;&lt; sizeof(float *) &lt;&lt; endl;
	cout &lt;&lt; sizeof(double *) &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：所有指针类型在32位操作系统下是4个字节### 7.4 空指针和野指针</p>
</blockquote>
<p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p>
<p><strong>用途：</strong> 初始化指针变量</p>
<p><strong>注意：</strong> 空指针指向的内存是不可以访问的<br>
<strong>示例1：空指针</strong></p>
<pre><code class="language-C++">int main() {

	//指针变量p指向内存地址编号为0的空间
	int * p = NULL;

	//访问空指针报错 
	//内存编号0 ~255为系统占用内存，不允许用户访问
	cout &lt;&lt; *p &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>野指针</strong>：指针变量指向非法的内存空间</p>
<p><strong>示例2：野指针</strong></p>
<pre><code class="language-C++">int main() {

	//指针变量p指向内存地址编号为0x1100的空间
	int * p = (int *)0x1100;

	//访问野指针报错 
	cout &lt;&lt; *p &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
```&gt; 总结：空指针和野指针都不是我们申请的空间，因此不要访问。
### 7.5 const修饰指针

const修饰指针有三种情况

1. const修饰指针   --- 常量指针
2. const修饰常量   --- 指针常量
3. const即修饰指针，又修饰常量

**示例：**```c++
int main() {

	int a = 10;
	int b = 10;

	//const修饰的是指针，指针指向可以改，指针指向的值不可以更改
	const int * p1 = &amp;a; 
	p1 = &amp;b; //正确
	//*p1 = 100;  报错
	

	//const修饰的是常量，指针指向不可以改，指针指向的值可以更改
	int * const p2 = &amp;a;
	//p2 = &amp;b; //错误
	*p2 = 100; //正确

    //const既修饰指针又修饰常量
	const int * const p3 = &amp;a;
	//p3 = &amp;b; //错误
	//*p3 = 100; //错误

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>
</blockquote>
<h3 id="76-指针和数组">7.6 指针和数组</h3>
<p><strong>作用：</strong> 利用指针访问数组中元素</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };

	int * p = arr;  //指向数组的指针

	cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl;
	cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl;

	for (int i = 0; i &lt; 10; i++)
	{
		//利用指针遍历数组
		cout &lt;&lt; *p &lt;&lt; endl;
		p++;
	}

	system(&quot;pause&quot;);

	return 0;
}
```### 7.7 指针和函数

**作用：** 利用指针作函数参数，可以修改实参的值
**示例：**

```C++
//值传递
void swap1(int a ,int b)
{
	int temp = a;
	a = b; 
	b = temp;
}
//地址传递
void swap2(int * p1, int *p2)
{
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

int main() {

	int a = 10;
	int b = 20;
	swap1(a, b); // 值传递不会改变实参

	swap2(&amp;a, &amp;b); //地址传递会改变实参

	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>
</blockquote>
<h3 id="78-指针-数组-函数">7.8 指针、数组、函数</h3>
<p><strong>案例描述：</strong> 封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>
<p>例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };<br>
<strong>示例：</strong></p>
<pre><code class="language-c++">//冒泡排序函数
void bubbleSort(int * arr, int len)  //int * arr 也可以写为int arr[]
{
	for (int i = 0; i &lt; len - 1; i++)
	{
		for (int j = 0; j &lt; len - 1 - i; j++)
		{
			if (arr[j] &gt; arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}

//打印数组函数
void printArray(int arr[], int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; endl;
	}
}

int main() {

	int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };
	int len = sizeof(arr) / sizeof(int);

	bubbleSort(arr, len);

	printArray(arr, len);

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>
</blockquote>
<h2 id="8-结构体">8 结构体</h2>
<h3 id="81-结构体基本概念">8.1 结构体基本概念</h3>
<p>结构体属于用户<mark>自定义的数据类型</mark>，允许用户存储不同的数据类型</p>
<h3 id="82-结构体定义和使用">8.2 结构体定义和使用</h3>
<p><strong>语法：</strong><code>struct 结构体名 { 结构体成员列表 }；</code></p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构体名 变量名 = { 成员1值 ， 成员2值...}</li>
<li>定义结构体时顺便创建变量</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
}stu3; //结构体变量创建方式3 int main() {

	//结构体变量创建方式1
	struct student stu1; //struct 关键字可以省略

	stu1.name = &quot;张三&quot;;
	stu1.age = 18;
	stu1.score = 100;
	
	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl;

	//结构体变量创建方式2
	struct student stu2 = { &quot;李四&quot;,19,60 };

	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl;	stu3.name = &quot;王五&quot;;
	stu3.age = 18;
	stu3.score = 80;
	

	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结1：定义结构体时的关键字是struct，不可省略</p>
</blockquote>
<blockquote>
<p>总结2：创建结构体变量时，关键字struct可以省略</p>
</blockquote>
<blockquote>
<p>总结3：结构体变量利用操作符 ''.''  访问成员</p>
</blockquote>
<h3 id="83-结构体数组">8.3 结构体数组</h3>
<p><strong>作用：</strong> 将自定义的结构体放入到数组中方便维护</p>
<p><strong>语法：</strong><code> struct  结构体名 数组名[元素个数] = {  {} , {} , ... {} }</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
}

int main() {
	
	//结构体数组
	struct student arr[3]=
	{
		{&quot;张三&quot;,18,80 },
		{&quot;李四&quot;,19,60 },
		{&quot;王五&quot;,20,70 }
	};

	for (int i = 0; i &lt; 3; i++)
	{
		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
```### 8.4 结构体指针

**作用：** 通过指针访问结构体中的成员
* 利用操作符 `-&gt; `可以通过结构体指针访问结构体属性
**示例：**

```C++
//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};int main() {
	
	struct student stu = { &quot;张三&quot;,18,100, };
	
	struct student * p = &amp;stu;
	
	p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员

	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl;
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>
</blockquote>
<h3 id="85-结构体嵌套结构体">8.5 结构体嵌套结构体</h3>
<p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p>
<p><strong>例如：</strong> 每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//教师结构体定义
struct teacher
{
    //成员列表
	int id; //职工编号
	string name;  //教师姓名
	int age;   //教师年龄
	struct student stu; //子结构体 学生
};int main() {

	struct teacher t1;
	t1.id = 10000;
	t1.name = &quot;老王&quot;;
	t1.age = 40;

	t1.stu.name = &quot;张三&quot;;
	t1.stu.age = 18;
	t1.stu.score = 100;

	cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl;
	
	cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>总结：</strong> 在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>
<h3 id="86-结构体做函数参数">8.6 结构体做函数参数</h3>
<p><strong>作用：</strong> 将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>地址传递</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//值传递
void printStudent(student stu )
{
	stu.age = 28;
	cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;
}

//地址传递
void printStudent2(student *stu)
{
	stu-&gt;age = 28;
	cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu-&gt;age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;
}

int main() {

	student stu = { &quot;张三&quot;,18,100};
	//值传递
	printStudent(stu);
	cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;

	cout &lt;&lt; endl;

	//地址传递
	printStudent2(&amp;stu);
	cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>
</blockquote>
<h3 id="87-结构体中-const使用场景">8.7 结构体中 const使用场景</h3>
<p><strong>作用：</strong> 用const来防止误操作</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//const使用场景
void printStudent(const student *stu) //加const防止函数体中的误操作
{
	//stu-&gt;age = 100; //操作失败，因为加了const修饰
	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;

}

int main() {

	student stu = { &quot;张三&quot;,18,100 };

	printStudent(&amp;stu);

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="88-结构体案例">8.8 结构体案例</h3>
<h4 id="881-案例1">8.8.1 案例1</h4>
<p><strong>案例描述：</strong></p>
<p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p>
<p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p>
<p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p>
<p>最终打印出老师数据以及老师所带的学生数据。<br>
<strong>示例：</strong></p>
<pre><code class="language-C++">struct Student
{
	string name;
	int score;
};
struct Teacher
{
	string name;
	Student sArray[5];
};

void allocateSpace(Teacher tArray[] , int len)
{
	string tName = &quot;教师&quot;;
	string sName = &quot;学生&quot;;
	string nameSeed = &quot;ABCDE&quot;;
	for (int i = 0; i &lt; len; i++)
	{
		tArray[i].name = tName + nameSeed[i];
		
		for (int j = 0; j &lt; 5; j++)
		{
			tArray[i].sArray[j].name = sName + nameSeed[j];
			tArray[i].sArray[j].score = rand() % 61 + 40;
		}
	}
}

void printTeachers(Teacher tArray[], int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		cout &lt;&lt; tArray[i].name &lt;&lt; endl;
		for (int j = 0; j &lt; 5; j++)
		{
			cout &lt;&lt; &quot;\t姓名：&quot; &lt;&lt; tArray[i].sArray[j].name &lt;&lt; &quot; 分数：&quot; &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;
		}
	}
}

int main() {

	srand((unsigned int)time(NULL)); //随机数种子 头文件 #include &lt;ctime&gt;

	Teacher tArray[3]; //老师数组

	int len = sizeof(tArray) / sizeof(Teacher);

	allocateSpace(tArray, len); //创建数据

	printTeachers(tArray, len); //打印数据
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="882-案例2">8.8.2 案例2</h4>
<p><strong>案例描述：</strong></p>
<p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p>
<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p>
<p>五名英雄信息如下：</p>
<pre><code class="language-C++">		{&quot;刘备&quot;,23,&quot;男&quot;},
		{&quot;关羽&quot;,22,&quot;男&quot;},
		{&quot;张飞&quot;,20,&quot;男&quot;},
		{&quot;赵云&quot;,21,&quot;男&quot;},
		{&quot;貂蝉&quot;,19,&quot;女&quot;},
```**示例：**

```C++
//英雄结构体
struct hero
{
	string name;
	int age;
	string sex;
};
//冒泡排序
void bubbleSort(hero arr[] , int len)
{
	for (int i = 0; i &lt; len - 1; i++)
	{
		for (int j = 0; j &lt; len - 1 - i; j++)
		{
			if (arr[j].age &gt; arr[j + 1].age)
			{
				hero temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}
//打印数组
void printHeros(hero arr[], int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 性别： &quot; &lt;&lt; arr[i].sex &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].age &lt;&lt; endl;
	}
}

int main() {

	struct hero arr[5] =
	{
		{&quot;刘备&quot;,23,&quot;男&quot;},
		{&quot;关羽&quot;,22,&quot;男&quot;},
		{&quot;张飞&quot;,20,&quot;男&quot;},
		{&quot;赵云&quot;,21,&quot;男&quot;},
		{&quot;貂蝉&quot;,19,&quot;女&quot;},
	};

	int len = sizeof(arr) / sizeof(hero); //获取数组元素个数

	bubbleSort(arr, len); //排序

	printHeros(arr, len); //打印

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[24秋招：前端面试题学习与记录_001]]></title>
        <id>https://blog.gitnote.cn/post/24_js_interview_001/</id>
        <link href="https://blog.gitnote.cn/post/24_js_interview_001/">
        </link>
        <updated>2023-08-30T09:05:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考：https://www.bilibili.com/video/BV12E41137h7</p>
</blockquote>
<h1 id="1-h5c3-部分">1、H5+C3 部分</h1>
<h2 id="11-cookiessessionstorage-和-localstorage">1.1  cookies，sessionStorage 和 localStorage</h2>
<p>问题：请描述一下cookies,sessionStorage和localStorage的区别？<br>
分析：考察求职者对于<mark>本地存储的方式</mark>是否熟悉，因为初学者会把 cookies 和 sessionStorage 与 localStorage 搞混</p>
<p><strong>解答</strong>：</p>
<ul>
<li>cookies ：它是网站用来<mark>标记用户身份</mark>的一段数据，通常情况下是一段加密的字符串，并且默认情况之下只会在同源的HTTP请求中携带</li>
<li>sessionStorage：它是浏览器<mark>本地存储</mark>的一种方式，以键值对的形式进行存储，并且存储的数据会在<mark>浏览器关闭之后自动删除</mark></li>
<li>localStorage：它也是浏览器<mark>本地存储</mark>的一种方式，和sessionStorage一样，也是以键值对的形式存在的，不过它存储的是一个持久化的数据，一般<mark>不主动删除</mark>，数据会一直存在</li>
</ul>
<h2 id="12-displaynone-与-visibilityhidden">1.2 display:none; 与 visibility:hidden;</h2>
<p>问题：display:none;与visibility:hidden;的区别？<br>
分析：这是一个比较容易出现错误的CSS问题，没有大量实际开发经验的开发者，很难了解它们之间的区别</p>
<p><strong>解答</strong>：</p>
<ul>
<li>共同点：它们都可以让元素不可见</li>
<li>不同点：
<ul>
<li>display:none; 会让元素完全从渲染树中<mark>消失</mark>，不渲染的时候<mark>不占据任何空间</mark>。而 visibility:hidden; 不会让元素从渲染树消失，不渲染时元素<mark>继续占据空间</mark>，只是<mark>内容不可见</mark></li>
<li>display:none; 是<mark>非继承属性</mark>，子孙节点消失是因为元素从渲染树消失造成，通过修改子孙节点属性无法显示；而 visibility:hidden; 是<mark>继承属性</mark>，子孙节点消失由于继承了 hidden ，通过设置 visibility:visible; 可以让子孙节点显式</li>
</ul>
</li>
</ul>
<h2 id="13-为什么要初始化-css-样式">1.3  为什么要初始化 CSS 样式</h2>
<p>问题：为什么要初始化CSS样式？<br>
分析：这个问题主要是看你有没有实际开发的经验，因为对于没有实际开发经验的同学，是不知道在正式项目开发时要初始化 CSS 样式的，也就是清理掉一些元素默认所携带的样式，比如默认的 padding 和 margin</p>
<p><strong>解答</strong>：</p>
<ul>
<li>因为浏览器的<mark>兼容问题</mark>，不同浏览器对有些元素的默认样式是<mark>不同的</mark>，并且默认的样式会影响到项目最终的布局，如果没对 CSS 初始化，那么有可能会出现浏览器之间的页面<mark>显示差异</mark>。</li>
</ul>
<h2 id="14-postcss">1.4 PostCSS</h2>
<p>问题：什么是 postcss ，以及 postcss 有什么作用？<br>
分析：有很多已经工作了两年、三年的开发者依然无法解释清楚 postcss 是什么，以及它的作用</p>
<p><strong>解答</strong>：</p>
<ul>
<li>首先明确 postcss 是一个平台</li>
<li>基于这个平台，可以使用一些插件，来优化 css 的代码。比如说：autoprefixer 插件，他就需要基于 postcss 使用，作用是可以帮助我们为 CSS 增加上不同的浏览器前缀。</li>
</ul>
<h1 id="2-javascript-部分">2、JavaScript 部分</h1>
<h2 id="21-闭包">2.1 闭包</h2>
<p>问题：解释一下什么是闭包？以及闭包解决了什么问题？<br>
分析：闭包的问题一直是在前端方面非常被关注的问题，这个问题作为面试题经久不衰</p>
<p><strong>解答</strong>：</p>
<ul>
<li>什么是闭包？
<ul>
<li>闭包就是能够读取<mark>其他函数内部变量</mark>的=<mark>一个函数</mark>。通常情况下，我们会在一个函数中，去创建另外一个函数，然后通过新创建的这个函数来访问上层函数的局部变量，被访问到的局部变量会始终保存在内存之中。</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="http://img.upy.qiaoyukeji.cn/2023/08/28/20230828161838.png" alt="" loading="lazy"></figure>
<h2 id="22-原型与原型链">2.2 原型与原型链</h2>
<p>原型与原型链分别是什么？有什么特点？<br>
分析：原型和原型链的问题和闭包一样，也是面试被问到频率很高的一个问题。</p>
<p><strong>解答</strong>：</p>
<ul>
<li>每个函数都有一个 <mark>prototype</mark> 属性，这个属性会指向一个对象，就是通过调用该构造函数而创建的实例的原型，可以通过实例对象的 <code>__proto__</code> 来访问到这个原型对象。</li>
<li>实例在创建时，就会默认关联原型，并且会从原型继承属性。</li>
<li>而每一个原型对象又都会存在一个 <mark>constructor</mark> 属性，这个属性会指向关联的这个构造函数。</li>
<li>当访问一个实例对象的属性时，如果说这个实例对象中没有这个属性，那么 js 引擎就会去<mark>该实例对象的原型对象</mark>中去找</li>
<li>如果属性在原型对象中也找不到，那么就会去原型的原型中去找，一直到找到最上层的原型，也就是 Object 为止。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="http://img.upy.qiaoyukeji.cn/2023/08/28/20230828170334.png" alt="" loading="lazy"></figure>
<h2 id="23-this-对象">2.3 this 对象</h2>
<p>问题：谈谈对 This 对象的理解<br>
分析：在 JS 中一直存在着一个<mark>本不应该存在</mark>的问题，那就是关于 this 指向的问题。关于 this 的指向在其他的语言（比如java)中是非常明确的。但是因为 js 的历史问题，导致 this 的指向一直是一个重难点</p>
<p><strong>解答</strong>：</p>
<ul>
<li>this 总是指向<mark>函数的直接调用者</mark>（而非间接调用者）</li>
<li>如果有 <mark>new</mark> 关键字，this 指向 new 出来的那个对象</li>
<li>在事件中，this 指向触发这个事件的对象，特殊的是，IE 中的 attachEvent 中的 this 总是指向全局对象 Window</li>
</ul>
<h2 id="24-webpack">2.4 webpack</h2>
<p>问题：谈谈你对webpack的看法<br>
分析：对于中级工程师来说，webpack的内容一般不会问的很深，因为除非是高软或者是架构师，否则一般不会去配置webpack，但是这并不是你可能光明正大说不会的理由</p>
<p><strong>解答</strong>：</p>
<ul>
<li>webpack 是一个 <mark>JS 的模块打包工具</mark>，可以使用 webpack 管理项目中的 JS 模块依赖。</li>
<li>Webpack 提供了一些<mark>默认的配置</mark>，比如说 devServer，我们可以利用 devServer 来快速启动一个开发时的web服务器。</li>
<li>并且因为 webpack <mark>默认只能打包 js 文件</mark>，所以 webpack 额外提供了 loader 的概念，我们可以使用 loader 来预处理一些文件，并且可以打包除了 JS 之外的任何静态资源。</li>
<li>另外 webpack 还提供了<mark>插性</mark>的概念，我们可以使用很多的插件来在 webpack 上做一些<mark>辅助性的工作</mark>，比如 HtmlWebpackPlugin 这种用来创建 HTML 文件的插件。</li>
</ul>
<h2 id="25-promise">2.5 promise</h2>
<p>问题：谈谈你对 promise 的了解<br>
分析：promise是目前开发中经常会用到的一个知识点，所以它是必须要掌握的</p>
<p><strong>解答</strong>：</p>
<ul>
<li>首先 promise 是 ES6 提出的一个<mark>异步编程解决方案</mark>。相比于传统的容易陷入<mark>回调地狱</mark>的异步回调方案来说，promise 会让异步的操作变得更加的优雅。</li>
<li>ES6 规定 promise 是一个<mark>构造函数</mark>，所以我们需要通过 new 关键字来生成一个 promise 的实例对象。</li>
<li>Promise 的构造函数接受<mark>一个函数</mark>作为参数，函数中的代码在 new primise 的时候，<mark>会立刻执行</mark>，我们可以在这里去执行异步代码的操作。并且该函数默认存在两个参数分别是 <mark>resolve和reject</mark>，这两个参数也是函数，用来标记异步执行的状态。</li>
<li>比如 resolve，当 promise 的异步操作<mark>完成</mark>的时候，我们可以调用 resolve 函数，来标记当前的异步操作已经完成了。</li>
<li>而 reject，是在异步操作<mark>失败</mark>的时候进行调用，用来标记当前的异步操作失败了。</li>
<li>这些标记的状态我们可以通过 promise 实例对象的 <mark>.then</mark> 方法和 <mark>.catch</mark> 方法接收。其中，.then 方法是异步完成的回调，.catach 是异步失败的回调。</li>
</ul>
<h2 id="26-null-undefined">2.6 null、undefined</h2>
<p>问题：null和undefined的区别是什么？<br>
分析：这个问题多出现在笔试中，是考察工程师基础知识掌握程度的一个很好的题目</p>
<p><strong>解答</strong>：</p>
<ul>
<li>undefined ：表示不存在这个值，是一个<mark>变量的最原始状态</mark></li>
<li>null ：是一个<mark>具体的值</mark>，只不过这个值是<mark>一个空值</mark>而已</li>
</ul>
<h2 id="27-同步与异步">2.7 同步与异步</h2>
<p>问题：什么是同步？什么是异步？他们的区别是什么？<br>
分析：对于任何一门编程语言来说，同步和异步的概念永远都是一个重点问题</p>
<p><strong>解答</strong>：</p>
<ul>
<li>同步：线程被<mark>阻塞</mark>，等待任务返回结果。</li>
<li>异步：异步就是线程<mark>不会被阻塞</mark>，任务完成通知 JS 引擎。</li>
</ul>
<h2 id="28-event-loop">2.8 event loop</h2>
<p>问题：什么是 EventLoop ?<br>
分析：询问 EventLoop，主要就是为了询问JS的一个线程机制，因为你只有了解了 JS 的单线程机制，你才可以理解什么是 EventLoop</p>
<p><strong>解答</strong>：</p>
<ul>
<li>JavaScript 语言的一大特点就是<mark>单线程</mark>，也就是说，<mark>同一时间只能做一件事</mark>。</li>
<li>单线程就意味着，<mark>所有的任务都需要排队</mark>，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不等不一直等着。</li>
<li>于是，所有任务可以分成两种，一种是<mark>同步任务</mark>（synchronous），另一种是<mark>异步任务</mark>（asynchronous）。</li>
<li>同步任务指的是，<mark>在主线程上排队执行的任务</mark>，只有前一个任务执行完毕，才能行后一个任务。</li>
<li>异步任务指的是，<mark>不进入主线程、而进入&quot;任务队列”(task queue)的任务</mark>，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li>
<li>而当主线程中的任务完成之后，主线程从&quot;任务队列&quot;中读取事件，这个过程是循环不断的，这就是 <mark>Event Loop (事件循环)</mark>。</li>
</ul>
<h2 id="29-bind-call-apply">2.9 bind、call、apply</h2>
<p>问题：bind、call、apply的区别？<br>
分析：这三个方法在 react 的项目中会使用的非常的多，并且因为这三个方法会牵扯到 this 的指向问题，所以在面试中被问到的概率会非常大</p>
<p><strong>解答</strong>：</p>
<ul>
<li>call 和 apply 都是为了<mark>解决改变 this 的指向</mark>，作用都是相同的，只是传参的方式不同。</li>
<li>除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。</li>
<li>bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="http://img.upy.qiaoyukeji.cn/2023/08/30/20230830162818.png" alt="" loading="lazy"></figure>
<h2 id="210-typeof-与-instanceof">2.10 typeof 与 instanceof</h2>
<p>问题：typeof 与 instanceof 的区别？<br>
分析：typeof 与 instanceof 都是在项目中会经常使用到的方法，并且这两个方法的作用经常容易搞混，所以在面试中，这两个方法会经常被问到</p>
<p><strong>解答</strong>：</p>
<ul>
<li>typeof：会<mark>返回一个值的类型</mark>。对于基本数据类型，除了 null 都可以返回正确的类型。而对于 null 则会返回 object，这是 js 的一个 bug 。而对于引用数据类型来说，除了函数之外，其他的都会返回 object</li>
<li>instanceof：它是用来判断<mark>一个对象</mark>是否<mark>是另一个对象</mark>的实例，注意它<mark>只能用来判断对象</mark></li>
</ul>
<figure data-type="image" tabindex="4"><img src="http://img.upy.qiaoyukeji.cn/2023/08/30/20230830163354.png" alt="" loading="lazy"></figure>
<h1 id="3-vue-部分">3、Vue 部分</h1>
<h2 id="31-vue-生命周期">3.1 Vue 生命周期</h2>
<p>问题：请说一下对 Vue 生命周期的理解<br>
分析：如果要使用 Vue 来开发项目，那么 Vue 生命周期部分，是必须要掌握的一个内容</p>
<p><strong>解答</strong>：</p>
<ul>
<li>Vue 实例从<mark>创建到销毁</mark>的过程，就是生命周期。</li>
<li>总共分为 8 个阶段，分别为：<mark>创建前/后，载入前/后，更新前/后，销毁前/后</mark></li>
</ul>
<figure data-type="image" tabindex="5"><img src="http://img.upy.qiaoyukeji.cn/2023/08/30/20230830164101.png" alt="" loading="lazy"></figure>
<h2 id="32-双向绑定的原理">3.2 双向绑定的原理</h2>
<p>问题：请说一下 Vue 实现双向数据绑定的原理<br>
分析：如果你的简历中有关于 Vue 的内容，那么 Vue 实现双向数据绑定的原理是有很大概率会被问到的一个知识点</p>
<p><strong>解答</strong>：</p>
<ul>
<li>vue 实现数据双向绑定主要是：采用<mark>数据劫持</mark>结合<mark>发布者-订阅者</mark>模式的方式。</li>
<li>数据劫持：通过 Object.defineProperty() 来劫持特对象各个属性的 setter，getter。</li>
<li>发布者-订阅者模式：在<mark>数据变动</mark>时发布者发布消息给<mark>订阅者</mark>，触发相应监听回调。</li>
<li>总的来说：当把一个普通 <mark>Javascript 对象</mark>传给 Vue 实例来作为它的 <mark>data 选项</mark>时，Vue 将遍历它的属性，用 Object.defineProperty() 监听它们的 getter/setter 方法。这样，它们就可以让 Vue 追踪依赖，在对象的属性被==访问(get)和修改(set)==时通知变化。</li>
</ul>
<h2 id="33-参数传递">3.3 参数传递</h2>
<p>问题：请说一下 Vue 中如何实现参数的传递？<br>
分析：Vue 中各个组件之间的参数传递，是使用Vue进行项目开发时大慨率会用到的一个知识点</p>
<p><strong>解答</strong>：</p>
<ul>
<li>父组件给子组件传值：子组件通过 <mark>pops 属性</mark>接受数据。</li>
<li>子组件给父组件传值：子组件通过 <mark>$emit 方法</mark>传递参数。</li>
<li>兄弟组件传值：对于兄弟组件之间传值来说，兄弟组件之间其实没有任何的相互依赖关系，也就是说他们之间其实<mark>没有关系</mark>。而对于没有关系的两个组件，如果想要进行数据传递，那么就需要有一个<mark>第三方</mark>。通过这个第三方来为两个没有关系的组件建立关系。目前比较通用的方式，主要有两种：
<ul>
<li>一个是 <mark>eventBus 方案</mark>，建立一个<mark>事件中心</mark>，通过它传递事件来进行数据传递。</li>
<li>第二个就是通过 <mark>vuex</mark> 来进行数据共享。</li>
</ul>
</li>
</ul>
<h2 id="34-路由-vuerouter">3.4 路由 VueRouter</h2>
<p>问题：请说一下 Vue 的路由实现：hash 模式和 history 模式<br>
分析：这个问题对于初、中级工程师来说被问到主要是一个加分项，因为路由模式在进行项目开发的时候所产生的影响比较有限，更大的影响是在项目部署之后的生产环境中</p>
<p><strong>解答</strong>：</p>
<ul>
<li>hash 模式：是vue-router的默认模式使用哈希，URL 中会出现 <code>#</code> 号字符， <mark><code>#</code> 以及 <code>#</code> 后面的字符称之为哈希(hash)</mark>。特点：hash 虽然在URL中，但<mark>不被包括在HTTP请求</mark>中。</li>
<li>history 模式：国内线上项目使用的比较多的还是 history 模式，这种模式下 URL 中不会存在 <code>#</code> 这种难看的字符。不过这种模式下，需要<mark>后台</mark>进行配合，因为 Vue 打包的项目通常是一个单页的应用，也就是<mark>任何的 URL 其实指向的都是一个HTML文件</mark>，所以我们需要在 <mark>apache 或者 nginx</mark> 中进行配置，当 URL 匹配不到资源时，指向同一个 html 页面的配置。</li>
</ul>
<h2 id="35-keepalive">3.5 KeepAlive</h2>
<p>问题：<code>&lt;keep-alive&gt;&lt;\keep-alive&gt;</code> 的作用是什么？<br>
分析：keepAlive 是构建公司级项目时经常会使用到的一个知识点</p>
<p><strong>解答</strong>：</p>
<ul>
<li>KeepAlive 的作用：<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code> 包裹动态组件时，会<mark>缓存不活动的组件实例</mark>，住要用于<mark>保留组件状态</mark>或<mark>避免重新渲染</mark>。</li>
</ul>
<h1 id="4-总结">4、总结</h1>
<p>目的：让大家可以针对每一个技术问题，以一种正确的方式，表达出自己心中对这个问题的理解。</p>
<p><a href="https://interview.poetries.top/">其他前端面试题整理：https://interview.poetries.top/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ESP32cam系列教程003：ESP32cam实现远程 HTTP_OTA 自动升级]]></title>
        <id>https://blog.gitnote.cn/post/esp32cam_http_ota/</id>
        <link href="https://blog.gitnote.cn/post/esp32cam_http_ota/">
        </link>
        <updated>2023-07-29T11:30:10.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1%E4%BB%80%E4%B9%88%E6%98%AF-ota">1.什么是 OTA</a></li>
<li><a href="#2-esp32cam-http_ota-%E6%9C%AC%E5%9C%B0%E5%87%86%E5%A4%87">2. ESP32cam HTTP_OTA 本地准备</a>
<ul>
<li><a href="#21-http-ota-%E5%8D%87%E7%BA%A7%E5%8E%9F%E7%90%86">2.1 HTTP OTA 升级原理</a></li>
<li><a href="#22-%E5%BC%80%E5%8F%91%E6%9D%BF%E6%9C%AC%E5%9C%B0%E5%9F%BA%E5%87%86%E7%A8%8B%E5%BA%8F%E7%A8%8B%E5%BA%8F%E7%89%88%E6%9C%AC1_0_0">2.2 开发板本地基准程序（程序版本：1_0_0）</a></li>
<li><a href="#23-%E5%BC%80%E5%8F%91%E6%9D%BF%E5%8D%87%E7%BA%A7%E7%A8%8B%E5%BA%8F%E7%A8%8B%E5%BA%8F%E7%89%88%E6%9C%AC1_0_1">2.3 开发板升级程序（程序版本：1_0_1）</a></li>
<li><a href="#24-%E6%9C%AC%E5%9C%B0-http_ota-%E5%8D%87%E7%BA%A7%E6%B5%8B%E8%AF%95">2.4 本地 HTTP_OTA 升级测试</a>
<ul>
<li><a href="#241-%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA-http-%E6%9C%8D%E5%8A%A1">2.4.1 本地运行一个 HTTP 服务</a></li>
<li><a href="#242-%E6%9B%BF%E6%8D%A2%E8%BF%9C%E7%A8%8B%E9%93%BE%E6%8E%A5%E5%B9%B6%E5%B0%86%E8%A6%81%E5%8D%87%E7%BA%A7%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E6%88%90-bin-%E6%96%87%E4%BB%B6">2.4.2 替换远程链接并将要升级的程序打包成 <code>.bin</code> 文件</a></li>
<li><a href="#243-%E6%9B%BF%E6%8D%A2%E8%BF%9C%E7%A8%8B%E9%93%BE%E6%8E%A5%E5%B9%B6%E7%83%A7%E5%BD%95%E5%9F%BA%E5%87%86%E7%A8%8B%E5%BA%8F%E7%89%88%E6%9C%AC%E4%B8%BA1_0_0-%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95%E5%8D%87%E7%BA%A7%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F">2.4.3 替换远程链接并烧录基准程序（版本为：1_0_0 的程序）测试升级是否成功</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-http_ota-%E5%8D%87%E7%BA%A7%E5%B1%95%E6%9C%9B">3. HTTP_OTA 升级展望</a>
<ul>
<li><a href="#31-%E5%90%8E%E6%9C%9F%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E5%8F%AF%E9%80%9A%E8%BF%87-http_ota-%E5%AE%9E%E7%8E%B0">3.1 后期版本更新可通过 HTTP_OTA 实现</a></li>
<li><a href="#32-%E5%80%9F%E5%8A%A9%E7%BD%91%E7%BB%9C%E4%BA%91%E5%B9%B3%E5%8F%B0%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B-http_ota-%E5%8D%87%E7%BA%A7">3.2 借助网络云平台实现远程 HTTP_OTA 升级</a></li>
</ul>
</li>
</ul>
</p>
<blockquote>
<p>本教程是 ESP32cam 的系列教程之三，使用 Arduino IDE 对 ESP32cam 开发板进行开发。<br>
本教程代码同样使用与其他 ESP32 开发板。</p>
</blockquote>
<h1 id="1什么是-ota">1.什么是 OTA</h1>
<p>OTA 即空中下载技术（Over-the-Air Technology），其可以安全方便地升级设备的固件或软件。远程升级还可以大大降低成本，节省资源，它已成为物联网设备和产品制造商的关键技术之一。</p>
<p>ESP32 开发板支持 3 种 OTA 方式：</p>
<ol>
<li>Arduino IDE ：主要用于软件开发阶段，实现不接线固件烧录</li>
<li>Web_OTA：通过 Web 浏览器手动提供应用程序更新模块</li>
<li>HTTP_OTA：固件存放到 http 服务器端，设备自动判断是否需要联网下载固件升级</li>
</ol>
<p>本文主要介绍：HTTP_OTA 的原理与实现。</p>
<h1 id="2-esp32cam-http_ota-本地准备">2. ESP32cam HTTP_OTA 本地准备</h1>
<br>
<h2 id="21-http-ota-升级原理">2.1 HTTP OTA 升级原理</h2>
<ol>
<li>本地程序在开机连接 WIFI 后发送 http 请求获取远程服务器中的升级 json 文件。</li>
<li>通过对比 json 中的远程版本信息与本地的版本信息判断是否一致。</li>
<li>若远程版本信息与本地版本不一致，则本地需要更新程序。</li>
<li>通过 json 中的版本信息在远程服务器中拉取需要更新的程序的 <code>.bin</code> 文件。</li>
<li>依据下载下来的 <code>.bin</code> 自动完成版本的升级，然后自动重启开发板。</li>
<li>重复第一步获取远程 json 文件判断是否需要更新。</li>
</ol>
<h2 id="22-开发板本地基准程序程序版本1_0_0">2.2 开发板本地基准程序（程序版本：1_0_0）</h2>
<p>本地 1_0_0 版本程序主要内容如下：</p>
<ol>
<li>当前版本（非常重要，升级依据）</li>
<li>远程升级的 json 链接与远程固件的文件夹链接</li>
<li>获取并解析 json 的函数 httpGETRequest</li>
<li>依据 json 判断是否需要更新的函数 isOrNotNeedUpdate</li>
<li>以及其他基础信息组成</li>
</ol>
<pre><code class="language-C++">#include &lt;WiFi.h&gt;

#include &lt;HTTPClient.h&gt;
#include &lt;ESP32httpUpdate.h&gt;
#include &lt;Arduino_JSON.h&gt;

/**********根据实际修改**********/
const char* wifi_ssid = &quot;TP-LINK_1760&quot;;   // WIFI名称，区分大小写，不要写错
const char* wifi_password = &quot;987654321&quot;;  // WIFI密码

// 特别重要，升级依据！！！
// 设置当前代码版本 格式 1_0_0
char* version = &quot;1_0_0&quot;;

//远程固件链接，只支持http
const char* baseUpdateUrl = &quot;http://example.cn/esp32/&quot;;
const char* updateJson = &quot;http://example.cn/esp32/esp32_update.json&quot;;


// esp32_update.json
// {
//     &quot;version&quot;:&quot;1_0_1&quot;
// }

/**********根据实际修改**********/


int need_ota_update = 0;
int i = 0;
String jsonBuffer;


// 获取远程 json 升级文件
String httpGETRequest(const char* serverName) {
  WiFiClient client;
  HTTPClient http;
  String payload = &quot;&quot;;
  //连接目标网址
  http.begin(client, serverName);
  //发送HTTP站点请求
  int httpCode = http.GET();
  if (httpCode &gt; 0) {
    Serial.printf(&quot;[HTTP] GET... code: %d\n&quot;, httpCode);
    payload = http.getString();
  } else {
    Serial.printf(&quot;[HTTP] GET... failed, error: %s\n&quot;, http.errorToString(httpCode).c_str());
  }

  http.end();  //关闭连接
  //返回获得的数据用于Json处理
  return payload;
}

// 依据json文件中版本号与本地版本号，判断是否需要进行更新
void isOrNotNeedUpdate(){
  // 获取远程的升级 json ，判断内部版本与本地是否相同，判断是否需要升级
  jsonBuffer = httpGETRequest(updateJson);
  Serial.println(jsonBuffer);
  //将解析的Json对象值储存在Jsonu缓冲区中
  JSONVar myObject = JSON.parse(jsonBuffer);
  Serial.println(myObject);
  // Serial.println(myObject[&quot;version&quot;]);
  const char* ota_version = myObject[&quot;version&quot;];
  // Serial.println(ota_version);

  Serial.println(&quot;---&quot;);

  Serial.print(&quot;远程版本： &quot;);
  Serial.println(ota_version);
  Serial.print(&quot;本地版本： &quot;);
  Serial.println(version);
  // char * 与 const char * 比较
  // 判断远程版本与本地版本是否相同
  if (String(version) == String(ota_version)) {
    need_ota_update = 0;
    Serial.println(&quot;无需升级。。。&quot;);

  } else {
    need_ota_update = 1;
    Serial.println(&quot;需要升级。。。&quot;);
    Serial.print(&quot;OTA 升级地址为：&quot;);
    // 升级的完整链接， 例如：http://example.cn/esp32/esp32_1_0_1.bin
    String fullUpdateUrl = String(baseUpdateUrl) + &quot;esp32_&quot; + ota_version + &quot;.bin&quot;;
    Serial.println(String(fullUpdateUrl));


    // 获取远程 bin 文件进行升级
    t_httpUpdate_return ret = ESPhttpUpdate.update(fullUpdateUrl);
    Serial.println(ret);
    switch (ret) {
      case HTTP_UPDATE_FAILED:
        Serial.printf(&quot;HTTP_UPDATE_FAILED Error (%d): %s\n&quot;, ESPhttpUpdate.getLastError(), ESPhttpUpdate.getLastErrorString().c_str());
        break;
      case HTTP_UPDATE_NO_UPDATES:
        Serial.println(&quot;HTTP_UPDATE_NO_UPDATES&quot;);
        break;
      case HTTP_UPDATE_OK:
        Serial.println(&quot;HTTP_UPDATE_OK&quot;);
        break;
      default:
        Serial.println(ret);
    }
    // version=(char *)ota_version;
  }
  need_ota_update = 0;
}

void setup() {
  Serial.begin(115200);  //波特率115200
  Serial.print(&quot;Connection WIFI&quot;);
  WiFi.begin(wifi_ssid, wifi_password);    //连接wifi
  while (WiFi.status() != WL_CONNECTED) {  //等待连接wifi
    delay(500);
    Serial.print(&quot;.&quot;);
  }
  Serial.println(&quot;&quot;);
  // 调用判断是否需要升级函数
  isOrNotNeedUpdate();
}

void loop() {
// 主程序
  Serial.println(i);
  i++;
  delay(2000);
}

</code></pre>
<h2 id="23-开发板升级程序程序版本1_0_1">2.3 开发板升级程序（程序版本：1_0_1）</h2>
<p>本测试升级程序如下，仅仅在程序版本与主程序中做了调整，以便更清楚的看出是否OTA升级成功。</p>
<pre><code class="language-c++">#include &lt;WiFi.h&gt;

#include &lt;HTTPClient.h&gt;
#include &lt;ESP32httpUpdate.h&gt;
#include &lt;Arduino_JSON.h&gt;

/**********根据实际修改**********/
const char* wifi_ssid = &quot;TP-LINK_1760&quot;;   // WIFI名称，区分大小写，不要写错
const char* wifi_password = &quot;987654321&quot;;  // WIFI密码

// 特别重要，升级依据！！！
// 设置当前代码版本 格式 1_0_0
char* version = &quot;1_0_1&quot;;

//远程固件链接，只支持http
const char* baseUpdateUrl = &quot;http://example.cn/esp32/&quot;;
const char* updateJson = &quot;http://example.cn/esp32/esp32_update.json&quot;;


// esp32_update.json
// {
//     &quot;version&quot;:&quot;1_0_1&quot;
// }

/**********根据实际修改**********/


int need_ota_update = 0;
int i = 0;
String jsonBuffer;


// 获取远程 json 升级文件
String httpGETRequest(const char* serverName) {
  WiFiClient client;
  HTTPClient http;
  String payload = &quot;&quot;;
  //连接目标网址
  http.begin(client, serverName);
  //发送HTTP站点请求
  int httpCode = http.GET();
  if (httpCode &gt; 0) {
    Serial.printf(&quot;[HTTP] GET... code: %d\n&quot;, httpCode);
    payload = http.getString();
  } else {
    Serial.printf(&quot;[HTTP] GET... failed, error: %s\n&quot;, http.errorToString(httpCode).c_str());
  }

  http.end();  //关闭连接
  //返回获得的数据用于Json处理
  return payload;
}

// 依据json文件中版本号与本地版本号，判断是否需要进行更新
void isOrNotNeedUpdate(){
  // 获取远程的升级 json ，判断内部版本与本地是否相同，判断是否需要升级
  jsonBuffer = httpGETRequest(updateJson);
  Serial.println(jsonBuffer);
  //将解析的Json对象值储存在Jsonu缓冲区中
  JSONVar myObject = JSON.parse(jsonBuffer);
  Serial.println(myObject);
  // Serial.println(myObject[&quot;version&quot;]);
  const char* ota_version = myObject[&quot;version&quot;];
  // Serial.println(ota_version);

  Serial.println(&quot;---&quot;);

  Serial.print(&quot;远程版本： &quot;);
  Serial.println(ota_version);
  Serial.print(&quot;本地版本： &quot;);
  Serial.println(version);
  // char * 与 const char * 比较
  // 判断远程版本与本地版本是否相同
  if (String(version) == String(ota_version)) {
    need_ota_update = 0;
    Serial.println(&quot;无需升级。。。&quot;);

  } else {
    need_ota_update = 1;
    Serial.println(&quot;需要升级。。。&quot;);
    Serial.print(&quot;OTA 升级地址为：&quot;);
    // 升级的完整链接， 例如：http://example.cn/esp32/esp32_1_0_1.bin
    String fullUpdateUrl = String(baseUpdateUrl) + &quot;esp32_&quot; + ota_version + &quot;.bin&quot;;
    Serial.println(String(fullUpdateUrl));


    // 获取远程 bin 文件进行升级
    t_httpUpdate_return ret = ESPhttpUpdate.update(fullUpdateUrl);
    Serial.println(ret);
    switch (ret) {
      case HTTP_UPDATE_FAILED:
        Serial.printf(&quot;HTTP_UPDATE_FAILED Error (%d): %s\n&quot;, ESPhttpUpdate.getLastError(), ESPhttpUpdate.getLastErrorString().c_str());
        break;
      case HTTP_UPDATE_NO_UPDATES:
        Serial.println(&quot;HTTP_UPDATE_NO_UPDATES&quot;);
        break;
      case HTTP_UPDATE_OK:
        Serial.println(&quot;HTTP_UPDATE_OK&quot;);
        break;
      default:
        Serial.println(ret);
    }
    // version=(char *)ota_version;
  }
  need_ota_update = 0;
}

void setup() {
  Serial.begin(115200);  //波特率115200
  Serial.print(&quot;Connection WIFI&quot;);
  WiFi.begin(wifi_ssid, wifi_password);    //连接wifi
  while (WiFi.status() != WL_CONNECTED) {  //等待连接wifi
    delay(500);
    Serial.print(&quot;.&quot;);
  }
  Serial.println(&quot;&quot;);
  // 调用判断是否需要升级函数
  isOrNotNeedUpdate();
}

void loop() {
// 主程序
  Serial.println(i);
  Serial.println(&quot;OTA 升级成功&quot;);
  i++;
  delay(2000);
}
</code></pre>
<h2 id="24-本地-http_ota-升级测试">2.4 本地 HTTP_OTA 升级测试</h2>
<h3 id="241-本地运行一个-http-服务">2.4.1 本地运行一个 HTTP 服务</h3>
<p>这里使用 vscode 进行：</p>
<ol>
<li>用 vscode 打开一个空白文件夹</li>
<li>在文件夹中新建目录 <code>esp32</code>，文件 <code>index.html</code> ，目录下新建文件 <code>esp32_update.json</code></li>
<li><code>esp32_update.json</code> 中内容是 <code>{&quot;version&quot;:&quot;1_0_1&quot;}</code> ,表明当前远程的版本为 <code>1_0_1</code></li>
<li><code>index.html</code> 中为标准html结构文件</li>
<li>在 <code>index.html</code> 界面中右键&gt;Open with Live Server 打开</li>
</ol>
<figure data-type="image" tabindex="1"><img src="http://img.upyun.gitnote.cn/2023/07/29/20230729164822.png" alt="" loading="lazy"></figure>
<ol start="6">
<li>替换 <code>127.0.0.1</code> 为本地 <code>192.168.1.XXX</code> 并拼接 <code>/esp32/esp32_update.json</code> ,如下图所示</li>
</ol>
<figure data-type="image" tabindex="2"><img src="http://img.upyun.gitnote.cn/2023/07/29/20230729165341.png" alt="" loading="lazy"></figure>
<h3 id="242-替换远程链接并将要升级的程序打包成-bin-文件">2.4.2 替换远程链接并将要升级的程序打包成 <code>.bin</code> 文件</h3>
<ol>
<li>
<p>将 arduino IDE 中的程序的远程链接替换成本地 HTTP 服务器链接<br>
<img src="http://img.upyun.gitnote.cn/2023/07/31/20230731104826.png" alt="" loading="lazy"></p>
</li>
<li>
<p>工具中 开发板和 <code>Partition Scheme</code> 选择如下图：<br>
<img src="http://img.upyun.gitnote.cn/2023/07/29/20230729170115.png" alt="" loading="lazy"></p>
</li>
<li>
<p>项目中选择导出已编译的二进制文件，导出的二进制文件在同级目录下。<br>
<img src="http://img.upyun.gitnote.cn/2023/07/29/20230729170322.png" alt="" loading="lazy"></p>
</li>
<li>
<p>将导出的 <code>.bin</code> 文件重命名为 <code>esp32_1_0_x.bin</code> 样式，并复制到 2.4.1 节中的 esp32目录中，保证使用 <code>http://192.168.1.x/esp32/esp32_1_0_x.bin</code> 能够下载到该文件。<br>
<img src="http://img.upyun.gitnote.cn/2023/07/29/20230729170712.png" alt="" loading="lazy"></p>
</li>
</ol>
<h3 id="243-替换远程链接并烧录基准程序版本为1_0_0-的程序测试升级是否成功">2.4.3 替换远程链接并烧录基准程序（版本为：1_0_0 的程序）测试升级是否成功</h3>
<ol>
<li>将 arduino IDE 中的程序的远程链接替换成本地 HTTP 服务器链接<br>
<img src="http://img.upyun.gitnote.cn/2023/07/29/20230729171151.png" alt="" loading="lazy"></li>
<li>将 2.4.1 节中的 <code>esp32_update.json</code> 内部版本改为 1_0_0 ，保证一开始不升级。</li>
<li>将程序烧录进 esp32 开发板中。然后打开串口监视器</li>
<li>串口调试器中显示不需要升级<br>
<img src="http://img.upyun.gitnote.cn/2023/07/29/20230729171832.png" alt="" loading="lazy"></li>
<li>将 2.4.1 节中的 <code>esp32_update.json</code> 内部版本改为 1_0_1 ，然后重启开发板。<br>
<img src="http://img.upyun.gitnote.cn/2023/07/29/20230729172456.png" alt="" loading="lazy"></li>
<li>由上图可知，开发板自动判断是否需要升级并自动OTA升级成功。</li>
</ol>
<h1 id="3-http_ota-升级展望">3. HTTP_OTA 升级展望</h1>
<br>
<h2 id="31-后期版本更新可通过-http_ota-实现">3.1 后期版本更新可通过 HTTP_OTA 实现</h2>
<p>通过第二节可知，可以通过 HTTP_OTA 实现 esp32 开发板的隔空升级，这样可以在一台设备上测试好了程序后，上传 <code>.bin</code> 文件到第 2.4.1 节中的 HTTP 服务器文件夹中，实现其他开发板批量升级。</p>
<h2 id="32-借助网络云平台实现远程-http_ota-升级">3.2 借助网络云平台实现远程 HTTP_OTA 升级</h2>
<p>第 2.4 节是使用本地 HTTP 服务器进行升级的，我们也可以使用云服务厂商的对象云存储服务，将需要升级的 <code>.bin</code> 文件与 <code>esp32_update.json</code> 放到云服务厂商的对象云存储服务中，使用提供的公网域名替换程序代码中的远程固件连接，真正实现远程 OTA 快速自动升级服务。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>本地 HTTP_OTA 升级时，本机电脑需要和 esp32 开发板连在同一个网络下，否则 esp32 开发板无法访问固件地址。</li>
<li>使用云服务厂商的对象云存储服务，对象云存储需要设置禁止缓存，否则可能会获取之前缓存的版本而不是最新版，导致不必要的错误。</li>
</ol>
</blockquote>
]]></content>
    </entry>
</feed>