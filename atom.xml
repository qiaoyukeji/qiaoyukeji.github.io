<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.zhawenwen.cn/</id>
    <title>巧遇个人博客</title>
    <updated>2025-12-31T01:45:37.665Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.zhawenwen.cn/"/>
    <link rel="self" href="https://blog.zhawenwen.cn/atom.xml"/>
    <subtitle>他日若遂凌云志，敢笑黄巢不丈夫！&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;code-v9TubG0Cv1&quot; /&gt;&lt;meta name=&quot;msvalidate.01&quot; content=&quot;8B5B1D4FCE1CBCBCD2836739B32F2960&quot; /&gt;
&lt;script src=&quot;https://sdk.51.la/perf/js-sdk-perf.min.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  new LingQue.Monitor().init({id:&quot;KbiL8olwnEa4wAKH&quot;,sendSuspicious:true});
&lt;/script&gt;</subtitle>
    <logo>https://blog.zhawenwen.cn/images/avatar.png</logo>
    <icon>https://blog.zhawenwen.cn/favicon.ico</icon>
    <rights>All rights reserved 2025, 巧遇个人博客</rights>
    <entry>
        <title type="html"><![CDATA[2025年年度回顾（流水账）]]></title>
        <id>https://blog.zhawenwen.cn/post/2025/</id>
        <link href="https://blog.zhawenwen.cn/post/2025/">
        </link>
        <updated>2025-12-30T13:36:51.000Z</updated>
        <content type="html"><![CDATA[<p>2025年是本人正式工作的第一个整年，在这一年里我经历了很多挫折，也收获了很多见解，真正的从一名学生转变成了一名职场人。</p>
<p>下面是我2025年的一些碎碎念，通过流水账的形式回顾一下2025年的点点滴滴。</p>
<hr>
<ul>
<li>
<p>2025.01.02：晚上在办公室里加班。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767096069_20251230200108.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.01.07：就软件正版化工作推进不力被省版权局、省国资委联合约谈。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767096219_20251230200338.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.01.08：试用期6个月结束，正式转正，转正评级优秀。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767096336_20251230200536.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.01.10：发年终奖了，但是新员工年终奖就1000多块钱🤣。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767096447_20251230200727.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.01.25：公司开会，布置会场中。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767096674_20251230201114.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.01.28：回家过年了，吃年夜饭。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767096755_20251230201234.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.01.29：年初一，农家舞狮。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767096841_20251230201400.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.2.15：计划买车了，各个4S店看车中。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767097039_20251230201719.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.02.16：看房子中，计划搬出宿舍租房子住，宿舍周边啥也没有，实在是住不下去。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767097136_20251230201855.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.03.01：收到了好朋友给寄的零食，开心😊。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767097274_20251230202114.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.03.02：付款提车了，我也要有自己的小车车了。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767097398_20251230202318.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.03.07：有公司想挖我过去，被我拒绝了。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767097502_20251230202502.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.03.16：庐南川藏线踏青中，外出看看风景，放松一下。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767097620_20251230202659.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767097642_20251230202721.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.03.21：朋友约酒吧喝酒中。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767097735_20251230202855.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.03.25：公司集体植树中，第一次参加公司外出集体活动。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767097852_20251230203052.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.04.04：清明节巢湖周边转转，踏踏青。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767097972_20251230203251.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767098018_20251230203338.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.04.13：和朋友一起去万佛湖踏青。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767098190_20251230203630.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.04.20：重回官亭路小吃街，辣哭饼一如既往的辣。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767098297_20251230203817.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.04.22：代表公司参见安徽省委网信办的培训。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767098399_20251230203959.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.05.01：五一大别山去走一圈，放松放松心情。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767098507_20251230204146.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767098543_20251230204223.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767098586_20251230204306.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.05.30：我的生日，兄弟们给买的蛋糕。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767098704_20251230204504.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767098767_20251230204606.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.06.06：师妹毕业了请吃饭。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767098846_20251230204726.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767098879_20251230204759.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.06.16：探寻朋友的新家。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767099007_20251230205007.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.07.16：参加注册信息安全工程师考试。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767099089_20251230205128.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.07.19：和同事一起去鹞落坪自然保护区避暑。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767099167_20251230205246.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767099259_20251230205419.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.08.24：和大学好几年没见的同学吃饭、K歌。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767099405_20251230205644.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.08.31：皖南川藏线一日游。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767099528_20251230205848.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767099558_20251230205917.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.09.11：代表公司参加安徽省正版软件培训班。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767099674_20251230210113.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.09.16：又一发明专利Get。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767099767_20251230210246.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.10.1：国庆节，安吉三日游。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767099866_20251230210426.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767099893_20251230210453.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767099925_20251230210524.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767099965_20251230210605.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.10.18：和朋友们一起吃火锅、逛山姆。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767100065_20251230210745.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767100113_20251230210833.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.11.06：注册信息安全工程师证书Get。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767100210_20251230211010.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.11.16：独自一人，燕子河大峡谷一日游。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767100334_20251230211214.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767100369_20251230211249.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/12/30/1767100393_20251230211312.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.11.25：第一次晚上加班到约10点钟。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767100465_20251230211425.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.11.30：毕业好久了，研究生师兄弟一起聚餐。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767100560_20251230211559.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.12.14：买了一张显卡，5060，算是犒劳一下自己吧。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767100622_20251230211702.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.12.17：参加为期两天的脱产公文写作培训，算是可以歇一下了。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767100696_20251230211816.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.12.21：参加信创高级规划设计师考试中。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767100767_20251230211926.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.12.27：前往上海考试，并和朋友们一起聚一聚。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767100841_20251230212041.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.12.28：在朋友的陪同下参观了上海大学。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767101042_20251230212401.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2025.12.29：报名参加 RHCE 红帽认证考试。<br>
<img src="http://md.gitnote.cn/2025/12/30/1767101198_20251230212637.png" alt="" loading="lazy"></p>
</li>
</ul>
<blockquote>
<p>这就是我的2025流水账式的记录。<br>
他日若遂林云志，敢笑黄巢不丈夫！</p>
</blockquote>
<p>希望接下来的一年里继续努力，争取拿下软考高级等更多证书，同时工作顺兴，家庭美满，加油！</p>
<p>-- 写于 2025年12月30日夜。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2024年年度回顾（流水账）]]></title>
        <id>https://blog.zhawenwen.cn/post/2024/</id>
        <link href="https://blog.zhawenwen.cn/post/2024/">
        </link>
        <updated>2025-01-02T12:53:40.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="2024年年度回顾流水账">2024年年度回顾（流水账）</h1>
<p>时光飞逝，岁月荏苒，转眼之间 2024 年已经过去，2025 年已经到来。</p>
<p>回首已然走过的 2024 年，于我而言，意义非凡。这一年，我告别了熟悉的校园，褪去青涩学生的外衣，成功转型为一名职场新人。从一名学生到一名职场人的转变，对我来说，既是挑战，也是机遇。</p>
<p>本人将2024年分为两个部分，前半年忙着毕业相关事宜，后面年主要忙着自己的工作。本次通过流水账的形式，回顾一下 2024 年的点点滴滴。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="2024年年度回顾流水账">2024年年度回顾（流水账）</h1>
<p>时光飞逝，岁月荏苒，转眼之间 2024 年已经过去，2025 年已经到来。</p>
<p>回首已然走过的 2024 年，于我而言，意义非凡。这一年，我告别了熟悉的校园，褪去青涩学生的外衣，成功转型为一名职场新人。从一名学生到一名职场人的转变，对我来说，既是挑战，也是机遇。</p>
<p>本人将2024年分为两个部分，前半年忙着毕业相关事宜，后面年主要忙着自己的工作。本次通过流水账的形式，回顾一下 2024 年的点点滴滴。</p>
<!-- more -->
<h2 id="第一部分202401-202406">第一部分：2024.01-2024.06</h2>
<ul>
<li>
<p>2024.01.05：参加信息与人工智能学院成立大会。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819800_20250102200959.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.01.06：去南京参加地质调查局笔试。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819819_20250102201018.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.01.17：冬天的实验室楼下。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819784_20250102200943.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.01.18：农业银行卡被限额，一气之下把卡全注销了。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819743_20250102200902.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.01.19：去上海参加中国极地研究中心笔试，上海的物价也太高了。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819766_20250102200925.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.01.20：中国极地研究中心笔试，顺便再逛逛外滩。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819726_20250102200845.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/01/02/1735819703_20250102200822.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.01.29：实验室贴春联了。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819679_20250102200758.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.02.08：家乡的枫树。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819660_20250102200739.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.02.24：春季开学返校聚餐。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819646_20250102200725.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.02.25：我的桌面。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819619_20250102200658.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.03.13：硬件制板完成，测试中。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819601_20250102200640.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.03.17：实验室同门一起聚餐。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819585_20250102200624.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.03.18：数据采集设备测试中。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819564_20250102200604.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.03.20：又来上海了，上海的亲嘴烧居然有糊辣椒风味的。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819539_20250102200538.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.03.21：中国极地研究中心第二轮面试。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819516_20250102200514.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.03.28：校园里的桃花开了。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819494_20250102200452.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.03.29：又来上海了，葱油拌面味道还行。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819466_20250102200425.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.03.30：参加上海市事业单位联考。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819439_20250102200358.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.04.04：去万象城看小米SU7。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819416_20250102200335.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.04.12：南京，I am coming.<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819388_20250102200307.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.04.13：参加江苏中烟工业笔试，顺便去中山陵逛逛。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819358_20250102200237.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/01/02/1735819334_20250102200213.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/01/02/1735819309_20250102200148.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.04.19：又一次来上海了。</p>
</li>
<li>
<p>2024.04.20：再上海交通大学参加上海消防科学研究所笔试。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819286_20250102200125.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.04.25：优秀毕业生 GET。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819192_20250102195951.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.04.26：从南京寄给自己的明信片到了。尽人事，听天命！<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819142_20250102195901.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.04.27：农耕文化节，我们有自己的展台。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819215_20250102200014.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.05.02：太累了，宿舍里喝点啤酒放松一下。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819240_20250102200039.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.05.06；论文盲审意见出来了，一个B，一个C。还行吧，算是过了。</p>
</li>
<li>
<p>2024.05.11：和往届师兄一起夜爬大蜀山。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819263_20250102200102.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.05.13：参加工商银行安徽省合肥分行科技精英岗面试。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819118_20250102195838.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.05.18：参加安徽机场集团笔试。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819091_20250102195810.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.05.19：时隔四年，又来蚌埠了。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819065_20250102195744.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.05.20：参加淮河水利委员会面试，并重回蚌埠学院。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819043_20250102195722.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.05.24：中央网信办-国家计算机网络应急中心差额入职体检。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735819016_20250102195655.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.05.25：硕士毕业答辩结束，顺利通过了。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735818976_20250102195615.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.05.26：实验室同门聚餐吃饭。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735818945_20250102195544.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.05.28：国家能源集团安庆神皖能源面试。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735818906_20250102195505.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.05.31：又一次来上海了，参加上海审计局审计科学研究所资格审查。</p>
</li>
<li>
<p>2024.06.01：参加上海审计局审计科学研究所面试。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735818886_20250102195445.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.06.05：拍毕业照中。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735818866_20250102195425.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.06.05：参加安徽省建筑设计研究总院面试。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735818593_20250102194952.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.06.06：参加XX集团面试。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735818823_20250102195342.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.06.10：端午节朋友一起吃饭。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735818789_20250102195308.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.06.15：又来上海了。</p>
</li>
<li>
<p>2024.06.16：参加上海市大数据中心笔试。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735818773_20250102195252.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.06.18：清理毕业物品，回老家了。</p>
</li>
<li>
<p>2024.06.25：又来合肥了。</p>
</li>
<li>
<p>2024.06.27：参加入职体检。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735818665_20250102195103.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.06.28：来杭州了，坐的高铁低人一等坐。</p>
</li>
<li>
<p>2024.06.29：参加浙江交通职业技术学院笔试，然后和朋友游览西湖与雷峰塔。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735818694_20250102195133.png" alt="" loading="lazy"><br>
<img src="http://md.gitnote.cn/2025/01/02/1735818755_20250102195234.png" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="第二部分202407-202412">第二部分：2024.07-2024.12</h2>
<ul>
<li>
<p>2024.07.03： 放松放松心情，独自游长江安庆段大堤。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820035_20250102201354.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.07.04：给老家我的房间安装空调。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820261_20250102201740.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.07.08：入职公司了。</p>
</li>
<li>
<p>2024.07.09：安排办公室了，空空的桌子，啥也没配。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820293_20250102201812.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.07.16：换办公室了。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735821562_20250102203921.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.07.17：公司发劳保用品，我也蹭了一份。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735821539_20250102203858.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.07.23：上班窗外环境随拍。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820317_20250102201836.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.07.25：发放第一笔工资了。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820353_20250102201912.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.08.04：牛马生病了，急性肠胃炎，发烧40度。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820368_20250102201927.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.08.12：参加新员工培训了，为期一周时间。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820400_20250102201959.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.08.14：参观公司消防站。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820416_20250102202015.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.09.09：打工人电脑坏了，CPU频率锁0.4Ghz了。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820435_20250102202034.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.09.14：准备一个小型会议。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820452_20250102202051.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.09.18：合肥发生地震了，有震感。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735821441_20250102203720.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.09.23：公司发月饼了，但是是美诚月饼。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735821420_20250102203659.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.09.29：成功举办一场集团层面大型工作会议。</p>
</li>
<li>
<p>2024.10.02：和小伙伴一起游泰山。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820493_20250102202132.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.10.03：和小伙伴一起游徐州。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820509_20250102202148.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.10.12：公司领导安排前往一线学习工作3个月。</p>
</li>
<li>
<p>2024.10.15：一线工作学习中。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735821309_20250102203508.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.10.23：一线工作学习中。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820851_20250102202730.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.11.09：参加软考高级考试。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735821646_20250102204045.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.11.16：和室友一起去金寨县马鬃岭两日游。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820755_20250102202555.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.11.17：在霍山县迎驾集团打酒5斤。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820773_20250102202612.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.11.22：朋友同事请喝酒，12点的三里庵。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820793_20250102202632.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.11.23：独自游安徽省博物馆。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820810_20250102202649.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.12.15：和朋友一起吃饭。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735821098_20250102203138.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.12.18：被车撞了...<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820874_20250102202753.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.12.19：加班到凌晨4点。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820940_20250102202859.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.12.20：参加职工拔河比赛，队伍拿到第四名。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820958_20250102202917.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.12.22：CCF中国计算机学会赠送礼物。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820975_20250102202934.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.12.27：修理大屏。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735820998_20250102202957.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.12.27：前期帮忙，同事请喝酒。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735821221_20250102203340.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.12.30：检修引导系统。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735821130_20250102203209.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2024.12.31：和同事以及室友前往骆岗公园吃饭跨年。<br>
<img src="http://md.gitnote.cn/2025/01/02/1735821153_20250102203232.png" alt="" loading="lazy"></p>
</li>
</ul>
<blockquote>
<p>他时若遂凌云志，敢笑黄巢不丈夫!</p>
</blockquote>
<p>希望在接下来的一年里能继续努力，不断进步。</p>
<p>-- 写于2025年1月2日夜</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[博客网站运行 1100 天记录]]></title>
        <id>https://blog.zhawenwen.cn/post/run_1100_day/</id>
        <link href="https://blog.zhawenwen.cn/post/run_1100_day/">
        </link>
        <updated>2024-09-10T09:39:12.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://md.gitnote.cn/2024/09/10/1725962160_20240910175600.png" alt="" loading="lazy"></figure>
<hr>
<p>本博客自 2021年9月6日我即将进入研究生阶段学习前夕建立，建立的初衷是记录我的日常的学习与生活。</p>
<p>截止到2024年9月10日，博客网站已正常运行 1100 天，本博客贯穿了我的整个研究生生涯，记录了我的研究生学习期间的种种内容。</p>
<p>说真的，在最开始的时候，我真的从未曾想象过我的博客能够持续运行这么长的时间，我居然能够坚持整整 3 年不断地在博客中撰写各类内容。这其中的坚持与付出，现在回想起来都觉得有些不可思议。而且，我的博客在全平台的阅读量竟然也超过了 50 万，它意味着我的文字和经历在一定程度上得到了大家的关注与认可。</p>
<p>在研究生期间，因为大部分时间都沉浸在学习与研究之中，而我本身对新鲜事物又有着浓厚的兴趣。每当遇到那些新奇的领域或者独特的观点时，我总会不由自主地深入其中进行探索与研究。得益于研究生相对灵活的时间安排，我有足够的时间将这些研究成果整理归纳，最终形成一篇篇有价值的博客文章。</p>
<p>如今，我已经顺利地从研究生毕业，正式进入了企业开始上班。然而，企业的工作模式和校园有着很大的不同。在这里，一切都显得比较按部就班，很少有新奇的事物出现，也不需要我像在学校那样去深入地研究与探索。或许正是因为这样相对平淡的工作环境，导致我在近期都没有再撰写新的博客。</p>
<p>但我始终认为，撰写博客是一件极具意义的事情，尤其是撰写技术博客。它就像是把我们所学的知识，通过文字、图片等生动形象的方式记录下来，最终形成一篇完整的、具有可复现性的文档。在这个撰写的过程中，我们其实是在对相关的技术进行一次深入的复习与巩固。而当我们完成博客之后，它不仅可以为其他有需要的人提供宝贵的参考资料，同时也可以当作我们自己的一份独特的学习笔记，在未来的日子里随时翻阅。</p>
<p>我会继续保持积极的学习姿态，不断地学习新的知识与技能。并且，我会将这些学习成果认真地整理、汇总，然后将它们以博客内容的形式分享给每一位关注我的朋友。让我们一起在知识的海洋中遨游，共同进步！</p>
<p>最后，与大家共勉！</p>
<hr>
<p>写于 2024年9月10日，巧遇！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[24届毕业季——我的找工作之旅纪实]]></title>
        <id>https://blog.zhawenwen.cn/post/find_jobs_in_2024/</id>
        <link href="https://blog.zhawenwen.cn/post/find_jobs_in_2024/">
        </link>
        <updated>2024-07-05T10:41:20.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705220218.jpg" alt="" loading="lazy"></figure>
<hr>
<h2 id="1-个人介绍">1. 个人介绍</h2>
<p>本人是2021年9月入学、2024年6月毕业的一名计算机科学与技术专业硕士研究生，就读于省会城市的一所一本院校。</p>
<p>本人在2023年9月开始陆续投递简历，之后进入了投简历、笔试、面试的无限循环之中，本文是我找工作以来的一些记录。</p>
<h2 id="2-找工作流水记录">2. 找工作流水记录</h2>
<p>下面是本人从秋招到春招以来笔试和面试的公司（不完全），部分企业公司笔面试时间相同冲突时只选择其中一个参加。</p>
<p>部分保密单位笔、面试未列出。</p>
<ul>
<li>2023年8月13日，兆易创新，嵌入式软件工程师，笔试。</li>
<li>2023年8月17日，基恩士，技术工程师，一面。</li>
<li>2023年8月19日，京东集团，前端开发工程师，笔试。</li>
<li>2023年9月2日，小米，软件开发（JS），笔试。</li>
<li>2023年9月3日，微众银行，网络技术，笔试。</li>
<li>2023年9月14日，锐捷网络，嵌入式开发，笔试。</li>
<li>2023年9月16日，58同城，前端开发，笔试。</li>
<li>2023年9月21日，同程旅行，前端开发，笔试。</li>
<li>2023年10月10日，中信银行，信息科技，全球统一笔试（第一批）。</li>
<li>2023年10月14日，上海银行，信息科技，笔试。</li>
<li>2024年10月14日，小米，嵌入式开发，笔试。</li>
<li>2023年10月15日，咪咕文化，软件工程师，笔试。</li>
<li>2023年10月19号，民生银行上海分行，信息科技，笔试。</li>
<li>2023年10月31日，太平洋寿险，信息科技（前端方向），笔试。</li>
<li>2023年11月3日，阅文集团，前端开发，笔试。</li>
<li>2023年11月6日，民生银行上海分行，首轮线上面试。</li>
<li>2023年11月15日，保利集团校园招聘开放日，<strong>中奖</strong>，J20模型。</li>
<li>2023年12月3日，国家电网安徽，计算机类，笔试。</li>
<li>2023年12月9日，南方电网，信息通信类，统一线下笔试。</li>
<li>2023年12月9日，国家电网安徽，计算机类，<strong>面试</strong>。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705172518.png" alt="" loading="lazy"></li>
<li>2023年12月9日，教育部直属事业单位，笔试。</li>
<li>2023年12月25日，南方电网超高压，计算机类，<strong>面试</strong>。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705173848.jpg" alt="" loading="lazy"></li>
<li>2024年1月12日，南方电网广东，计算机类，<strong>面试</strong>。</li>
<li>2024年2月27日，中国建筑集团，信息类，统一笔试。</li>
<li>2024年3月6日，美团，前端开发，笔试。</li>
<li>2024年3月8日，携程，SRE工程师，笔试。</li>
<li>2024年3月12日，湖北中烟，信息类，笔试。</li>
<li>2024年3月14日，金山WPS，前端开发，笔试。</li>
<li>2024年3月15日，CVTE，嵌入式开发，笔试。</li>
<li>2024年3月23日，中国银行，信息科技类，线下统一笔试。</li>
<li>2024年3月20日，中国极地研究中心，电子工程师，<strong>二面</strong>。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705173127.png" alt="" loading="lazy"></li>
<li>2024年3月20日，小米，SER工程师，面试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705214748.png" alt="" loading="lazy"></li>
<li>2024年3月24日，TCL实业，笔试。</li>
<li>2024年3月30日，上海市事业单位联考，笔试。</li>
<li>2024年4月2日，安徽江淮汽车，软件系统岗，面试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705214947.png" alt="" loading="lazy"></li>
<li>2024年4月3日，小米，前端开发，面试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705214102.png" alt="" loading="lazy"></li>
<li>2024年4月10日，华夏银行，信息科技类，笔试。</li>
<li>2024年4月11日，国家计算机<code>********</code>中心，网络安全，笔试。</li>
<li>2024年4月15日，江苏交控，信息科技类，笔试。</li>
<li>2024年4月20日，浙江中烟，信息科技类，笔试。</li>
<li>2024年4月21日，中国工商银行，信息科技类，笔试。</li>
<li>2024年4月21日，应急管理部上海消防研究所，信息科技类，笔试。</li>
<li>2024年4月24日，三峡集团上海勘测设计研究院，信息科技类，面谈。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705214225.png" alt="" loading="lazy"></li>
<li>2024年4月25日，山东黄金集团，信息科技类，笔试。</li>
<li>2024年4月26日，民生银行上海分行，信息科技类，笔试。</li>
<li>2024年4月30日，水利部淮委通信总站，信息岗，笔试。</li>
<li>2024年5月7日，广东广电，信息岗，笔试。</li>
<li>2024年5月8日，中国工商银行软件开发中心（上海），信息科技类，<strong>面试</strong>。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705173255.png" alt="" loading="lazy"></li>
<li>2024年5月12日，国家能源集团，信息科技类，笔试。</li>
<li>2024年5月13日，中国工商银行合肥分行，科技精英，面试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705214446.png" alt="" loading="lazy"></li>
<li>2024年5月16日，民生银行上海分行，信息科技类，面试。</li>
<li>2024年5月14日，山东黄金集团山金期货，信息类，面试意向。</li>
<li>2024年5月14日，国家计算机<code>********</code>中心，网络安全，专业加试。</li>
<li>2024年5月14日，国家计算机<code>********</code>中心，网络安全，<strong>面试</strong>。</li>
<li>2024年5月18日，水利部淮委通信总站，信息岗，<strong>面试</strong>。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705173526.png" alt="" loading="lazy"></li>
<li>2024年5月28日，国家能源集团，计算机岗，<strong>面试</strong>。</li>
<li>2024年5月31日，上海审计科学研究所，计算机岗，<strong>面试</strong>。</li>
<li>2024年6月4日，广铁集团，软件开发岗，笔试。</li>
<li>2024年6月5日，安徽省交规院，信息岗，面试。</li>
<li>2024年6月14日，上海华讯网络，云计算工程师，笔试。</li>
<li>2024年6月14日，上海大数据中心，区块链工程师，笔试。</li>
<li>2024年6月18日，上海华讯网络，云计算工程师，面试<br>
<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705215142.png" alt="" loading="lazy"></li>
<li>2024年6月27日，上海电机学院，图书馆档案管理，笔试。</li>
<li>2024年6月30日，安徽工程大学，计算机学院教师，笔试。</li>
<li>2024年6月30日，浙江交院，数字化建设工程师，笔试。</li>
</ul>
<h2 id="3-总结">3. 总结</h2>
<p>在这段被冠以“史上最艰难就业”之名的毕业季里（或许 25 届会更艰难🤣），本人参加了众多公司的笔试，也历经了诸多公司的面试，然而一直处于陪跑状态。不少单位面试都是5进1、3进1，单位最终都选择了 985、211 院校的学生，本人学校于此方面不具优势。在这些面试经历中，我深切地感受到就业的沉重压力，此压力自上而下影响着每一个人。</p>
<p>毕业离校之际，本人手中空无一 Offer，目睹身边同学相继收获喜讯，那份焦虑与不安难以言表。最终，在毕业离校 20 多天后，一个省属国企向我伸出了橄榄枝，本人总算拿到了一个 Offer。有了 Offer 在手，内心压力顿时减轻不少，求职之路也暂告一段落。</p>
<p>回顾这段求职之旅，我心存感激；在求职之路上，众多师兄、同门、同学及朋友们无私的援助与鼓励，为我提供了莫大的支持，在此深表感激！但在这漫长的求职期间，本人也留下诸多遗憾，在此也就不展开了。</p>
<p>最后，衷心希望每个人都能收获理想的 Offer。</p>
<p>———— 写于2024年7月5日。</p>
<hr>
<p>附一个工作投递的记录（部分）：<img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F05%2F20240705183838.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是 websocket？—— websocket 使用与简介]]></title>
        <id>https://blog.zhawenwen.cn/post/what_is_websocket/</id>
        <link href="https://blog.zhawenwen.cn/post/what_is_websocket/">
        </link>
        <updated>2024-07-01T06:25:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-什么是-websocket">1. 什么是 websocket</h2>
<h3 id="11-什么是-websocket">1.1 什么是 websocket</h3>
<p>WebSocket是一种在单个 TCP 连接上进行<mark>全双工通信</mark>的协议。<br>
WebSocket 使得浏览器（客户端）和服务器之间的数据交换变得更加简单，允许<mark>服务端主动向客户端推送数据</mark>。</p>
<h3 id="12-websocket-与-http-的区别">1.2 websocket 与 http 的区别</h3>
<p>常规的 http 协议的网站与应用中，一般都是<mark>浏览器（客户端）主动</mark>发送请求到服务端获取数据，服务端<mark>无法</mark>主动推送数据到浏览器（客户端）。</p>
<p>服务端想要发送数据到浏览器（客户端），都是使用<mark>http轮询</mark>的方式实现，即浏览器（客户端）主动发送请求到服务端，服务端将数据返回浏览器（客户端）中。</p>
<p>http轮询模式有很大的缺点，需要浏览器（客户端）一直向服务端发送请求，以获取服务器中的最新数据到浏览器（客户端）中，当服务器数据又不一定一直变化，这就造成了很多的浏览器（客户端）发送的请求是无效请求，造成了资源的严重浪费。</p>
<p>Websocket 协议和 HTTP 协议主要有以下区别：</p>
<ul>
<li>连接方式
<ul>
<li>HTTP 协议：基于请求-响应模式，客户端发起请求，服务器响应。每次请求和响应都需要建立和关闭连接。</li>
<li>Websocket 协议：建立一次连接后，保持连接状态，允许双向通信，无需频繁建立和关闭连接。</li>
</ul>
</li>
<li>数据传输方向
<ul>
<li>HTTP 协议：通常是客户端向服务器发送请求，服务器返回响应，数据传输方向主要是客户端到服务器。</li>
<li>Websocket 协议：支持服务器主动向客户端推送数据，实现双向实时通信。</li>
</ul>
</li>
<li>开销
<ul>
<li>HTTP 协议：每次请求和响应都包含较多的头部信息，造成一定的开销。</li>
<li>Websocket 协议：建立连接后的通信开销相对较小。</li>
</ul>
</li>
<li>实时性
<ul>
<li>HTTP 协议：不太适合实时数据的传输，实时性相对较差。</li>
<li>Websocket 协议：能够实现实时的数据交互，实时性强。</li>
</ul>
</li>
<li>应用场景
<ul>
<li>HTTP 协议：适用于大多数一般性的网页浏览、数据获取等。</li>
<li>Websocket 协议：常用于在线聊天、实时游戏、金融行情实时推送等需要实时交互的场景。</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="2-为什么需要-websocket">2. 为什么需要 websocket</h2>
<p>为了解决使用 http 协议的浏览器（客户端）无法快速获取服务器端的数据，websocket 就被发明了出来。</p>
<p>websocket 协议有如下优点：</p>
<ol>
<li>双向通信：允许服务器主动向客户端推送数据，实现实时交互，无需客户端频繁请求。</li>
<li>低延迟：建立连接后，数据传输的延迟相对较低，能够快速响应。</li>
<li>更少的开销：相比传统的 HTTP 请求-响应模式，减少了连接建立和关闭的开销。</li>
<li>高效的数据传输：可以发送二进制数据，提高了数据传输的效率。</li>
<li>保持连接：连接一旦建立，除非出现异常，否则会一直保持，节省了重新建立连接的时间和资源。</li>
<li>实时性强：适用于需要实时更新数据的应用，如在线游戏、实时监控等。</li>
</ol>
<h2 id="3-websocket-如何使用">3. websocket 如何使用</h2>
<p>websocket 具体使用需要客户端与服务器端的双重支持。</p>
<h3 id="31-websocket-服务器端代码是使用">3.1 websocket 服务器端代码是使用</h3>
<pre><code class="language-javascript">// 引入 websocket 库；可以使用 npm install ws 安装库
const WebSocket = require('ws');
// 创建一个 WebSocket 服务器，并监听 8080 端口
const wss = new WebSocket.Server({ port: 8080 });

// 当有客户端连接成功时触发此事件
wss.on('connection', (ws) =&gt; {
  // 当接收到客户端发送的消息时触发此事件
  ws.on('message', (message) =&gt; {
    // 打印接收到的消息
    console.log(`Received: ${message}`);
    // 向客户端发送一条消息
    ws.send(`You sent: ${message} , 这是一个服务器返回的消息`);
  });
  // 向刚连接的客户端发送一条欢迎消息
  ws.send('Welcome to the WebSocket server!');
});
</code></pre>
<p>在目录里新建一个名为 <code>app.js</code> 的文件，将上述代码拷贝进去保存；之后在当前目录中打开终端，在终端中输入 <code>node app.js</code> 即可运行一个 websocket 测试版服务端。</p>
<h3 id="32-浏览器客户端代码与使用">3.2 浏览器（客户端）代码与使用</h3>
<h4 id="321-浏览器端使用一">3.2.1 浏览器端使用一</h4>
<p>浏览器端可以使用第三方网站来测试与 3.1 中的 websocket 服务器端是否通联成功。<br>
测试网址为：<a href="http://www.websocket-test.com">http://www.websocket-test.com/</a></p>
<p>打开网址后在左上角输入 websocket 服务端地址与端口号，示例为：ws://127.0.0.1:8080</p>
<p>之后即可发送内容测试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/07/01/20240701141359.png" alt="" loading="lazy"></p>
<h4 id="322-浏览器使用二">3.2.2 浏览器使用二</h4>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;WebSocket Test&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;h2&gt;WebSocket 测试&lt;/h2&gt;
  &lt;div id=&quot;message&quot;&gt;&lt;/div&gt;

  &lt;script&gt;
    // 创建 WebSocket 连接
    var socket = new WebSocket(&quot;ws://localhost:8080&quot;);

    // 连接打开时触发
    socket.onopen = function (event) {
      var p = document.createElement('p');
      p.textContent = '连接已打开';
      document.getElementById('message').appendChild(p);
      socket.send('Hello, WebSocket!');
    };

    // 接收到消息时触发
    socket.onmessage = function (event) {
      var p = document.createElement('p');
      p.textContent = '收到消息: '+ event.data;
      document.getElementById('message').appendChild(p);
    };

    // 连接关闭时触发
    socket.onclose = function (event) {
      var p = document.createElement('p');
      p.textContent = '连接已关闭';
      document.getElementById('message').appendChild(p);
    };

    // 发生错误时触发
    socket.onerror = function (error) {
      var p = document.createElement('p');
      p.textContent = '错误: '+ error.message;
      document.getElementById('message').appendChild(p);
    };
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>在目录中新建一个文件 <code>index.html</code> ,将上述代码复制到 <code>index.html</code> 中，然后使用浏览器打开该文件。</p>
<figure data-type="image" tabindex="1"><img src="http://img.upy.qiaoyukeji.cn/2024%2F07%2F01%2F20240701141938.png" alt="" loading="lazy"></figure>
<h2 id="4-总结">4. 总结</h2>
<p>本文档是本人学习使用 websocket 的一点记录，文中的代码片段仅为最基础的测试代码，仅用于测试 websocket 双向通联是否成功。</p>
<p>写于：2024.07.01</p>
<hr>
<p>参考文档：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/690282564">https://zhuanlan.zhihu.com/p/690282564</a></li>
<li><a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html">https://www.cnblogs.com/chyingp/p/websocket-deep-in.html</a></li>
<li><a href="https://www.runoob.com/html/html5-websocket.html">https://www.runoob.com/html/html5-websocket.html</a></li>
<li><a href="http://www.websocket-test.com/">http://www.websocket-test.com/</a></li>
<li><a href="https://www.doubao.com/">https://www.doubao.com/</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构建NPS内网穿透服务客户端GUI界面]]></title>
        <id>https://blog.zhawenwen.cn/post/nps_gui/</id>
        <link href="https://blog.zhawenwen.cn/post/nps_gui/">
        </link>
        <updated>2024-04-07T09:18:40.000Z</updated>
        <summary type="html"><![CDATA[<p>本教程使用 PySimpleGUI 绘制内网穿透服务客户端 GUI页面，使用 pyinstaller 打包构建出 exe 程序，适用于windows 操作系统</p>
]]></summary>
        <content type="html"><![CDATA[<p>本教程使用 PySimpleGUI 绘制内网穿透服务客户端 GUI页面，使用 pyinstaller 打包构建出 exe 程序，适用于windows 操作系统</p>
<!-- more -->
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E9%97%AE%E9%A2%98%E6%9D%A5%E6%BA%90">1、问题来源</a></li>
<li><a href="#2-%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B">2、操作教程</a>
<ul>
<li><a href="#21-%E5%8E%9F%E7%90%86">2.1 原理</a></li>
<li><a href="#22-nps_gui%E7%95%8C%E9%9D%A2%E4%BB%A3%E7%A0%81">2.2 NPS_GUI界面代码</a></li>
<li><a href="#23-python-%E7%A8%8B%E5%BA%8F%E8%BD%AC-exe-%E7%A8%8B%E5%BA%8F">2.3 python 程序转 exe 程序</a></li>
</ul>
</li>
<li><a href="#3-%E6%80%BB%E7%BB%93">3、总结</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="1-问题来源">1、问题来源</h2>
<p>本人之前撰写过一个 <a href="https://blog.gitnote.cn/post/nps/">使用nps搭建内网穿透并配置泛域名解析</a>的教程，但其中的运行客户端程序使用的是 CMD 命令行进行操作，并且需要配置的参数较多，总是记不住。<br>
<img src="https://md.gitnote.cn/nps%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-1673272870029-20231922117.png" alt="" loading="lazy"></p>
<p>所以就在考虑是否能将 cmd 命令程序转成 EXE GUI程序，方便配置参数运行。本教程就营运而生了。</p>
<h2 id="2-操作教程">2、操作教程</h2>
<h3 id="21-原理">2.1 原理</h3>
<p>PySimpleGUI是一个用于创建图形用户界面（GUI）的Python模块。本教程使用 PySimpleGUI 为 NPS内网穿透客户端程序(v0.26.0)制作了一个GUI界面。</p>
<h3 id="22-nps_gui界面代码">2.2 NPS_GUI界面代码</h3>
<p>首先新建一个目录为 <code>nps_gui</code> ，在目录中新建一个 <code>main.py</code> 程序，并将与 <code>nps</code> 服务端配套的 <code>npc.exe</code> 文件复制到该目录下。<br>
<code>main.py</code> 程序为主程序，用来绘制 GUI 界面，调用 CMD 命令运行程序。<br>
<code>main.py</code> 程序内容如下：</p>
<pre><code class="language-python"># main.py

import subprocess
import threading
import PySimpleGUI as sg

# 定义版本号和作者信息
version = &quot;0.0.1&quot;
author = &quot;巧遇科技工作室&quot;
about_me = &quot;本程序是NPS内网穿透服务的GUI界面，用来辅助NPS内网穿透服务客户端进行使用，与之配套的NPS版本为0.26.10。&quot;

def read_output(process, output_element):
    &quot;&quot;&quot;
    读取子进程的输出并将其传递给GUI线程显示的函数
    &quot;&quot;&quot;
    for line in process.stdout:
        output_element.print(line.strip())

    for line in process.stderr:
        output_element.print(line.strip())

# 定义GUI布局
layout = [
    [sg.Menu([['关于', ['本程序介绍','版本号', '作者']]])],
    [sg.Text(&quot;服务端地址(IP):&quot;), sg.Input(default_text=&quot;nps.qiaoyukeji.cn&quot;,key=&quot;-ADDRESS-&quot;)],
    [sg.Text(&quot;服务端端口号:&quot;), sg.Input(default_text=&quot;28024&quot;,key=&quot;-PORT-&quot;)],
    [sg.Text(&quot;验证密钥(vkey):&quot;), sg.Input(key=&quot;-VKEY-&quot;)],
    [sg.Text(&quot;连接方式:&quot;), sg.Input(default_text=&quot;tcp&quot;,key=&quot;-TYPE-&quot;)],
    [sg.Button(&quot;连接远程穿透服务器&quot;), sg.Button(&quot;退出&quot;)],
    [sg.Output(size=(60, 10), key=&quot;-OUTPUT-&quot;)]
]

# 创建窗口
window = sg.Window(&quot;NPS内网穿透GUI工具（v0.0.1）&quot;, layout)
output_element = window[&quot;-OUTPUT-&quot;]

# 事件循环
while True:
    event, values = window.read()

    if event == sg.WINDOW_CLOSED or event == &quot;退出&quot;:
        break

    if event == &quot;连接远程穿透服务器&quot;:
        address = values[&quot;-ADDRESS-&quot;]
        port = values[&quot;-PORT-&quot;]
        vkey = values[&quot;-VKEY-&quot;]
        type = values[&quot;-TYPE-&quot;]

        command = f&quot;npc.exe -server={address}:{port} -vkey={vkey} -type={type}&quot;
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
            startupinfo=startupinfo,
            creationflags=subprocess.CREATE_NO_WINDOW
        )

        # 创建线程读取子进程输出并传递给GUI线程显示
        output_thread = threading.Thread(target=read_output, args=(process, output_element), daemon=True)
        output_thread.start()

    if event == &quot;版本号&quot;:
        sg.popup(f&quot;版本号: {version}&quot;)

    if event == &quot;作者&quot;:
        sg.popup(f&quot;作者: {author}&quot;)
    if event == &quot;本程序介绍&quot;:
        sg.popup(f&quot;{about_me}&quot;)

# 关闭窗口
window.close()
</code></pre>
<p>目录下输入 <code>python main.py</code> 运行程序，程序的运行图如下所示。</p>
<figure data-type="image" tabindex="1"><img src="http://img.upy.qiaoyukeji.cn/2024/04/06/20240406214012.png" alt="" loading="lazy"></figure>
<p>填写好自己的 nps 服务端的 网址(IP)、端口、验证密钥(vkey)与连接方式，点击连接显示连接成功。</p>
<figure data-type="image" tabindex="2"><img src="http://img.upy.qiaoyukeji.cn/2024/04/07/20240407164854.png" alt="" loading="lazy"></figure>
<p>至此，python 代码版的 nps 客户端 GUI 程序已完成。</p>
<h3 id="23-python-程序转-exe-程序">2.3 python 程序转 exe 程序</h3>
<p>python 版的程序虽然已经完成，但是需要电脑先安装 python 运行环境，并且安装对应的 python 库，之后运行 python 代码才能正真的运行起来程序，对于普通人来说过于麻烦与繁琐了。</p>
<p>能不能打包成 exe 文件，无需安装，双击就能运行呢？</p>
<p>答案是肯定的，就是使用 <code>pyinstaller</code> 。<br>
PyInstaller 是一个用于将 Python 应用程序打包成可执行文件的工具。它可以将 Python 脚本及其依赖的库、资源文件等打包成一个独立的可执行文件，方便在没有 Python 解释器的环境中运行。</p>
<p>首先安装使用 <code>pip install pyinstaller</code> 安装 <code>pyinstaller</code> ；<br>
之后在上面的目录中运行 PyInstaller 打包程序；</p>
<pre><code class="language-bash">pyinstaller --onefile --hidden-import PySimpleGUI main.py --name &quot;NPS内网穿透客户端GUI程序&quot;  --noconsole
</code></pre>
<blockquote>
<p>--onefile：指定生成一个单个的可执行文件，而不是生成一个文件夹包含多个文件。这意味着所有的依赖项将被打包到一个可执行文件中。</p>
<p>--hidden-import PySimpleGUI：指定需要导入的额外模块或库。在这个例子中，指定了需要导入PySimpleGUI库，因为脚本&quot;main.py&quot;中使用了PySimpleGUI。这样PyInstaller会确保将该库包含在生成的可执行文件中。</p>
<p>main.py：要打包的Python脚本的文件名或路径。在这个例子中，指定了&quot;main.py&quot;作为要打包的脚本。</p>
<p>--name &quot;NPS内网穿透客户端GUI程序&quot;：指定生成的可执行文件的名称。在这个例子中，指定了生成的可执行文件的名称为&quot;NPS内网穿透客户端GUI程序&quot;。</p>
<p>--noconsole：指定生成的可执行文件在运行时不显示控制台窗口。这适用于图形用户界面（GUI）应用程序，因为它们通常不需要显示控制台输出。</p>
</blockquote>
<p>上述打包程序就可以在目录下生成一个 <code>dist</code> 目录、将 <code>main.py</code> 打包成一个 <code>exe</code> 程序放置在 <code>dist</code> 目录中，然后我们需要将 <code>npc.exe</code> 也复制一份到 <code>dist</code> 目录中。</p>
<p><img src="http://img.upy.qiaoyukeji.cn/2024/04/07/20240407170648.png" alt="" loading="lazy"><br>
在 <code>dist</code> 目录中双击 <code>NPS内网穿透客户端GUI程序.exe</code> 即可正常运行 NPS_GUI 程序。</p>
<p>我们可以将  <code>NPS内网穿透客户端GUI程序.exe</code>  与 <code>npc.exe</code> 两个文件打包成一个压缩包发送给他人，他人无需安装配置运行环境、仅需解压缩后双击程序即可运行程序。</p>
<p>至此 nps 客户端程序 GUI 界面程序已全部完成。</p>
<h2 id="3-总结">3、总结</h2>
<p>本教程已在 Gitee、Github中进行开源。<br>
Gitee：https://gitee.com/qiaoyukeji/nps_gui<br>
Github：https://github.com/qiaoyukeji/nps_gui</p>
<p>本教程使用的是 <code>PySimpleGUI</code> 绘制 GUI 界面，由于 <code>PySimpleGUI</code>  库本身的问题，第一次使用会提示<mark>填入授权码</mark>或者<mark>选择忽略跳过</mark>。<br>
授权码 <code>PySimpleGUI</code> 官方免费提供，但需要注册领取，填入注册授权码后可一直免费使用。<br>
选择忽略将导致 <code>PySimpleGUI</code> 绘制的程序将只能试用31天，注册填入授权码即可解决</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nanopc-T4硬件连接与数据采集上传物联网平台交接文档（内部交接使用）]]></title>
        <id>https://blog.zhawenwen.cn/post/inside_001/</id>
        <link href="https://blog.zhawenwen.cn/post/inside_001/">
        </link>
        <updated>2024-04-03T12:41:17.000Z</updated>
        <summary type="html"><![CDATA[<p>本文档为实验室内部交接文档，无其他含义</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文档为实验室内部交接文档，无其他含义</p>
<!-- more -->
<h1 id="nanopc-t4硬件连接与数据采集上传">nanopc-T4硬件连接与数据采集上传</h1>
<p>内容：硬件交接（nanopc-T4）<br>
时间：2024.04.01</p>
<h2 id="一-nanopc-t4硬件连接">一、nanopc-T4硬件连接</h2>
<p>需要硬件：nanopc-T4、罗技C920摄像头、氨气传感器、四合一传感器等、RS485</p>
<h2 id="二-nanopc-t4运行软件">二、nanopc-T4运行软件</h2>
<h3 id="21-使用ssh协议连接nanopc-t4">2.1 使用SSH协议连接nanopc-T4</h3>
<p>将 nanopc-T4 与电脑连接到同一个网段（路由器）中，在电脑中安装 xshell 软件连接到 nanopc-T4。<br>
普通账号密码：pi，pi<br>
root账号密码：root，fa</p>
<h3 id="22-获取运行程序并修改设备id">2.2 获取运行程序并修改设备ID</h3>
<p>在nanopc-T4 中下载需要运行的程序，通过 Git 获取运行程序，https://gitee.com/qiaoyukeji/nanopc2jetlinks4mqtt，<br>
所有要运行的具体内容都在程序的 <code>test_008_mqttControl</code> 目录中，修改运行程序中的设备 ID</p>
<h3 id="23-设置程序的自动启动与nanopc-t4的自动重启">2.3 设置程序的自动启动与nanopc-T4的自动重启</h3>
<p>设置程序的自启动等方法在 <code>test_008_mqttControl</code> 中的 readme.md 中</p>
<h2 id="三-物联网平台相关操作">三、物联网平台相关操作</h2>
<p>平台网址：http://aau.aau506.cn<br>
账号密码：</p>
<h3 id="31-新建设备">3.1 新建设备</h3>
<p>按前期标准设置 id 号</p>
<h3 id="32-设置连接密钥并配置物模型">3.2 设置连接密钥并配置物模型</h3>
<p>设置好连接的账号密码、并配置好属性定义物模型与功能定义物模型</p>
<h2 id="四-视频实时采集">四、视频实时采集</h2>
<h3 id="41-腾讯云直播仅需第一次修改">4.1 腾讯云直播（仅需第一次修改）</h3>
<p>添加推流域名，领取免费的20G测试流量</p>
<h3 id="42-域名解析仅需第一次修改">4.2 域名解析（仅需第一次修改）</h3>
<h3 id="43-nanopc-t4端运行">4.3 nanopc-T4端运行</h3>
<p>运行程序在 <code>test_009_onlyFFmpeg</code> 目录中</p>
<h3 id="44-可视化展示端修改程序展示仅需第一次修改">4.4 可视化展示端修改程序展示（仅需第一次修改）</h3>
<p>修改 大数据可视化界面的 <code>play.js</code><br>
平台网址：http://1.117.229.138:8888/qiaoyu<br>
账号密码：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023年年度总结回顾（流水账）]]></title>
        <id>https://blog.zhawenwen.cn/post/2023/</id>
        <link href="https://blog.zhawenwen.cn/post/2023/">
        </link>
        <updated>2024-01-03T03:08:10.000Z</updated>
        <summary type="html"><![CDATA[<p>2023年是难忘的一年，前半年主要在改小论文、写程序、调试开发板；后半年主要找工作、准备考试等，时间过的非常的匆忙，以至于比以前少了很多的乐趣，本次将 2023 年的一些我的日常活动做个流水账总结，自我勉励。</p>
]]></summary>
        <content type="html"><![CDATA[<p>2023年是难忘的一年，前半年主要在改小论文、写程序、调试开发板；后半年主要找工作、准备考试等，时间过的非常的匆忙，以至于比以前少了很多的乐趣，本次将 2023 年的一些我的日常活动做个流水账总结，自我勉励。</p>
<!-- more -->
<blockquote>
<p>待到秋来九月八，我花开后百花杀。冲天香阵透长安，满城尽带黄金甲。</p>
</blockquote>
<h1 id="一-年度数据总结">一、 年度数据总结</h1>
<h2 id="博客文章">博客文章：</h2>
<p>2023年，本人共撰写博客教程 17 篇，分别发布在本人博客、CSDN、知乎、掘金等平台上；个人博客浏览量 14562，CSDN 浏览量 16217，知乎浏览量 3.7 万，掘金浏览量 5624 ，总浏览量（不完全统计）7.5万，总收藏量 300+ 。</p>
<h2 id="githubgitee">Github&amp;Gitee：</h2>
<p>2023年，本人在 Github/Gitee 平台开源项目 4个，提交代码 100+ 次，收获 Star 14 个，fork 2 次。</p>
<figure data-type="image" tabindex="1"><img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102194729.png" alt="" loading="lazy"></figure>
<h1 id="二-年度流水账">二、年度流水账</h1>
<p>由于2022年年底众所周知的原因，学校提前放假，我也早早的回家了。</p>
<ul>
<li>
<p>2023年1月1日，老家，干枯的池塘。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/03/20240103194921.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年1月15日，老家，下雪了。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/03/20240103195112.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年1月19日，老家，年前一起炸糯米圆子。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102142956.jpg" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年1月30日，独秀山一日游 + 家乡池塘网鱼。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102143307.png" alt="" loading="lazy"><img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102143452.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年2月11日，开学了，实验室一起吃火锅。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102143722.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年2月18，在学校，已毕业的师兄组局请吃饭。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102144112.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年2月20日~2023年2月22日，实验室一起出差去合作的养殖基地。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102144450.png" alt="" loading="lazy"><br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102144546.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年3月4日，实验室小伙伴们一起植物园一日游。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102144819.png" alt="" loading="lazy"></p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102144918.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>2023年3月11日，和小伙伴们一起牛蛙铜火锅搞起。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102145231.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年3月13日~2023年3月14日，第二次出差去养殖基地安装设备。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102145531.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年3月30日，去医院拔牙齿，拔完最后一颗歪的智齿，吃了一周流食。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102165905.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年4月7日，由于元旦提前放假了，没有一起吃饭，老师补请吃饭。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102170221.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年4月9日，实验室一行十多人出发去往巢湖姆山岛一日游。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102170429.png" alt="" loading="lazy"><br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102170533.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年5月20日，研一开题结束，实验室一行去火锅撸串。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102170859.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年5月27日，在实验室看恐怖片。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102184625.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年6月2日，无线电台执照 GET。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102184850.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年6月4日，实验室毕业答辩通过聚餐。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102185101.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年6月17日，师兄们毕业请吃饭。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102185258.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年7月1日，杏花公园相亲角。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102185702.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年7月、8月、9月、10月部分数据丢失。</p>
</li>
<li>
<p>2023年11月22日，工作没找到，却收到了智联招聘邮寄的 J20 模型。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102190519.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年11月26日，参加 2024年国家公务员考试，考试内容非常难，试卷都没有写完；考试地点也非常远，连车都打不到。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102191420.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年12月3日，参加国家电网校园招聘统一考试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102192111.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年12月9日，参加南方电网校园招聘统一考试。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102192415.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年12月16日，考完四六级小伙伴们一起吃火锅。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102192625.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年12月18日，下大雪了。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102192803.png" alt="" loading="lazy"></p>
</li>
<li>
<p>2023年12月31日，跨年夜吃饭等了好久，有两个多小时，庐州太太给打了 8.5 折。<br>
<img src="http://img.upy.qiaoyukeji.cn/2024/01/02/20240102193053.png" alt="" loading="lazy"></p>
</li>
</ul>
<hr>
<p>2023年下半年非常之忙，一边投简历找工作、一边准备各项考试。投简历投了大概 100+ 家，收到笔试没多少，面试更是寥寥无几，工作难找呀。</p>
<p>希望 2024 年找工作能够顺风顺水，论文写作也能够一帆风顺。</p>
<figure data-type="image" tabindex="3"><img src="http://img.upy.qiaoyukeji.cn/2024/01/03/20240103101742.png" alt="" loading="lazy"></figure>
<blockquote>
<p>他日若遂凌云志，敢笑黄巢不丈夫。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust编程入门——第三章_通用编程概念]]></title>
        <id>https://blog.zhawenwen.cn/post/rust_learn_003/</id>
        <link href="https://blog.zhawenwen.cn/post/rust_learn_003/">
        </link>
        <updated>2023-12-26T12:59:57.000Z</updated>
        <summary type="html"><![CDATA[<p>一门赋予每个人构建可靠且高效软件能力的语言。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一门赋予每个人构建可靠且高效软件能力的语言。</p>
<!-- more -->
<h2 id="第三章-通用编程概念">第三章  通用编程概念</h2>
<ul>
<li>变量与可变性</li>
<li>数据类型
<ul>
<li>标量类型</li>
<li>符合类型</li>
</ul>
</li>
<li>函数</li>
<li>注释</li>
<li>控制流</li>
</ul>
<h3 id="31-变量与可变性">3.1 变量与可变性</h3>
<h4 id="311-变量">3.1.1 变量</h4>
<ul>
<li>申明变量使用 <code>let</code> 关键字</li>
<li>默认情况下，变量是不可变的（<code>immutable</code>）</li>
</ul>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    let x: i32=5;
    println!(&quot;the value of x is {}&quot;,x);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://img.upy.qiaoyukeji.cn/2023/12/25/20231225152936.png" alt="" loading="lazy"></figure>
<ul>
<li>申明变量时，在变量前面加上 <code>mut</code>，就可以使变量可变</li>
</ul>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    let mut x: i32=5;
    x=8;
    println!(&quot;the value of x is {}&quot;,x);
}
</code></pre>
<h4 id="312-常量">3.1.2 常量</h4>
<ul>
<li>常量（<code>constant</code>），常量在绑定值以后是不可变的，但是让他与不可变的变量有很多区别：
<ul>
<li>不可以使用 <code>mut</code> ，常量永远都是不可变的</li>
<li>申明常量使用 <code>const</code> 关键字，它的类型必须被标注</li>
<li>常量可以在任何作用域内申明，包括全局作用域</li>
<li>常量只能绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算的值</li>
</ul>
</li>
<li>在程序运行期间，常量在其申明的作用域内一直有效</li>
<li>命名规范：<code>Rust</code> 里常量使用全大写字母，每个单词之间用下划线分开，例如：
<ul>
<li><code>MAX_POINTS</code></li>
<li><code>const MAX_POINTS:u32 = 100_000;</code></li>
</ul>
</li>
</ul>
<pre><code class="language-rust">const MAX_POINTS:u32 = 100_000;

fn main() {
    println!(&quot;Hello, world!&quot;);
    println!(&quot;the number is {}&quot;,MAX_POINTS)
}

</code></pre>
<h4 id="313-shadowing隐藏">3.1.3 <code>Shadowing</code>（隐藏）</h4>
<ul>
<li>可以使用相同的名字申明新的变量，新的变量就会 <code>Shadow</code>（隐藏）之前申明的同名变量
<ul>
<li>在后续的代码中这个变量名代表的就是新的变量</li>
</ul>
</li>
</ul>
<pre><code class="language-rust">const MAX_POINTS:u32 = 100_000;

fn main() {
    println!(&quot;Hello, world!&quot;);

    println!(&quot;the number is {}&quot;,MAX_POINTS)
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://img.upy.qiaoyukeji.cn/2023/12/25/20231225154756.png" alt="" loading="lazy"></figure>
<ul>
<li><code>Shadow</code> 和把变量标记为 <code>mut</code> 是不一样的：
<ul>
<li>如果不使用 <code>let</code> 关键字，那么重新给非 <code>mut</code> 的变量赋值会导致编译错误</li>
<li>而使用 <code>let</code> 申明的同名新变量，也是不可变的</li>
<li>使用 <code>let</code> 申明的同名新变量，他的类型可以与之前不同</li>
</ul>
</li>
</ul>
<pre><code class="language-rust">fn main() {
    let spaces = &quot;    &quot;;
    let spaces=spaces.len();
    
    println!(&quot;the number is {}&quot;, spaces)  // 4
}
</code></pre>
<h3 id="32-数据类型">3.2 数据类型</h3>
<ul>
<li>标量和复合类型</li>
<li><code>Rust</code> 是静态编译语言，在编译时必须知道所有变量的类型
<ul>
<li>基于使用的值，编译器通常能够推断出它的具体类型</li>
<li>但如果可能的类型较多（如将 <code>String</code> 转为整数的 <code>parse</code> 方法），就必须添加类型的标注，否则编译会报错</li>
</ul>
</li>
</ul>
<pre><code class="language-rust">fn main() {
    let guess:i32 = &quot;42&quot;.parse().expect(&quot;not a number&quot;);

    println!(&quot;number is {}&quot;,guess);
}
</code></pre>
<h4 id="321-标量类型">3.2.1 标量类型</h4>
<ul>
<li>一个标量类型代表一个单个的值</li>
<li>Rust 有四个主要的标量类型：
<ul>
<li>整数类型</li>
<li>浮点类型</li>
<li>布尔类型</li>
<li>字符类型</li>
</ul>
</li>
</ul>
<h4 id="322-整数类型">3.2.2 整数类型</h4>
<h5 id="3221-基础介绍">3.2.2.1 基础介绍</h5>
<ul>
<li>
<p>整数类型没有小数部分</p>
</li>
<li>
<p>例如 <code>u32</code> 就是一个无符号的整数类型，占据32位空间</p>
</li>
<li>
<p>无符号整数类型以 <code>u</code> 开头</p>
</li>
<li>
<p>有符号整数类型以 <code>i</code> 开头</p>
</li>
<li>
<p>Rust 的整数类型列表如图：</p>
<ul>
<li>每种都分为 i 和 u ，以及固定位数</li>
<li>有符号的范围： -2<sup>(n-1)~2</sup>(n-1)-1</li>
<li>无符号的范围：0~2^n-1</li>
</ul>
<figure data-type="image" tabindex="3"><img src="http://img.upy.qiaoyukeji.cn/2023/12/25/20231225185142.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h5 id="3222-isize-和-usize">3.2.2.2 <code>isize</code> 和 <code>usize</code></h5>
<ul>
<li><code>isize</code> 和 <code>usize</code> 类型的位数由程序运行的计算机的架构所决定的：</li>
<li>如果是 64 位计算机，那就是 64 位的</li>
<li>使用 <code>isize</code> 和 <code>usize</code> 的主要场景是对某种集合进行索引操作</li>
</ul>
<h5 id="3223-整数字面值">3.2.2.3 整数字面值</h5>
<ul>
<li>除了 <code>byte</code> 类型外，所有的数值字面值都允许使用类型后缀
<ul>
<li>例如 <code>57u8</code></li>
</ul>
</li>
<li>如果不太清楚应该使用那种类型，可以使用 <code>Rust</code> 相应的默认类型</li>
<li>整数的默认类型就是 <code>i32</code>
<ul>
<li>总体上来说速冻更快，即使在 64 位系统中</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="http://img.upy.qiaoyukeji.cn/2023/12/25/20231225190417.png" alt="" loading="lazy"></figure>
<h5 id="3224-整数溢出">3.2.2.4 整数溢出</h5>
<ul>
<li>例如：u8 的范围是 0-255，如果你把一个 u8 变量的值设为 256 ，那么：
<ul>
<li>调试模式下编译：Rust 会检查整数溢出，如果发生溢出，程序在运行时就会 panic</li>
<li>发布模式下(--release)编译：Rust 不会检查可能导致 panic 的整数溢出
<ul>
<li>如果溢出发生：Rust 会执行“环绕”操作：
<ul>
<li>256 变成 0，257 变成 1 ...</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="323-浮点类型">3.2.3 浮点类型</h4>
<h5 id="3231-基础介绍">3.2.3.1 基础介绍</h5>
<ul>
<li>Rust 有两种基础的浮点类型，也就是含有小数部分的类型
<ul>
<li><code>f32</code>，32位，单精度</li>
<li><code>f64</code>，64为，双精度</li>
</ul>
</li>
<li>Rust 的浮点类型使用了 <code>IEEE-754</code> 标准来表达</li>
<li><code>f64</code> 是默认类型，因为在现代 CPU 上 <code>f64</code> 和 <code>f32</code> 的速度差不多，而且精度更高</li>
</ul>
<h5 id="3232-数值操作">3.2.3.2 数值操作</h5>
<ul>
<li>加减乘除余等</li>
</ul>
<pre><code class="language-rust">fn main() {
    let sum = 5 + 10;

    let difference = 95.5 - 4.3;

    let product = 4 * 30;

    let quotient = 56.7 / 32.2;

    let reminder = 54 % 5;
}
</code></pre>
<h4 id="324-布尔类型">3.2.4 布尔类型</h4>
<ul>
<li>Rust 的布尔类型也有两个值：true 和 false</li>
<li>一个字节大小</li>
<li>符号是 bool</li>
</ul>
<pre><code class="language-rust">fn main() {
    let t = true;
    let m: bool = false;
}
</code></pre>
<h4 id="325-字符类型">3.2.5 字符类型</h4>
<ul>
<li>Rust 语言中 char 类型被用来描述语言中最基础的单个字符。</li>
<li>字符类型的字面值使用单引号</li>
<li>占用 4 个字节大小</li>
<li>是 Unicode 标量值，可以表示比 ASCII 多得多的字符内容：拼音、中日韩文、零长度空白字符、emoji表情等。
<ul>
<li><code>U+0000</code> 到 <code>U+D7FF</code></li>
<li><code>U+E000</code> 到 <code>U+10FFFF</code></li>
</ul>
</li>
<li>但 Unicode 中并没有 “字符” 的概念，所以直觉上认为的字符也许与 Rust 中的概念并不相符</li>
</ul>
<pre><code class="language-rust">fn main() {
    let x: &amp;str = &quot;z&quot;;
    let y: char='z';
    let z: char='😂';
}
</code></pre>
<h3 id="33-复合类型">3.3 复合类型</h3>
<ul>
<li>复合类型可以将多个值放在一个类型里。</li>
<li>Rust 提供了两种基础的复合类型：元组（Tuple）、数组</li>
</ul>
<h4 id="331-元组tuple">3.3.1 元组（Tuple）</h4>
<ul>
<li>Tuple 可以将多个类型的多个值放到一个类型里</li>
<li>Tuple 的长度是固定的：一旦申明就无法改变</li>
</ul>
<h5 id="3311-创建-tuple">3.3.1.1 创建 Tuple</h5>
<ul>
<li>在小括号里，将值用逗号分开</li>
<li>Tuple 中的每一个位置都对应一个类型，Tuple 中个元素的类型不必相同</li>
</ul>
<pre><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) =(500,6.4,1);
    println!(&quot;{},{},{}&quot;,tup.0,tup.1,tup.2);
}
</code></pre>
<h5 id="3312-获取-tuple-的元素值">3.3.1.2 获取 Tuple 的元素值</h5>
<ul>
<li>可以使用模式匹配来解构（destructure）一个 Tuple 来获取元素的值</li>
</ul>
<pre><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) =(500,6.4,1);

    let (x,y,z) =tup;
    println!(&quot;{},{},{}&quot;,x,y,z);
}
</code></pre>
<h5 id="3313-访问-tuple-的元素">3.3.1.3 访问 Tuple 的元素</h5>
<ul>
<li>在 Tuple 变量使用点标记法，后接元素的索引号</li>
</ul>
<pre><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) =(500,6.4,1);
    println!(&quot;{},{},{}&quot;,tup.0,tup.1,tup.2);
}
</code></pre>
<h4 id="332-数组">3.3.2 数组</h4>
<ul>
<li>数组也可以将多个值放在同一个类型里</li>
<li>数组中每个元素的类型必须相同</li>
<li>数组的长度也是固定的</li>
</ul>
<h5 id="3321-申明数组">3.3.2.1 申明数组</h5>
<ul>
<li>在中括号里，各值用逗号分开</li>
</ul>
<pre><code class="language-rust">fn main() {
    let a = [1,2,3,4,5];
}
</code></pre>
<h5 id="3322-数组的用处">3.3.2.2 数组的用处</h5>
<ul>
<li>如果想让数据存放在 stack（栈）上而不是 heap（堆）上，或者想保证有固定数量的元素，这时使用数组更有好处</li>
<li>数组没有 Vector 灵活
<ul>
<li>Vector 和数组类似，它由标准库提供</li>
<li>Vector 的长度可以改变</li>
<li>如果你不确定应该使用数组还是 Vector ，那么估计你应该使用 Vector</li>
</ul>
</li>
</ul>
<h5 id="3323-数组的类型">3.3.2.3 数组的类型</h5>
<ul>
<li>数组的类型表示形式：[类型；长度]
<ul>
<li>例如：<code>let a:[i32;5] = [1,2,3,4,5];</code></li>
</ul>
</li>
</ul>
<h5 id="3324-另一种申明数组的方式">3.3.2.4 另一种申明数组的方式</h5>
<ul>
<li>如果数组的每个元素都相同，那么可以：
<ul>
<li>在中括号中指定初始值</li>
<li>然后是一个 &quot;;&quot;</li>
<li>最后是数组的长度</li>
<li>例如：<code>let a=[3;5];</code> 相当于 <code>let a = [3,3,3,3,3];</code></li>
</ul>
</li>
</ul>
<h5 id="3325-访问数组的元素">3.3.2.5 访问数组的元素</h5>
<ul>
<li>数组是在 stack 上分配的单个块的内存</li>
<li>可以使用索引来访问数组的元素</li>
<li>如果访问的索引<mark>超出了数组的范围</mark>，那么
<ul>
<li>编译会通过</li>
<li>运行会报错（runtime 时会 panic ）
<ul>
<li>Rust 不会允许其继续访问相应地址的内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-rust">fn main() {
    let a = [1,2,3,4,5];

    let first = a[0];
    let second = a[1];
}
</code></pre>
<h3 id="34-函数">3.4 函数</h3>
<ul>
<li>申明函数使用 fn 关键字</li>
<li>按照惯例，针对函数与变量名，Rust 使用 snake case 命名规范：
<ul>
<li>所有的字母都是小写，单词之间使用下划线分开</li>
</ul>
</li>
</ul>
<pre><code class="language-rust">fn main() {
    println!(&quot;hello world!&quot;);
    another_function();
}

fn another_function(){
    println!(&quot;Another function&quot;);
}
</code></pre>
<h4 id="341-函数的参数">3.4.1 函数的参数</h4>
<ul>
<li><code>parameters</code>、<code>arguments</code></li>
<li>在函数签名里，必须包含每个参数的类型</li>
</ul>
<pre><code class="language-rust">fn main() {
    println!(&quot;hello world!&quot;);
    another_function(5);    // argument
}

fn another_function(x:i32){    // parameter
    println!(&quot; the number is {}&quot;,x);
}
</code></pre>
<h4 id="342-函数体中的语句与表达式">3.4.2 函数体中的语句与表达式</h4>
<ul>
<li>函数体由一系列语句组成，可选的由一个表达式结束</li>
<li>Rust 是一个基于表达式的语言</li>
<li>语句是执行一些动作的指令</li>
<li>表达式会计算产生一个值</li>
<li>函数定义也是语句</li>
<li>语句不返回值，所以不可以使用 let 将一个语句赋给一个变量</li>
</ul>
<h4 id="343-函数的返回值">3.4.3 函数的返回值</h4>
<ul>
<li>在 <code>-&gt;</code> 符号后边申明函数返回值的类型，但是不可以为返回值命名</li>
<li>在 Rust 中，返回值就是函数体里面<mark>最后一个表达式的值</mark></li>
<li>若想提前返回。需使用 return 关键字，并指定一个值</li>
</ul>
<pre><code class="language-rust">fn main() {
    let x=five(1);
    println!(&quot;the number is {}&quot;,x); // 6
}

fn five(x:i32)-&gt;i32{
    x+5
}
</code></pre>
<h3 id="35-控制流-if-else">3.5 控制流 ：if else</h3>
<h4 id="351-if-表达式">3.5.1 if 表达式</h4>
<ul>
<li>if 表达式允许您根据条件来执行不同的代码分支
<ul>
<li>这个条件必须是bool类型</li>
</ul>
</li>
<li>if 表达式中，与条件相关联的代码块就叫做分支（arm）</li>
<li>可选的，在后边可以加上一个 else 表达式</li>
</ul>
<pre><code class="language-rust">fn main() {
    let num=3;
    if num&lt;5{
        println!(&quot;true&quot;);
    }else {
        println!(&quot;false&quot;);
    }
}
</code></pre>
<h4 id="352-使用-else-if-处理多重条件">3.5.2 使用 else if 处理多重条件</h4>
<ul>
<li>如果使用了多于一个 else if ，那么最好使用 match 来重构代码</li>
</ul>
<h4 id="353-在-let-语句中使用-if">3.5.3 在 let 语句中使用 if</h4>
<ul>
<li>因为 if 是一个表达式，所以可以将它放在 let 语句中等号的右边</li>
</ul>
<pre><code class="language-rust">fn main() {
    let condition = true;

    let num = if condition { 5 } else { 6 };
    
    println!(&quot;the number is {}&quot;,num);    // 5
}
</code></pre>
<h3 id="36-控制流-rust-的循环">3.6 控制流： Rust 的循环</h3>
<ul>
<li>Rust 提供了 3 中循环：loop，while 和 for</li>
</ul>
<h4 id="361-loop-循环">3.6.1 loop 循环</h4>
<ul>
<li>loop 关键字告诉 Rust 反复的执行一块代码，直到喊停</li>
<li>可以在 loop 循环中使用 break 关键字来告诉程序何时停止循环</li>
</ul>
<pre><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;the result is {}&quot;, result);    // 20
}
</code></pre>
<h4 id="362-while-条件循环">3.6.2 while 条件循环</h4>
<ul>
<li>另外一种常见的循环模式是每次执行循环体之前都判断一次条件</li>
<li>while条件循环为这种模式而生</li>
</ul>
<pre><code class="language-rust">fn main() {
    let mut counter = 3;

    while counter != 0 {
        println!(&quot;number is {}&quot;, counter);
        counter = counter - 1;
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre>
<h4 id="363-使用-for-循环遍历集合">3.6.3 使用 for 循环遍历集合</h4>
<ul>
<li>可是使用 while 或 loop 来遍历集合，但是易错且低效</li>
</ul>
<pre><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;{}&quot;, a[index]);

        index += 1;
    }
}
</code></pre>
<ul>
<li>使用 for 循环更简洁紧凑，它可以针对集合中的每个元素来执行一些代码</li>
</ul>
<pre><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    for element in a.iter(){
        println!(&quot;{}&quot;,element);
    }
}
</code></pre>
<ul>
<li>由于 for 循环的安全、简洁性，所以它在 Rust 里用的最多</li>
</ul>
<h4 id="364-range">3.6.4 Range</h4>
<ul>
<li>标准库提供</li>
<li>指定一个开始数字和一个结束数字，Range 可以生成它们之间的数字（不含结束）</li>
<li>rev 方法可以反转 Range</li>
</ul>
<pre><code class="language-rust">fn main() {
    for number in (1..4).rev(){
        println!(&quot;{}&quot;,number);
    }
    println!(&quot;LIFTOFF!!!&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++学习——01.C++基础]]></title>
        <id>https://blog.zhawenwen.cn/post/C++_001/</id>
        <link href="https://blog.zhawenwen.cn/post/C++_001/">
        </link>
        <updated>2023-10-04T09:15:04.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#c%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8">C++基础入门</a>
<ul>
<li><a href="#1-c%E5%88%9D%E8%AF%86">1 C++初识</a>
<ul>
<li><a href="#11-%E7%AC%AC%E4%B8%80%E4%B8%AAc%E7%A8%8B%E5%BA%8F">1.1  第一个C++程序</a>
<ul>
<li><a href="#111-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">1.1.1 创建项目</a></li>
<li><a href="#112-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6">1.1.2 创建文件</a></li>
<li><a href="#113-%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81">1.1.3 编写代码</a></li>
<li><a href="#114-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F">1.1.4 运行程序</a></li>
</ul>
</li>
<li><a href="#12-%E6%B3%A8%E9%87%8A">1.2 注释</a></li>
<li><a href="#14-%E5%B8%B8%E9%87%8F">1.4  常量</a></li>
<li><a href="#15-%E5%85%B3%E9%94%AE%E5%AD%97">1.5 关键字</a></li>
</ul>
</li>
<li><a href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2 数据类型</a>
<ul>
<li><a href="#21-%E6%95%B4%E5%9E%8B">2.1 整型</a></li>
<li><a href="#22-sizeof%E5%85%B3%E9%94%AE%E5%AD%97">2.2 sizeof关键字</a></li>
<li><a href="#24-%E5%AD%97%E7%AC%A6%E5%9E%8B">2.4 字符型</a></li>
<li><a href="#25-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6">2.5 转义字符</a></li>
<li><a href="#26-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B">2.6 字符串型</a></li>
<li><a href="#28-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5">2.8 数据的输入</a></li>
</ul>
</li>
<li><a href="#3-%E8%BF%90%E7%AE%97%E7%AC%A6">3 运算符</a>
<ul>
<li><a href="#31-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">3.1 算术运算符</a></li>
<li><a href="#32-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">3.2 赋值运算符</a></li>
<li><a href="#33-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6">3.3 比较运算符</a></li>
<li><a href="#34-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">3.4 逻辑运算符</a></li>
<li><a href="#41-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84">4.1 选择结构</a>
<ul>
<li><a href="#411-if%E8%AF%AD%E5%8F%A5">4.1.1 if语句</a></li>
<li><a href="#412-%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6">4.1.2 三目运算符</a></li>
<li><a href="#413-switch%E8%AF%AD%E5%8F%A5">4.1.3 switch语句</a></li>
</ul>
</li>
<li><a href="#42-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">4.2 循环结构</a>
<ul>
<li><a href="#421-while%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">4.2.1 while循环语句</a></li>
<li><a href="#422-dowhile%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">4.2.2 do...while循环语句</a></li>
<li><a href="#423-for%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">4.2.3 for循环语句</a></li>
<li><a href="#424-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF">4.2.4 嵌套循环</a></li>
</ul>
</li>
<li><a href="#43-%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5">4.3 跳转语句</a>
<ul>
<li><a href="#431-break%E8%AF%AD%E5%8F%A5">4.3.1 break语句</a></li>
<li><a href="#432-continue%E8%AF%AD%E5%8F%A5">4.3.2 continue语句</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-%E6%95%B0%E7%BB%84">5 数组</a>
<ul>
<li><a href="#51-%E6%A6%82%E8%BF%B0">5.1 概述</a></li>
<li><a href="#52-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">5.2 一维数组</a>
<ul>
<li><a href="#521-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F">5.2.1 一维数组定义方式</a></li>
<li><a href="#522-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E5%90%8D">5.2.2 一维数组数组名</a></li>
</ul>
</li>
<li><a href="#53-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">5.3 二维数组</a>
<ul>
<li><a href="#531-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F">5.3.1 二维数组定义方式</a></li>
<li><a href="#532-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E5%90%8D">5.3.2 二维数组数组名</a></li>
<li><a href="#533-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><strong>5.3.3 二维数组应用案例</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-%E5%87%BD%E6%95%B0">6 函数</a>
<ul>
<li><a href="#61-%E6%A6%82%E8%BF%B0">6.1 概述</a></li>
<li><a href="#62-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">6.2 函数的定义</a></li>
<li><a href="#64-%E5%80%BC%E4%BC%A0%E9%80%92">6.4 值传递</a></li>
<li><a href="#65-%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F"><strong>6.5 函数的常见样式</strong></a></li>
</ul>
</li>
<li><a href="#7-%E6%8C%87%E9%92%88">7 指针</a>
<ul>
<li><a href="#71-%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">7.1 指针的基本概念</a></li>
<li><a href="#72-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8">7.2 指针变量的定义和使用</a></li>
<li><a href="#76-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84">7.6 指针和数组</a></li>
<li><a href="#78-%E6%8C%87%E9%92%88-%E6%95%B0%E7%BB%84-%E5%87%BD%E6%95%B0">7.8 指针、数组、函数</a></li>
</ul>
</li>
<li><a href="#8-%E7%BB%93%E6%9E%84%E4%BD%93">8 结构体</a>
<ul>
<li><a href="#81-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">8.1 结构体基本概念</a></li>
<li><a href="#82-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8">8.2 结构体定义和使用</a></li>
<li><a href="#83-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84">8.3 结构体数组</a></li>
<li><a href="#85-%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93">8.5 结构体嵌套结构体</a></li>
<li><a href="#86-%E7%BB%93%E6%9E%84%E4%BD%93%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">8.6 结构体做函数参数</a></li>
<li><a href="#87-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD-const%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">8.7 结构体中 const使用场景</a></li>
<li><a href="#88-%E7%BB%93%E6%9E%84%E4%BD%93%E6%A1%88%E4%BE%8B">8.8 结构体案例</a>
<ul>
<li><a href="#881-%E6%A1%88%E4%BE%8B1">8.8.1 案例1</a></li>
<li><a href="#882-%E6%A1%88%E4%BE%8B2">8.8.2 案例2</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="c基础入门">C++基础入门</h1>
<h2 id="1-c初识">1 C++初识</h2>
<h3 id="11-第一个c程序">1.1  第一个C++程序</h3>
<p>编写一个C++程序总共分为4个步骤</p>
<ul>
<li>创建项目</li>
<li>创建文件</li>
<li>编写代码</li>
<li>运行程序</li>
</ul>
<h4 id="111-创建项目">1.1.1 创建项目</h4>
<p>​	Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</p>
<p><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004172903.png" alt="" loading="lazy"><br>
<img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004172929.png" alt="" loading="lazy"></p>
<h4 id="112-创建文件">1.1.2 创建文件</h4>
<p>右键源文件，选择添加-&gt;新建项</p>
<figure data-type="image" tabindex="1"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173001.png" alt="" loading="lazy"></figure>
<p>给C++文件起个名称，然后点击添加即可。</p>
<figure data-type="image" tabindex="2"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173035.png" alt="" loading="lazy"></figure>
<h4 id="113-编写代码">1.1.3 编写代码</h4>
<pre><code class="language-c++">#include&lt;iostream&gt;
using namespace std;

int main() {

	cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="114-运行程序">1.1.4 运行程序</h4>
<figure data-type="image" tabindex="3"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173103.png" alt="" loading="lazy"></figure>
<h3 id="12-注释">1.2 注释</h3>
<p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p>
<p><strong>两种格式</strong></p>
<ol>
<li><strong>单行注释</strong>：<code>// 描述信息</code>
<ul>
<li>通常放在一行代码的上方，或者一条语句的末尾，<mark>对该行代码说明</mark></li>
</ul>
</li>
<li><strong>多行注释</strong>： <code>/* 描述信息 */</code>
<ul>
<li>通常放在一段代码的上方，<mark>对该段代码做整体说明</mark></li>
</ul>
</li>
</ol>
<blockquote>
<p>提示：编译器在编译代码时，会忽略注释的内容### 1.3 变量</p>
</blockquote>
<p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p>
<p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include&lt;iostream&gt;
using namespace std;

int main() {

	//变量的定义
	//语法：数据类型  变量名 = 初始值

	int a = 10;

	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p>
</blockquote>
<h3 id="14-常量">1.4  常量</h3>
<p><strong>作用</strong>：用于记录程序中不可更改的数据</p>
<p>C++定义常量两种方式</p>
<ol>
<li><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code>
<ul>
<li><mark>通常在文件上方定义</mark>，表示一个常量2. <strong>const</strong>修饰的变量 <code>const 数据类型 常量名 = 常量值</code></li>
<li><mark>通常在变量定义前加关键字const</mark>，修饰该变量为常量，不可修改<br>
<strong>示例：</strong></li>
</ul>
</li>
</ol>
<pre><code class="language-C++">//1、宏常量
#define day 7

int main() {

	cout &lt;&lt; &quot;一周里总共有 &quot; &lt;&lt; day &lt;&lt; &quot; 天&quot; &lt;&lt; endl;
	//day = 8;  //报错，宏常量不可以修改

	//2、const修饰变量
	const int month = 12;
	cout &lt;&lt; &quot;一年里总共有 &quot; &lt;&lt; month &lt;&lt; &quot; 个月份&quot; &lt;&lt; endl;
	//month = 24; //报错，常量是不可以修改的
	
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="15-关键字">1.5 关键字</h3>
<p>**作用：**关键字是C++中预先保留的单词（标识符）</p>
<ul>
<li><strong>在定义变量或者常量时候，不要用关键字</strong><br>
C++关键字如下：</li>
</ul>
<table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code>### 1.6 标识符命名规则</p>
<p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p>
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<blockquote>
<p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p>
</blockquote>
<h2 id="2-数据类型">2 数据类型</h2>
<p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p>
<h3 id="21-整型">2.1 整型</h3>
<p><strong>作用</strong>：整型变量表示的是<mark>整数类型</mark>的数据</p>
<p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>short(短整型)</td>
<td>2字节</td>
<td>(-2^15 ~ 2^15-1)</td>
</tr>
<tr>
<td>int(整型)</td>
<td>4字节</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long(长整形)</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long long(长长整形)</td>
<td>8字节</td>
<td>(-2^63 ~ 2^63-1)</td>
</tr>
</tbody>
</table>
<h3 id="22-sizeof关键字">2.2 sizeof关键字</h3>
<p>**作用：**利用sizeof关键字可以<mark>统计数据类型所占内存大小</mark></p>
<p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	cout &lt;&lt; &quot;short 类型所占内存空间为： &quot; &lt;&lt; sizeof(short) &lt;&lt; endl;

	cout &lt;&lt; &quot;int 类型所占内存空间为： &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;

	cout &lt;&lt; &quot;long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long) &lt;&lt; endl;

	cout &lt;&lt; &quot;long long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
```&gt; **整型结论**：==short &lt; int &lt;= long &lt;= long long==
### 2.3 实型（浮点型）

**作用**：用于==表示小数==

浮点型变量分为两种：

1. 单精度float 
2. 双精度double

两者的**区别**在于表示的有效数字范围不同。

| **数据类型** | **占用空间** | **有效数字范围** |
| ------------ | ------------ | ---------------- |
| float        | 4字节        | 7位有效数字      |
| double       | 8字节        | 15～16位有效数字 |

**示例：**

```C++
int main() {

	float f1 = 3.14f;
	double d1 = 3.14;

	cout &lt;&lt; f1 &lt;&lt; endl;
	cout &lt;&lt; d1&lt;&lt; endl;

	cout &lt;&lt; &quot;float  sizeof = &quot; &lt;&lt; sizeof(f1) &lt;&lt; endl;
	cout &lt;&lt; &quot;double sizeof = &quot; &lt;&lt; sizeof(d1) &lt;&lt; endl;

	//科学计数法
	float f2 = 3e2; // 3 * 10 ^ 2 
	cout &lt;&lt; &quot;f2 = &quot; &lt;&lt; f2 &lt;&lt; endl;

	float f3 = 3e-2;  // 3 * 0.1 ^ 2
	cout &lt;&lt; &quot;f3 = &quot; &lt;&lt; f3 &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="24-字符型">2.4 字符型</h3>
<p>**作用：**字符型变量用于显示单个字符</p>
<p><strong>语法：</strong><code>char ch = 'a';</code></p>
<blockquote>
<p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p>
</blockquote>
<blockquote>
<p>注意2：单引号内只能有一个字符，不可以是字符串</p>
</blockquote>
<ul>
<li>C和C++中字符型变量只占用<mark>1个字节</mark>。</li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元<br>
示例：</li>
</ul>
<pre><code class="language-C++">int main() {
	
	char ch = 'a';
	cout &lt;&lt; ch &lt;&lt; endl;
	cout &lt;&lt; sizeof(char) &lt;&lt; endl;

	//ch = &quot;abcde&quot;; //错误，不可以用双引号
	//ch = 'abcde'; //错误，单引号内只能引用一个字符

	cout &lt;&lt; (int)ch &lt;&lt; endl;  //查看字符a对应的ASCII码
	ch = 97; //可以直接用ASCII给字符型变量赋值
	cout &lt;&lt; ch &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>ASCII码表格：</p>
<table>
<thead>
<tr>
<th><strong>ASCII</strong>值</th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>&quot;</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>/</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>/</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>=</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>`</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody>
</table>
<p>ASCII 码大致由以下<strong>两部分组</strong>成：</p>
<ul>
<li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul>
<h3 id="25-转义字符">2.5 转义字符</h3>
<p>**作用：**用于表示一些<mark>不能显示出来的ASCII字符</mark></p>
<p>现阶段我们常用的转义字符有：<code> \n  \\  \t</code></p>
<table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td><strong>\\</strong></td>
<td><strong>代表一个反斜线字符&quot;&quot;</strong></td>
<td><strong>092</strong></td>
</tr>
<tr>
<td>'</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围0<sub>9，a</sub>f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<pre><code class="language-C++">int main() {
	
	
	cout &lt;&lt; &quot;\\&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;\tHello&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;\n&quot; &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="26-字符串型">2.6 字符串型</h3>
<p><strong>作用</strong>：用于表示一串字符</p>
<p><strong>两种风格</strong></p>
<ol>
<li>
<p><strong>C风格字符串</strong>： <code>char 变量名[] = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<pre><code class="language-C++">int main() {

	char str1[] = &quot;hello world&quot;;
	cout &lt;&lt; str1 &lt;&lt; endl;
    
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
</li>
</ol>
<blockquote>
<p>注意：C风格的字符串要用双引号括起来</p>
</blockquote>
<ol>
<li>
<p><strong>C++风格字符串</strong>：  <code>string  变量名 = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<pre><code class="language-C++">int main() {

	string str = &quot;hello world&quot;;
	cout &lt;&lt; str &lt;&lt; endl;
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
</li>
</ol>
<blockquote>
<p>注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;==### 2.7 布尔类型 bool</p>
</blockquote>
<p><strong>作用：</strong> 布尔数据类型代表真或假的值</p>
<p>bool类型只有两个值：</p>
<ul>
<li>true  --- 真（本质是1）</li>
<li>false --- 假（本质是0）</li>
</ul>
<p><strong>bool类型占<mark>1个字节</mark>大小</strong></p>
<p>示例：</p>
<pre><code class="language-C++">int main() {

	bool flag = true;
	cout &lt;&lt; flag &lt;&lt; endl; // 1

	flag = false;
	cout &lt;&lt; flag &lt;&lt; endl; // 0

	cout &lt;&lt; &quot;size of bool = &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; //1
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="28-数据的输入">2.8 数据的输入</h3>
<p><strong>作用：用于从键盘获取数据</strong></p>
<p><strong>关键字：</strong> cin</p>
<p><strong>语法：</strong> <code>cin &gt;&gt; 变量 </code></p>
<p>示例：</p>
<pre><code class="language-C++">int main(){

	//整型输入
	int a = 0;
	cout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl;
	cin &gt;&gt; a;
	cout &lt;&lt; a &lt;&lt; endl;

	//浮点型输入
	double d = 0;
	cout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl;
	cin &gt;&gt; d;
	cout &lt;&lt; d &lt;&lt; endl;

	//字符型输入
	char ch = 0;
	cout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl;
	cin &gt;&gt; ch;
	cout &lt;&lt; ch &lt;&lt; endl;

	//字符串型输入
	string str;
	cout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl;
	cin &gt;&gt; str;
	cout &lt;&lt; str &lt;&lt; endl;

	//布尔类型输入
	bool flag = true;
	cout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl;
	cin &gt;&gt; flag;
	cout &lt;&lt; flag &lt;&lt; endl;
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
}
</code></pre>
<h2 id="3-运算符">3 运算符</h2>
<p><strong>作用：</strong> 用于执行代码的运算</p>
<p>本章我们主要讲解以下几类运算符：</p>
<table>
<thead>
<tr>
<th><strong>运算符类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>算术运算符</td>
<td>用于处理四则运算</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>用于将表达式的值赋给变量</td>
</tr>
<tr>
<td>比较运算符</td>
<td>用于表达式的比较，并返回一个真值或假值</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>用于根据表达式的值返回真值或假值</td>
</tr>
</tbody>
</table>
<h3 id="31-算术运算符">3.1 算术运算符</h3>
<p><strong>作用</strong>：用于处理四则运算</p>
<p>算术运算符包括以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>10 / 5</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr>
<td>++</td>
<td>前置递增</td>
<td>a=2; b=++a;</td>
<td>a=3; b=3;</td>
</tr>
<tr>
<td>++</td>
<td>后置递增</td>
<td>a=2; b=a++;</td>
<td>a=3; b=2;</td>
</tr>
<tr>
<td>--</td>
<td>前置递减</td>
<td>a=2; b=--a;</td>
<td>a=1; b=1;</td>
</tr>
<tr>
<td>--</td>
<td>后置递减</td>
<td>a=2; b=a--;</td>
<td>a=1; b=2;</td>
</tr>
</tbody>
</table>
<p><strong>示例1：</strong></p>
<pre><code class="language-C++">//加减乘除
int main() {

	int a1 = 10;
	int b1 = 3;

	cout &lt;&lt; a1 + b1 &lt;&lt; endl;
	cout &lt;&lt; a1 - b1 &lt;&lt; endl;
	cout &lt;&lt; a1 * b1 &lt;&lt; endl;
	cout &lt;&lt; a1 / b1 &lt;&lt; endl;  //两个整数相除结果依然是整数

	int a2 = 10;
	int b2 = 20;
	cout &lt;&lt; a2 / b2 &lt;&lt; endl; 

	int a3 = 10;
	int b3 = 0;
	//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0	//两个小数可以相除
	double d1 = 0.5;
	double d2 = 0.25;
	cout &lt;&lt; d1 / d2 &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：在除法运算中，除数不能为0<strong>示例2：</strong></p>
</blockquote>
<pre><code class="language-C++">//取模
int main() {

	int a1 = 10;
	int b1 = 3;

	cout &lt;&lt; 10 % 3 &lt;&lt; endl;

	int a2 = 10;
	int b2 = 20;

	cout &lt;&lt; a2 % b2 &lt;&lt; endl;

	int a3 = 10;
	int b3 = 0;

	//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0

	//两个小数不可以取模
	double d1 = 3.14;
	double d2 = 1.1;

	//cout &lt;&lt; d1 % d2 &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<blockquote>
<p>总结：只有整型变量可以进行取模运算<br>
<strong>示例3：</strong></p>
</blockquote>
<pre><code class="language-C++">//递增
int main() {

	//后置递增
	int a = 10;
	a++; //等价于a = a + 1
	cout &lt;&lt; a &lt;&lt; endl; // 11

	//前置递增
	int b = 10;
	++b;
	cout &lt;&lt; b &lt;&lt; endl; // 11

	//区别
	//前置递增先对变量进行++，再计算表达式
	int a2 = 10;
	int b2 = ++a2 * 10;
	cout &lt;&lt; b2 &lt;&lt; endl;

	//后置递增先计算表达式，后对变量进行++
	int a3 = 10;
	int b3 = a3++ * 10;
	cout &lt;&lt; b3 &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<blockquote>
<p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p>
</blockquote>
<h3 id="32-赋值运算符">3.2 赋值运算符</h3>
<p>**作用：**用于将表达式的值赋给变量</p>
<p>赋值运算符包括以下几个符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值</td>
<td>a=2; b=3;</td>
<td>a=2; b=3;</td>
</tr>
<tr>
<td>+=</td>
<td>加等于</td>
<td>a=0; a+=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>-=</td>
<td>减等于</td>
<td>a=5; a-=3;</td>
<td>a=2;</td>
</tr>
<tr>
<td>*=</td>
<td>乘等于</td>
<td>a=2; a*=2;</td>
<td>a=4;</td>
</tr>
<tr>
<td>/=</td>
<td>除等于</td>
<td>a=4; a/=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>%=</td>
<td>模等于</td>
<td>a=3; a%2;</td>
<td>a=1;</td>
</tr>
<tr>
<td><strong>示例：</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-C++">int main() {

	//赋值运算符

	// =
	int a = 10;
	a = 100;
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	// +=
	a = 10;
	a += 2; // a = a + 2;
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	// -=
	a = 10;
	a -= 2; // a = a - 2
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	// *=
	a = 10;
	a *= 2; // a = a * 2
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	// /=
	a = 10;
	a /= 2;  // a = a / 2;
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	// %=
	a = 10;
	a %= 2;  // a = a % 2;
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="33-比较运算符">3.3 比较运算符</h3>
<p><strong>作用：</strong> 用于表达式的比较，并返回一个真值或假值</p>
<p>比较运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>相等于</td>
<td>4 == 3</td>
<td>0</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>4 != 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>4 &lt;= 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>4 &gt;= 1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<pre><code class="language-C++">int main() {

	int a = 10;
	int b = 20;

	cout &lt;&lt; (a == b) &lt;&lt; endl; // 0 

	cout &lt;&lt; (a != b) &lt;&lt; endl; // 1

	cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0

	cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1

	cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0

	cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：C和C++ 语言的比较运算中， <mark>“真”用数字“1”来表示， “假”用数字“0”来表示。</mark></p>
</blockquote>
<h3 id="34-逻辑运算符">3.4 逻辑运算符</h3>
<p>**作用：**用于根据表达式的值返回真值或假值</p>
<p>逻辑运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真；  如果a为真，则!a为假。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>a || b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
</tbody>
</table>
<p>**示例1：**逻辑非</p>
<pre><code class="language-C++">//逻辑运算符  --- 非
int main() {

	int a = 10;

	cout &lt;&lt; !a &lt;&lt; endl; // 0

	cout &lt;&lt; !!a &lt;&lt; endl; // 1

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结： 真变假，假变真<strong>示例2：</strong> 逻辑与</p>
</blockquote>
<pre><code class="language-C++">//逻辑运算符  --- 与
int main() {

	int a = 10;
	int b = 10;

	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 1

	a = 10;
	b = 0;

	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 

	a = 0;
	b = 0;

	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<blockquote>
<p>总结：逻辑<mark>与</mark>运算符总结： <mark>同真为真，其余为假</mark></p>
</blockquote>
<p><strong>示例3：</strong> 逻辑或</p>
<pre><code class="language-c++">//逻辑运算符  --- 或
int main() {

	int a = 10;
	int b = 10;

	cout &lt;&lt; (a || b) &lt;&lt; endl;// 1

	a = 10;
	b = 0;

	cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 

	a = 0;
	b = 0;

	cout &lt;&lt; (a || b) &lt;&lt; endl;// 0

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>逻辑<mark>或</mark>运算符总结： <mark>同假为假，其余为真</mark>## 4 程序流程结构</p>
</blockquote>
<p>C/C++支持最基本的三种程序运行结构：<mark>顺序结构、选择结构、循环结构</mark></p>
<ul>
<li>顺序结构：程序按顺序执行，不发生跳转</li>
<li>选择结构：依据条件是否满足，有选择的执行相应功能</li>
<li>循环结构：依据条件是否满足，循环多次执行某段代码</li>
</ul>
<h3 id="41-选择结构">4.1 选择结构</h3>
<h4 id="411-if语句">4.1.1 if语句</h4>
<p>**作用：**执行满足条件的语句</p>
<p>if语句的三种形式</p>
<ul>
<li>
<p>单行格式if语句</p>
</li>
<li>
<p>多行格式if语句</p>
</li>
<li>
<p>多条件的if语句</p>
</li>
</ul>
<ol>
<li>
<p>单行格式if语句：<code>if(条件){ 条件满足执行的语句 }</code></p>
<figure data-type="image" tabindex="4"><img src="assets/clip_image002.png" alt="" loading="lazy"></figure>
<p>示例：</p>
<pre><code class="language-C++">int main() {

	//选择结构-单行if语句
	//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印

	int score = 0;
	cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl;
	cin &gt;&gt; score;

	cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl;

	//if语句
	//注意事项，在if判断语句后面，不要加分号
	if (score &gt; 600)
	{
		cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：if条件表达式后不要加分号</p>
</blockquote>
</li>
<li>
<p>多行格式if语句：<code>if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };</code><br>
示例：</p>
</li>
</ol>
<pre><code class="language-C++">int main() {

	int score = 0;

	cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;

	cin &gt;&gt; score;

	if (score &gt; 600)
	{
		cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<ol start="3">
<li>多条件的if语句：<br>
<code>if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}</code></li>
</ol>
<figure data-type="image" tabindex="5"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173156.png" alt="" loading="lazy"></figure>
<p>示例：</p>
<pre><code class="language-C++">	int main() {

	int score = 0;

	cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;

	cin &gt;&gt; score;

	if (score &gt; 600)
	{
		cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;
	}
	else if (score &gt; 500)
	{
		cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;
	}
	else if (score &gt; 400)
	{
		cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断<br>
案例需求：</p>
<ul>
<li>提示用户输入一个高考考试分数，根据分数做如下判断</li>
<li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li>
<li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。<br>
<strong>示例：</strong></li>
</ul>
<pre><code class="language-c++">int main() {

	int score = 0;

	cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;

	cin &gt;&gt; score;

	if (score &gt; 600)
	{
		cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;
		if (score &gt; 700)
		{
			cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl;
		}
		else if (score &gt; 650)
		{
			cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl;
		}
		else
		{
			cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl;
		}
		
	}
	else if (score &gt; 500)
	{
		cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;
	}
	else if (score &gt; 400)
	{
		cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>练习案例：</strong> 三只小猪称体重</p>
<p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？<br>
<img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173222.jpeg" alt="" loading="lazy"></p>
<h4 id="412-三目运算符">4.1.2 三目运算符</h4>
<p><strong>作用：</strong> 通过三目运算符实现简单的判断</p>
<p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p>
<p><strong>解释：</strong></p>
<p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p>
<p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	int a = 10;
	int b = 20;
	int c = 0;

	c = a &gt; b ? a : b;
	cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

	//C++中三目运算符返回的是变量,可以继续赋值

	(a &gt; b ? a : b) = 100;

	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p>
</blockquote>
<h4 id="413-switch语句">4.1.3 switch语句</h4>
<p>**作用：**执行多条件分支语句</p>
<p><strong>语法：</strong></p>
<pre><code class="language-C++">switch(表达式)

{

	case 结果1：执行语句;break;

	case 结果2：执行语句;break;

	...

	default:执行语句;break;

}

</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	//请给电影评分 
	//10 ~ 9   经典   
	// 8 ~ 7   非常好
	// 6 ~ 5   一般
	// 5分以下 烂片

	int score = 0;
	cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl;
	cin &gt;&gt; score;

	switch (score)
	{
	case 10:
	case 9:
		cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl;
		break;
	case 8:
		cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl;
		break;
	case 7:
	case 6:
		cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl;
		break;
	default:
		cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl;
		break;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意1：switch语句中表达式类型只能是整型或者字符型</p>
</blockquote>
<blockquote>
<p>注意2：case里如果没有break，那么程序会一直向下执行</p>
</blockquote>
<blockquote>
<p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p>
</blockquote>
<h3 id="42-循环结构">4.2 循环结构</h3>
<h4 id="421-while循环语句">4.2.1 while循环语句</h4>
<p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> while(循环条件){ 循环语句 }</code></p>
<p><strong>解释：</strong><mark>只要循环条件的结果为真，就执行循环语句</mark></p>
<figure data-type="image" tabindex="6"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173258.png" alt="" loading="lazy"></figure>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	int num = 0;
	while (num &lt; 10)
	{
		cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;
		num++;
	}
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环<br>
<strong>while循环练习案例：</strong><mark>猜数字</mark></p>
</blockquote>
<p><strong>案例描述：</strong> 系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。<br>
<img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173338.jpeg" alt="" loading="lazy"></p>
<h4 id="422-dowhile循环语句">4.2.2 do...while循环语句</h4>
<p><strong>作用：</strong>  满足循环条件，执行循环语句</p>
<p><strong>语法：</strong> <code>do{ 循环语句 } while(循环条件);</code></p>
<p>**注意：**与while的区别在于<mark>do...while会先执行一次循环语句</mark>，再判断循环条件</p>
<figure data-type="image" tabindex="7"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173414.png" alt="" loading="lazy"></figure>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	int num = 0;

	do
	{
		cout &lt;&lt; num &lt;&lt; endl;
		num++;

	} while (num &lt; 10);
	
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件</p>
</blockquote>
<p><strong>练习案例：水仙花数</strong></p>
<p>**案例描述：**水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身</p>
<p>例如：1^3 + 5^3+ 3^3 = 153</p>
<p>请利用do...while语句，求出所有3位数中的水仙花数</p>
<h4 id="423-for循环语句">4.2.3 for循环语句</h4>
<p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> for(起始表达式;条件表达式;末尾循环体) { 循环语句; }</code><br>
<strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	for (int i = 0; i &lt; 10; i++)
	{
		cout &lt;&lt; i &lt;&lt; endl;
	}
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>详解：</strong></p>
<figure data-type="image" tabindex="8"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173438.png" alt="" loading="lazy"></figure>
<blockquote>
<p>注意：for循环中的表达式，要用分号进行分隔</p>
</blockquote>
<blockquote>
<p>总结：while , do...while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用<strong>练习案例：敲桌子</strong></p>
</blockquote>
<p>案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p>
<figure data-type="image" tabindex="9"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173453.gif" alt="" loading="lazy"></figure>
<h4 id="424-嵌套循环">4.2.4 嵌套循环</h4>
<p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题</p>
<p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p>
<p><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173519.png" alt="" loading="lazy"><br>
<strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	//外层循环执行1次，内层循环执行1轮
	for (int i = 0; i &lt; 10; i++)
	{
		for (int j = 0; j &lt; 10; j++)
		{
			cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>练习案例：</strong> 乘法口诀表</p>
<p>案例描述：利用嵌套循环，实现九九乘法表</p>
<figure data-type="image" tabindex="10"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173545.jpeg" alt="" loading="lazy"></figure>
<h3 id="43-跳转语句">4.3 跳转语句</h3>
<h4 id="431-break语句">4.3.1 break语句</h4>
<p><strong>作用:</strong> 用于跳出<mark>选择结构</mark>或者<mark>循环结构</mark></p>
<p>break使用的时机：</p>
<ul>
<li>出现在switch条件语句中，作用是终止case并跳出switch</li>
<li>出现在循环语句中，作用是跳出当前的循环语句</li>
<li>出现在嵌套循环中，跳出最近的内层循环语句<br>
<strong>示例1：</strong></li>
</ul>
<pre><code class="language-C++">int main() {
	//1、在switch 语句中使用break
	cout &lt;&lt; &quot;请选择您挑战副本的难度：&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;1、普通&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;2、中等&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;3、困难&quot; &lt;&lt; endl;

	int num = 0;

	cin &gt;&gt; num;

	switch (num)
	{
	case 1:
		cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl;
		break;
	case 2:
		cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl;
		break;
	case 3:
		cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl;
		break;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>示例2：</strong></p>
<pre><code class="language-C++">int main() {
	//2、在循环语句中用break
	for (int i = 0; i &lt; 10; i++)
	{
		if (i == 5)
		{
			break; //跳出循环语句
		}
		cout &lt;&lt; i &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>示例3：</strong></p>
<pre><code class="language-C++">int main() {
	//在嵌套循环语句中使用break，退出内层循环
	for (int i = 0; i &lt; 10; i++)
	{
		for (int j = 0; j &lt; 10; j++)
		{
			if (j == 5)
			{
				break;
			}
			cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
	}
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="432-continue语句">4.3.2 continue语句</h4>
<p>**作用：**在<mark>循环语句</mark>中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	for (int i = 0; i &lt; 100; i++)
	{
		if (i % 2 == 0)
		{
			continue;
		}
		cout &lt;&lt; i &lt;&lt; endl;
	}
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：continue并没有使整个循环终止，而break会跳出循环#### 4.3.3 goto语句</p>
</blockquote>
<p>**作用：**可以无条件跳转语句<br>
<strong>语法：</strong> <code>goto 标记;</code></p>
<p>**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置<br>
<strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;

	goto FLAG;

	cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;3&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;4&quot; &lt;&lt; endl;

	FLAG:

	cout &lt;&lt; &quot;5&quot; &lt;&lt; endl;
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p>
</blockquote>
<h2 id="5-数组">5 数组</h2>
<h3 id="51-概述">5.1 概述</h3>
<p>所谓数组，就是一个集合，里面存放了相同类型的数据元素<br>
<strong>特点1：</strong> 数组中的每个<mark>数据元素都是相同的数据类型</mark></p>
<p><strong>特点2：</strong> 数组是由<mark>连续的内存</mark>位置组成的</p>
<h3 id="52-一维数组">5.2 一维数组</h3>
<h4 id="521-一维数组定义方式">5.2.1 一维数组定义方式</h4>
<p>一维数组定义的三种方式：</p>
<ol>
<li><code>数据类型  数组名[ 数组长度 ];</code></li>
<li><code>数据类型  数组名[ 数组长度 ] = { 值1，值2 ...};</code></li>
<li><code>数据类型  数组名[ ] = { 值1，值2 ...};</code><br>
示例</li>
</ol>
<pre><code class="language-C++">int main() {

	//定义方式1
	//数据类型 数组名[元素个数];
	int score[10];

	//利用下标赋值
	score[0] = 100;
	score[1] = 99;
	score[2] = 85;

	//利用下标输出
	cout &lt;&lt; score[0] &lt;&lt; endl;
	cout &lt;&lt; score[1] &lt;&lt; endl;
	cout &lt;&lt; score[2] &lt;&lt; endl;	//第二种定义方式
	//数据类型 数组名[元素个数] =  {值1，值2 ，值3 ...};
	//如果{}内不足10个数据，剩余数据用0补全
	int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 };
	
	//逐个输出
	//cout &lt;&lt; score2[0] &lt;&lt; endl;
	//cout &lt;&lt; score2[1] &lt;&lt; endl;

	//一个一个输出太麻烦，因此可以利用循环进行输出
	for (int i = 0; i &lt; 10; i++)
	{
		cout &lt;&lt; score2[i] &lt;&lt; endl;
	}

	//定义方式3
	//数据类型 数组名[] =  {值1，值2 ，值3 ...};
	int score3[] = { 100,90,80,70,60,50,40,30,20,10 };

	for (int i = 0; i &lt; 10; i++)
	{
		cout &lt;&lt; score3[i] &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p>
</blockquote>
<blockquote>
<p>总结2：数组中下标是从0开始索引</p>
</blockquote>
<h4 id="522-一维数组数组名">5.2.2 一维数组数组名</h4>
<p>一维数组名称的<strong>用途</strong>：</p>
<ol>
<li>可以统计整个数组在内存中的长度</li>
<li>可以获取数组在内存中的首地址<strong>示例：</strong></li>
</ol>
<pre><code class="language-C++">int main() {

	//数组名用途
	//1、可以获取整个数组占用内存空间大小
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };

	cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;
	cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;
	cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;

	//2、可以通过数组名获取到数组首地址
	cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl;
	cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;
	cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;

	//arr = 100; 错误，数组名是常量，因此不可以赋值	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>注意：数组名是常量，不可以赋值</p>
</blockquote>
<blockquote>
<p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小<strong>练习案例1</strong>：五只小猪称体重</p>
</blockquote>
<p><strong>案例描述：</strong></p>
<p>在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};</p>
<p>找出并打印最重的小猪体重。<br>
**练习案例2：**数组元素逆置</p>
<p>**案例描述：**请声明一个5个元素的数组，并且将元素逆置.</p>
<p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);#### 5.2.3 冒泡排序</p>
<p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li>
<li>重复以上的步骤，每次比较次数-1，直到不需要比较<strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</li>
</ol>
<pre><code class="language-C++">int main() {

	int arr[9] = { 4,2,8,0,5,7,1,3,9 };

	for (int i = 0; i &lt; 9 - 1; i++)
	{
		for (int j = 0; j &lt; 9 - 1 - i; j++)
		{
			if (arr[j] &gt; arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}

	for (int i = 0; i &lt; 9; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; endl;
	}
    
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="53-二维数组">5.3 二维数组</h3>
<p>二维数组就是在一维数组上，多加一个维度。</p>
<figure data-type="image" tabindex="11"><img src="http://img.upy.qiaoyukeji.cn/2023/10/04/20231004173611.png" alt="" loading="lazy"></figure>
<h4 id="531-二维数组定义方式">5.3.1 二维数组定义方式</h4>
<p>二维数组定义的四种方式：</p>
<ol>
<li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};</code></li>
<li><code> 数据类型  数组名[  ][ 列数 ] = { 数据1，数据2，数据3，数据4};</code></li>
</ol>
<blockquote>
<p>建议：以上4种定义方式，利用<mark>第二种更加直观，提高代码的可读性</mark></p>
</blockquote>
<p>示例：</p>
<pre><code class="language-C++">int main() {

	//方式1  
	//数组类型 数组名 [行数][列数]
	int arr[2][3];
	arr[0][0] = 1;
	arr[0][1] = 2;
	arr[0][2] = 3;
	arr[1][0] = 4;
	arr[1][1] = 5;
	arr[1][2] = 6;

	for (int i = 0; i &lt; 2; i++)
	{
		for (int j = 0; j &lt; 3; j++)
		{
			cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
	}

	//方式2 
	//数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } };
	int arr2[2][3] =
	{
		{1,2,3},
		{4,5,6}
	};

	//方式3
	//数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4  };
	int arr3[2][3] = { 1,2,3,4,5,6 }; 

	//方式4 
	//数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4  };
	int arr4[][3] = { 1,2,3,4,5,6 };
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p>
</blockquote>
<h4 id="532-二维数组数组名">5.3.2 二维数组数组名</h4>
<ul>
<li>查看二维数组所占内存空间</li>
<li>获取二维数组首地址<strong>示例：</strong></li>
</ul>
<pre><code class="language-C++">int main() {

	//二维数组数组名
	int arr[2][3] =
	{
		{1,2,3},
		{4,5,6}
	};

	cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;

	cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl;

	//地址
	cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl;

	cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结1：二维数组名就是这个数组的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p>
</blockquote>
<h4 id="533-二维数组应用案例"><strong>5.3.3 二维数组应用案例</strong></h4>
<p><strong>考试成绩统计：</strong></p>
<p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td>100</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>李四</td>
<td>90</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>王五</td>
<td>60</td>
<td>70</td>
<td>80</td>
</tr>
</tbody>
</table>
<pre><code class="language-C++">int main() {

	int scores[3][3] =
	{
		{100,100,100},
		{90,50,100},
		{60,70,80},
	};

	string names[3] = { &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; };

	for (int i = 0; i &lt; 3; i++)
	{
		int sum = 0;
		for (int j = 0; j &lt; 3; j++)
		{
			sum += scores[i][j];
		}
		cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h2 id="6-函数">6 函数</h2>
<h3 id="61-概述">6.1 概述</h3>
<p><strong>作用：</strong> 将一段经常使用的代码封装起来，减少重复代码</p>
<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>
<h3 id="62-函数的定义">6.2 函数的定义</h3>
<p>函数的定义一般主要有5个步骤：</p>
<p>1、返回值类型</p>
<p>2、函数名</p>
<p>3、参数表列</p>
<p>4、函数体语句</p>
<p>5、return 表达式</p>
<p><strong>语法：</strong></p>
<pre><code class="language-C++">返回值类型 函数名 （参数列表）
{

       函数体语句

       return 表达式

}
</code></pre>
<ul>
<li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名称</li>
<li>参数列表：使用该函数时，传入的数据</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据<strong>示例：</strong> 定义一个加法函数，实现两个数相加</li>
</ul>
<pre><code class="language-C++">//函数定义
int add(int num1, int num2)
{
	int sum = num1 + num2;
	return sum;
}
```### 6.3 函数的调用

**功能：** 使用定义好的函数

**语法：**` 函数名（参数）`

**示例：**

```C++
//函数定义
int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参
{
	int sum = num1 + num2;
	return sum;
}

int main() {

	int a = 10;
	int b = 10;
	//调用add函数
	int sum = add(a, b);//调用时的a，b称为实际参数，简称实参
	cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;

	a = 100;
	b = 100;

	sum = add(a, b);
	cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p>
</blockquote>
<h3 id="64-值传递">6.4 值传递</h3>
<ul>
<li>所谓值传递，就是函数调用时实参将数值传入给形参</li>
<li>值传递时，<mark>如果形参发生，并不会影响实参</mark><br>
<strong>示例：</strong></li>
</ul>
<pre><code class="language-C++">void swap(int num1, int num2)
{
	cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;
	cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;

	int temp = num1;
	num1 = num2;
	num2 = temp;

	cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;
	cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;

	//return ; 当函数声明时候，不需要返回值，可以不写return
}

int main() {

	int a = 10;
	int b = 20;

	swap(a, b);

	cout &lt;&lt; &quot;mian中的 a = &quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;mian中的 b = &quot; &lt;&lt; b &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结： 值传递时，形参是修饰不了实参的</p>
</blockquote>
<h3 id="65-函数的常见样式"><strong>6.5 函数的常见样式</strong></h3>
<p>常见的函数样式有4种</p>
<ol>
<li>无参无返</li>
<li>有参无返</li>
<li>无参有返</li>
<li>有参有返</li>
</ol>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//函数常见样式
//1、 无参无返
void test01()
{
	//void a = 10; //无类型不可以创建变量,原因无法分配内存
	cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl;
	//test01(); 函数调用
}

//2、 有参无返
void test02(int a)
{
	cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
}

//3、无参有返
int test03()
{
	cout &lt;&lt; &quot;this is test03 &quot; &lt;&lt; endl;
	return 10;
}

//4、有参有返
int test04(int a, int b)
{
	cout &lt;&lt; &quot;this is test04 &quot; &lt;&lt; endl;
	int sum = a + b;
	return sum;
}
```### 6.6 函数的声明

**作用：** 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

*  函数的**声明可以多次**，但是函数的**定义只能有一次**

**示例：**

```C++
//声明可以多次，定义只能一次
//声明
int max(int a, int b);
int max(int a, int b);
//定义
int max(int a, int b)
{
	return a &gt; b ? a : b;
}

int main() {

	int a = 100;
	int b = 200;

	cout &lt;&lt; max(a, b) &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
```### 6.7 函数的分文件编写

**作用：** 让代码结构更加清晰

函数分文件编写一般有4个步骤

1. 创建后缀名为.h的头文件  
2. 创建后缀名为.cpp的源文件
3. 在头文件中写函数的声明
4. 在源文件中写函数的定义

**示例：**

```C++
//swap.h文件
#include&lt;iostream&gt;
using namespace std;

//实现两个数字交换的函数声明
void swap(int a, int b);

</code></pre>
<pre><code class="language-C++">//swap.cpp文件
#include &quot;swap.h&quot;

void swap(int a, int b)
{
	int temp = a;
	a = b;
	b = temp;

	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
}
</code></pre>
<pre><code class="language-C++">//main函数文件
#include &quot;swap.h&quot;
int main() {

	int a = 100;
	int b = 200;
	swap(a, b);

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<h2 id="7-指针">7 指针</h2>
<h3 id="71-指针的基本概念">7.1 指针的基本概念</h3>
<p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>
<ul>
<li>内存编号是从0开始记录的，一般用十六进制数字表示</li>
<li>可以利用指针变量保存地址</li>
</ul>
<h3 id="72-指针变量的定义和使用">7.2 指针变量的定义和使用</h3>
<p>指针变量定义语法： <code>数据类型 * 变量名；</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	//1、指针的定义
	int a = 10; //定义整型变量a
	
	//指针定义语法： 数据类型 * 变量名 ;
	int * p;

	//指针变量赋值
	p = &amp;a; //指针指向变量a的地址
	cout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址
	cout &lt;&lt; p &lt;&lt; endl;  //打印指针变量p

	//2、指针的使用
	//通过*操作指针变量指向的内存
	cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>指针变量和普通变量的区别</p>
<ul>
<li>普通变量存放的是数据,指针变量存放的是地址</li>
<li>指针变量可以通过&quot; * &quot;操作符，操作指针变量指向的内存空间，这个过程称为解引用</li>
</ul>
<blockquote>
<p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p>
</blockquote>
<blockquote>
<p>总结2：利用指针可以记录地址</p>
</blockquote>
<blockquote>
<p>总结3：对指针变量解引用，可以操作指针指向的内存### 7.3 指针所占内存空间<br>
提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？<br>
<strong>示例：</strong></p>
</blockquote>
<pre><code class="language-C++">int main() {

	int a = 10;

	int * p;
	p = &amp;a; //指针指向数据a的地址

	cout &lt;&lt; *p &lt;&lt; endl; //* 解引用
	cout &lt;&lt; sizeof(p) &lt;&lt; endl;
	cout &lt;&lt; sizeof(char *) &lt;&lt; endl;
	cout &lt;&lt; sizeof(float *) &lt;&lt; endl;
	cout &lt;&lt; sizeof(double *) &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：所有指针类型在32位操作系统下是4个字节### 7.4 空指针和野指针</p>
</blockquote>
<p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p>
<p><strong>用途：</strong> 初始化指针变量</p>
<p><strong>注意：</strong> 空指针指向的内存是不可以访问的<br>
<strong>示例1：空指针</strong></p>
<pre><code class="language-C++">int main() {

	//指针变量p指向内存地址编号为0的空间
	int * p = NULL;

	//访问空指针报错 
	//内存编号0 ~255为系统占用内存，不允许用户访问
	cout &lt;&lt; *p &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>野指针</strong>：指针变量指向非法的内存空间</p>
<p><strong>示例2：野指针</strong></p>
<pre><code class="language-C++">int main() {

	//指针变量p指向内存地址编号为0x1100的空间
	int * p = (int *)0x1100;

	//访问野指针报错 
	cout &lt;&lt; *p &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
```&gt; 总结：空指针和野指针都不是我们申请的空间，因此不要访问。
### 7.5 const修饰指针

const修饰指针有三种情况

1. const修饰指针   --- 常量指针
2. const修饰常量   --- 指针常量
3. const即修饰指针，又修饰常量

**示例：**```c++
int main() {

	int a = 10;
	int b = 10;

	//const修饰的是指针，指针指向可以改，指针指向的值不可以更改
	const int * p1 = &amp;a; 
	p1 = &amp;b; //正确
	//*p1 = 100;  报错
	

	//const修饰的是常量，指针指向不可以改，指针指向的值可以更改
	int * const p2 = &amp;a;
	//p2 = &amp;b; //错误
	*p2 = 100; //正确

    //const既修饰指针又修饰常量
	const int * const p3 = &amp;a;
	//p3 = &amp;b; //错误
	//*p3 = 100; //错误

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>
</blockquote>
<h3 id="76-指针和数组">7.6 指针和数组</h3>
<p><strong>作用：</strong> 利用指针访问数组中元素</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };

	int * p = arr;  //指向数组的指针

	cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl;
	cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl;

	for (int i = 0; i &lt; 10; i++)
	{
		//利用指针遍历数组
		cout &lt;&lt; *p &lt;&lt; endl;
		p++;
	}

	system(&quot;pause&quot;);

	return 0;
}
```### 7.7 指针和函数

**作用：** 利用指针作函数参数，可以修改实参的值
**示例：**

```C++
//值传递
void swap1(int a ,int b)
{
	int temp = a;
	a = b; 
	b = temp;
}
//地址传递
void swap2(int * p1, int *p2)
{
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

int main() {

	int a = 10;
	int b = 20;
	swap1(a, b); // 值传递不会改变实参

	swap2(&amp;a, &amp;b); //地址传递会改变实参

	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>
</blockquote>
<h3 id="78-指针-数组-函数">7.8 指针、数组、函数</h3>
<p><strong>案例描述：</strong> 封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>
<p>例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };<br>
<strong>示例：</strong></p>
<pre><code class="language-c++">//冒泡排序函数
void bubbleSort(int * arr, int len)  //int * arr 也可以写为int arr[]
{
	for (int i = 0; i &lt; len - 1; i++)
	{
		for (int j = 0; j &lt; len - 1 - i; j++)
		{
			if (arr[j] &gt; arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}

//打印数组函数
void printArray(int arr[], int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; endl;
	}
}

int main() {

	int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };
	int len = sizeof(arr) / sizeof(int);

	bubbleSort(arr, len);

	printArray(arr, len);

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>
</blockquote>
<h2 id="8-结构体">8 结构体</h2>
<h3 id="81-结构体基本概念">8.1 结构体基本概念</h3>
<p>结构体属于用户<mark>自定义的数据类型</mark>，允许用户存储不同的数据类型</p>
<h3 id="82-结构体定义和使用">8.2 结构体定义和使用</h3>
<p><strong>语法：</strong><code>struct 结构体名 { 结构体成员列表 }；</code></p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构体名 变量名 = { 成员1值 ， 成员2值...}</li>
<li>定义结构体时顺便创建变量</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
}stu3; //结构体变量创建方式3 int main() {

	//结构体变量创建方式1
	struct student stu1; //struct 关键字可以省略

	stu1.name = &quot;张三&quot;;
	stu1.age = 18;
	stu1.score = 100;
	
	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl;

	//结构体变量创建方式2
	struct student stu2 = { &quot;李四&quot;,19,60 };

	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl;	stu3.name = &quot;王五&quot;;
	stu3.age = 18;
	stu3.score = 80;
	

	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结1：定义结构体时的关键字是struct，不可省略</p>
</blockquote>
<blockquote>
<p>总结2：创建结构体变量时，关键字struct可以省略</p>
</blockquote>
<blockquote>
<p>总结3：结构体变量利用操作符 ''.''  访问成员</p>
</blockquote>
<h3 id="83-结构体数组">8.3 结构体数组</h3>
<p><strong>作用：</strong> 将自定义的结构体放入到数组中方便维护</p>
<p><strong>语法：</strong><code> struct  结构体名 数组名[元素个数] = {  {} , {} , ... {} }</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
}

int main() {
	
	//结构体数组
	struct student arr[3]=
	{
		{&quot;张三&quot;,18,80 },
		{&quot;李四&quot;,19,60 },
		{&quot;王五&quot;,20,70 }
	};

	for (int i = 0; i &lt; 3; i++)
	{
		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl;
	}

	system(&quot;pause&quot;);

	return 0;
}
```### 8.4 结构体指针

**作用：** 通过指针访问结构体中的成员
* 利用操作符 `-&gt; `可以通过结构体指针访问结构体属性
**示例：**

```C++
//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};int main() {
	
	struct student stu = { &quot;张三&quot;,18,100, };
	
	struct student * p = &amp;stu;
	
	p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员

	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl;
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>
</blockquote>
<h3 id="85-结构体嵌套结构体">8.5 结构体嵌套结构体</h3>
<p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p>
<p><strong>例如：</strong> 每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//教师结构体定义
struct teacher
{
    //成员列表
	int id; //职工编号
	string name;  //教师姓名
	int age;   //教师年龄
	struct student stu; //子结构体 学生
};int main() {

	struct teacher t1;
	t1.id = 10000;
	t1.name = &quot;老王&quot;;
	t1.age = 40;

	t1.stu.name = &quot;张三&quot;;
	t1.stu.age = 18;
	t1.stu.score = 100;

	cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl;
	
	cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>总结：</strong> 在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>
<h3 id="86-结构体做函数参数">8.6 结构体做函数参数</h3>
<p><strong>作用：</strong> 将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>地址传递</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//值传递
void printStudent(student stu )
{
	stu.age = 28;
	cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;
}

//地址传递
void printStudent2(student *stu)
{
	stu-&gt;age = 28;
	cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu-&gt;age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;
}

int main() {

	student stu = { &quot;张三&quot;,18,100};
	//值传递
	printStudent(stu);
	cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;

	cout &lt;&lt; endl;

	//地址传递
	printStudent2(&amp;stu);
	cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>
</blockquote>
<h3 id="87-结构体中-const使用场景">8.7 结构体中 const使用场景</h3>
<p><strong>作用：</strong> 用const来防止误操作</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//const使用场景
void printStudent(const student *stu) //加const防止函数体中的误操作
{
	//stu-&gt;age = 100; //操作失败，因为加了const修饰
	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;

}

int main() {

	student stu = { &quot;张三&quot;,18,100 };

	printStudent(&amp;stu);

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="88-结构体案例">8.8 结构体案例</h3>
<h4 id="881-案例1">8.8.1 案例1</h4>
<p><strong>案例描述：</strong></p>
<p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p>
<p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p>
<p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p>
<p>最终打印出老师数据以及老师所带的学生数据。<br>
<strong>示例：</strong></p>
<pre><code class="language-C++">struct Student
{
	string name;
	int score;
};
struct Teacher
{
	string name;
	Student sArray[5];
};

void allocateSpace(Teacher tArray[] , int len)
{
	string tName = &quot;教师&quot;;
	string sName = &quot;学生&quot;;
	string nameSeed = &quot;ABCDE&quot;;
	for (int i = 0; i &lt; len; i++)
	{
		tArray[i].name = tName + nameSeed[i];
		
		for (int j = 0; j &lt; 5; j++)
		{
			tArray[i].sArray[j].name = sName + nameSeed[j];
			tArray[i].sArray[j].score = rand() % 61 + 40;
		}
	}
}

void printTeachers(Teacher tArray[], int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		cout &lt;&lt; tArray[i].name &lt;&lt; endl;
		for (int j = 0; j &lt; 5; j++)
		{
			cout &lt;&lt; &quot;\t姓名：&quot; &lt;&lt; tArray[i].sArray[j].name &lt;&lt; &quot; 分数：&quot; &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;
		}
	}
}

int main() {

	srand((unsigned int)time(NULL)); //随机数种子 头文件 #include &lt;ctime&gt;

	Teacher tArray[3]; //老师数组

	int len = sizeof(tArray) / sizeof(Teacher);

	allocateSpace(tArray, len); //创建数据

	printTeachers(tArray, len); //打印数据
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="882-案例2">8.8.2 案例2</h4>
<p><strong>案例描述：</strong></p>
<p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p>
<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p>
<p>五名英雄信息如下：</p>
<pre><code class="language-C++">		{&quot;刘备&quot;,23,&quot;男&quot;},
		{&quot;关羽&quot;,22,&quot;男&quot;},
		{&quot;张飞&quot;,20,&quot;男&quot;},
		{&quot;赵云&quot;,21,&quot;男&quot;},
		{&quot;貂蝉&quot;,19,&quot;女&quot;},
```**示例：**

```C++
//英雄结构体
struct hero
{
	string name;
	int age;
	string sex;
};
//冒泡排序
void bubbleSort(hero arr[] , int len)
{
	for (int i = 0; i &lt; len - 1; i++)
	{
		for (int j = 0; j &lt; len - 1 - i; j++)
		{
			if (arr[j].age &gt; arr[j + 1].age)
			{
				hero temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}
//打印数组
void printHeros(hero arr[], int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 性别： &quot; &lt;&lt; arr[i].sex &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].age &lt;&lt; endl;
	}
}

int main() {

	struct hero arr[5] =
	{
		{&quot;刘备&quot;,23,&quot;男&quot;},
		{&quot;关羽&quot;,22,&quot;男&quot;},
		{&quot;张飞&quot;,20,&quot;男&quot;},
		{&quot;赵云&quot;,21,&quot;男&quot;},
		{&quot;貂蝉&quot;,19,&quot;女&quot;},
	};

	int len = sizeof(arr) / sizeof(hero); //获取数组元素个数

	bubbleSort(arr, len); //排序

	printHeros(arr, len); //打印

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>