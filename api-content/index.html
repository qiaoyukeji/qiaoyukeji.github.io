{"posts":[{"title":"2025年年度回顾（流水账）","content":"2025年是本人正式工作的第一个整年，在这一年里我经历了很多挫折，也收获了很多见解，真正的从一名学生转变成了一名职场人。 下面是我2025年的一些碎碎念，通过流水账的形式回顾一下2025年的点点滴滴。 2025.01.02：晚上在办公室里加班。 2025.01.07：就软件正版化工作推进不力被省版权局、省国资委联合约谈。 2025.01.08：试用期6个月结束，正式转正，转正评级优秀。 2025.01.10：发年终奖了，但是新员工年终奖就1000多块钱🤣。 2025.01.25：公司开会，布置会场中。 2025.01.28：回家过年了，吃年夜饭。 2025.01.29：年初一，农家舞狮。 2025.2.15：计划买车了，各个4S店看车中。 2025.02.16：看房子中，计划搬出宿舍租房子住，宿舍周边啥也没有，实在是住不下去。 2025.03.01：收到了好朋友给寄的零食，开心😊。 2025.03.02：付款提车了，我也要有自己的小车车了。 2025.03.07：有公司想挖我过去，被我拒绝了。 2025.03.16：庐南川藏线踏青中，外出看看风景，放松一下。 2025.03.21：朋友约酒吧喝酒中。 2025.03.25：公司集体植树中，第一次参加公司外出集体活动。 2025.04.04：清明节巢湖周边转转，踏踏青。 2025.04.13：和朋友一起去万佛湖踏青。 2025.04.20：重回官亭路小吃街，辣哭饼一如既往的辣。 2025.04.22：代表公司参见安徽省委网信办的培训。 2025.05.01：五一大别山去走一圈，放松放松心情。 2025.05.30：我的生日，兄弟们给买的蛋糕。 2025.06.06：师妹毕业了请吃饭。 2025.06.16：探寻朋友的新家。 2025.07.16：参加注册信息安全工程师考试。 2025.07.19：和同事一起去鹞落坪自然保护区避暑。 2025.08.24：和大学好几年没见的同学吃饭、K歌。 2025.08.31：皖南川藏线一日游。 2025.09.11：代表公司参加安徽省正版软件培训班。 2025.09.16：又一发明专利Get。 2025.10.1：国庆节，安吉三日游。 2025.10.18：和朋友们一起吃火锅、逛山姆。 2025.11.06：注册信息安全工程师证书Get。 2025.11.16：独自一人，燕子河大峡谷一日游。 2025.11.25：第一次晚上加班到约10点钟。 2025.11.30：毕业好久了，研究生师兄弟一起聚餐。 2025.12.14：买了一张显卡，5060，算是犒劳一下自己吧。 2025.12.17：参加为期两天的脱产公文写作培训，算是可以歇一下了。 2025.12.21：参加信创高级规划设计师考试中。 2025.12.27：前往上海考试，并和朋友们一起聚一聚。 2025.12.28：在朋友的陪同下参观了上海大学。 2025.12.29：报名参加 RHCE 红帽认证考试。 这就是我的2025流水账式的记录。 他日若遂林云志，敢笑黄巢不丈夫！ 希望接下来的一年里继续努力，争取拿下软考高级等更多证书，同时工作顺兴，家庭美满，加油！ -- 写于 2025年12月30日夜。 ","link":"https://blog.zhawenwen.cn/post/2025/"},{"title":"2024年年度回顾（流水账）","content":"2024年年度回顾（流水账） 时光飞逝，岁月荏苒，转眼之间 2024 年已经过去，2025 年已经到来。 回首已然走过的 2024 年，于我而言，意义非凡。这一年，我告别了熟悉的校园，褪去青涩学生的外衣，成功转型为一名职场新人。从一名学生到一名职场人的转变，对我来说，既是挑战，也是机遇。 本人将2024年分为两个部分，前半年忙着毕业相关事宜，后面年主要忙着自己的工作。本次通过流水账的形式，回顾一下 2024 年的点点滴滴。 第一部分：2024.01-2024.06 2024.01.05：参加信息与人工智能学院成立大会。 2024.01.06：去南京参加地质调查局笔试。 2024.01.17：冬天的实验室楼下。 2024.01.18：农业银行卡被限额，一气之下把卡全注销了。 2024.01.19：去上海参加中国极地研究中心笔试，上海的物价也太高了。 2024.01.20：中国极地研究中心笔试，顺便再逛逛外滩。 2024.01.29：实验室贴春联了。 2024.02.08：家乡的枫树。 2024.02.24：春季开学返校聚餐。 2024.02.25：我的桌面。 2024.03.13：硬件制板完成，测试中。 2024.03.17：实验室同门一起聚餐。 2024.03.18：数据采集设备测试中。 2024.03.20：又来上海了，上海的亲嘴烧居然有糊辣椒风味的。 2024.03.21：中国极地研究中心第二轮面试。 2024.03.28：校园里的桃花开了。 2024.03.29：又来上海了，葱油拌面味道还行。 2024.03.30：参加上海市事业单位联考。 2024.04.04：去万象城看小米SU7。 2024.04.12：南京，I am coming. 2024.04.13：参加江苏中烟工业笔试，顺便去中山陵逛逛。 2024.04.19：又一次来上海了。 2024.04.20：再上海交通大学参加上海消防科学研究所笔试。 2024.04.25：优秀毕业生 GET。 2024.04.26：从南京寄给自己的明信片到了。尽人事，听天命！ 2024.04.27：农耕文化节，我们有自己的展台。 2024.05.02：太累了，宿舍里喝点啤酒放松一下。 2024.05.06；论文盲审意见出来了，一个B，一个C。还行吧，算是过了。 2024.05.11：和往届师兄一起夜爬大蜀山。 2024.05.13：参加工商银行安徽省合肥分行科技精英岗面试。 2024.05.18：参加安徽机场集团笔试。 2024.05.19：时隔四年，又来蚌埠了。 2024.05.20：参加淮河水利委员会面试，并重回蚌埠学院。 2024.05.24：中央网信办-国家计算机网络应急中心差额入职体检。 2024.05.25：硕士毕业答辩结束，顺利通过了。 2024.05.26：实验室同门聚餐吃饭。 2024.05.28：国家能源集团安庆神皖能源面试。 2024.05.31：又一次来上海了，参加上海审计局审计科学研究所资格审查。 2024.06.01：参加上海审计局审计科学研究所面试。 2024.06.05：拍毕业照中。 2024.06.05：参加安徽省建筑设计研究总院面试。 2024.06.06：参加XX集团面试。 2024.06.10：端午节朋友一起吃饭。 2024.06.15：又来上海了。 2024.06.16：参加上海市大数据中心笔试。 2024.06.18：清理毕业物品，回老家了。 2024.06.25：又来合肥了。 2024.06.27：参加入职体检。 2024.06.28：来杭州了，坐的高铁低人一等坐。 2024.06.29：参加浙江交通职业技术学院笔试，然后和朋友游览西湖与雷峰塔。 第二部分：2024.07-2024.12 2024.07.03： 放松放松心情，独自游长江安庆段大堤。 2024.07.04：给老家我的房间安装空调。 2024.07.08：入职公司了。 2024.07.09：安排办公室了，空空的桌子，啥也没配。 2024.07.16：换办公室了。 2024.07.17：公司发劳保用品，我也蹭了一份。 2024.07.23：上班窗外环境随拍。 2024.07.25：发放第一笔工资了。 2024.08.04：牛马生病了，急性肠胃炎，发烧40度。 2024.08.12：参加新员工培训了，为期一周时间。 2024.08.14：参观公司消防站。 2024.09.09：打工人电脑坏了，CPU频率锁0.4Ghz了。 2024.09.14：准备一个小型会议。 2024.09.18：合肥发生地震了，有震感。 2024.09.23：公司发月饼了，但是是美诚月饼。 2024.09.29：成功举办一场集团层面大型工作会议。 2024.10.02：和小伙伴一起游泰山。 2024.10.03：和小伙伴一起游徐州。 2024.10.12：公司领导安排前往一线学习工作3个月。 2024.10.15：一线工作学习中。 2024.10.23：一线工作学习中。 2024.11.09：参加软考高级考试。 2024.11.16：和室友一起去金寨县马鬃岭两日游。 2024.11.17：在霍山县迎驾集团打酒5斤。 2024.11.22：朋友同事请喝酒，12点的三里庵。 2024.11.23：独自游安徽省博物馆。 2024.12.15：和朋友一起吃饭。 2024.12.18：被车撞了... 2024.12.19：加班到凌晨4点。 2024.12.20：参加职工拔河比赛，队伍拿到第四名。 2024.12.22：CCF中国计算机学会赠送礼物。 2024.12.27：修理大屏。 2024.12.27：前期帮忙，同事请喝酒。 2024.12.30：检修引导系统。 2024.12.31：和同事以及室友前往骆岗公园吃饭跨年。 他时若遂凌云志，敢笑黄巢不丈夫! 希望在接下来的一年里能继续努力，不断进步。 -- 写于2025年1月2日夜 ","link":"https://blog.zhawenwen.cn/post/2024/"},{"title":"博客网站运行 1100 天记录","content":" 本博客自 2021年9月6日我即将进入研究生阶段学习前夕建立，建立的初衷是记录我的日常的学习与生活。 截止到2024年9月10日，博客网站已正常运行 1100 天，本博客贯穿了我的整个研究生生涯，记录了我的研究生学习期间的种种内容。 说真的，在最开始的时候，我真的从未曾想象过我的博客能够持续运行这么长的时间，我居然能够坚持整整 3 年不断地在博客中撰写各类内容。这其中的坚持与付出，现在回想起来都觉得有些不可思议。而且，我的博客在全平台的阅读量竟然也超过了 50 万，它意味着我的文字和经历在一定程度上得到了大家的关注与认可。 在研究生期间，因为大部分时间都沉浸在学习与研究之中，而我本身对新鲜事物又有着浓厚的兴趣。每当遇到那些新奇的领域或者独特的观点时，我总会不由自主地深入其中进行探索与研究。得益于研究生相对灵活的时间安排，我有足够的时间将这些研究成果整理归纳，最终形成一篇篇有价值的博客文章。 如今，我已经顺利地从研究生毕业，正式进入了企业开始上班。然而，企业的工作模式和校园有着很大的不同。在这里，一切都显得比较按部就班，很少有新奇的事物出现，也不需要我像在学校那样去深入地研究与探索。或许正是因为这样相对平淡的工作环境，导致我在近期都没有再撰写新的博客。 但我始终认为，撰写博客是一件极具意义的事情，尤其是撰写技术博客。它就像是把我们所学的知识，通过文字、图片等生动形象的方式记录下来，最终形成一篇完整的、具有可复现性的文档。在这个撰写的过程中，我们其实是在对相关的技术进行一次深入的复习与巩固。而当我们完成博客之后，它不仅可以为其他有需要的人提供宝贵的参考资料，同时也可以当作我们自己的一份独特的学习笔记，在未来的日子里随时翻阅。 我会继续保持积极的学习姿态，不断地学习新的知识与技能。并且，我会将这些学习成果认真地整理、汇总，然后将它们以博客内容的形式分享给每一位关注我的朋友。让我们一起在知识的海洋中遨游，共同进步！ 最后，与大家共勉！ 写于 2024年9月10日，巧遇！ ","link":"https://blog.zhawenwen.cn/post/run_1100_day/"},{"title":"24届毕业季——我的找工作之旅纪实","content":" 1. 个人介绍 本人是2021年9月入学、2024年6月毕业的一名计算机科学与技术专业硕士研究生，就读于省会城市的一所一本院校。 本人在2023年9月开始陆续投递简历，之后进入了投简历、笔试、面试的无限循环之中，本文是我找工作以来的一些记录。 2. 找工作流水记录 下面是本人从秋招到春招以来笔试和面试的公司（不完全），部分企业公司笔面试时间相同冲突时只选择其中一个参加。 部分保密单位笔、面试未列出。 2023年8月13日，兆易创新，嵌入式软件工程师，笔试。 2023年8月17日，基恩士，技术工程师，一面。 2023年8月19日，京东集团，前端开发工程师，笔试。 2023年9月2日，小米，软件开发（JS），笔试。 2023年9月3日，微众银行，网络技术，笔试。 2023年9月14日，锐捷网络，嵌入式开发，笔试。 2023年9月16日，58同城，前端开发，笔试。 2023年9月21日，同程旅行，前端开发，笔试。 2023年10月10日，中信银行，信息科技，全球统一笔试（第一批）。 2023年10月14日，上海银行，信息科技，笔试。 2024年10月14日，小米，嵌入式开发，笔试。 2023年10月15日，咪咕文化，软件工程师，笔试。 2023年10月19号，民生银行上海分行，信息科技，笔试。 2023年10月31日，太平洋寿险，信息科技（前端方向），笔试。 2023年11月3日，阅文集团，前端开发，笔试。 2023年11月6日，民生银行上海分行，首轮线上面试。 2023年11月15日，保利集团校园招聘开放日，中奖，J20模型。 2023年12月3日，国家电网安徽，计算机类，笔试。 2023年12月9日，南方电网，信息通信类，统一线下笔试。 2023年12月9日，国家电网安徽，计算机类，面试。 2023年12月9日，教育部直属事业单位，笔试。 2023年12月25日，南方电网超高压，计算机类，面试。 2024年1月12日，南方电网广东，计算机类，面试。 2024年2月27日，中国建筑集团，信息类，统一笔试。 2024年3月6日，美团，前端开发，笔试。 2024年3月8日，携程，SRE工程师，笔试。 2024年3月12日，湖北中烟，信息类，笔试。 2024年3月14日，金山WPS，前端开发，笔试。 2024年3月15日，CVTE，嵌入式开发，笔试。 2024年3月23日，中国银行，信息科技类，线下统一笔试。 2024年3月20日，中国极地研究中心，电子工程师，二面。 2024年3月20日，小米，SER工程师，面试。 2024年3月24日，TCL实业，笔试。 2024年3月30日，上海市事业单位联考，笔试。 2024年4月2日，安徽江淮汽车，软件系统岗，面试。 2024年4月3日，小米，前端开发，面试。 2024年4月10日，华夏银行，信息科技类，笔试。 2024年4月11日，国家计算机********中心，网络安全，笔试。 2024年4月15日，江苏交控，信息科技类，笔试。 2024年4月20日，浙江中烟，信息科技类，笔试。 2024年4月21日，中国工商银行，信息科技类，笔试。 2024年4月21日，应急管理部上海消防研究所，信息科技类，笔试。 2024年4月24日，三峡集团上海勘测设计研究院，信息科技类，面谈。 2024年4月25日，山东黄金集团，信息科技类，笔试。 2024年4月26日，民生银行上海分行，信息科技类，笔试。 2024年4月30日，水利部淮委通信总站，信息岗，笔试。 2024年5月7日，广东广电，信息岗，笔试。 2024年5月8日，中国工商银行软件开发中心（上海），信息科技类，面试。 2024年5月12日，国家能源集团，信息科技类，笔试。 2024年5月13日，中国工商银行合肥分行，科技精英，面试。 2024年5月16日，民生银行上海分行，信息科技类，面试。 2024年5月14日，山东黄金集团山金期货，信息类，面试意向。 2024年5月14日，国家计算机********中心，网络安全，专业加试。 2024年5月14日，国家计算机********中心，网络安全，面试。 2024年5月18日，水利部淮委通信总站，信息岗，面试。 2024年5月28日，国家能源集团，计算机岗，面试。 2024年5月31日，上海审计科学研究所，计算机岗，面试。 2024年6月4日，广铁集团，软件开发岗，笔试。 2024年6月5日，安徽省交规院，信息岗，面试。 2024年6月14日，上海华讯网络，云计算工程师，笔试。 2024年6月14日，上海大数据中心，区块链工程师，笔试。 2024年6月18日，上海华讯网络，云计算工程师，面试 2024年6月27日，上海电机学院，图书馆档案管理，笔试。 2024年6月30日，安徽工程大学，计算机学院教师，笔试。 2024年6月30日，浙江交院，数字化建设工程师，笔试。 3. 总结 在这段被冠以“史上最艰难就业”之名的毕业季里（或许 25 届会更艰难🤣），本人参加了众多公司的笔试，也历经了诸多公司的面试，然而一直处于陪跑状态。不少单位面试都是5进1、3进1，单位最终都选择了 985、211 院校的学生，本人学校于此方面不具优势。在这些面试经历中，我深切地感受到就业的沉重压力，此压力自上而下影响着每一个人。 毕业离校之际，本人手中空无一 Offer，目睹身边同学相继收获喜讯，那份焦虑与不安难以言表。最终，在毕业离校 20 多天后，一个省属国企向我伸出了橄榄枝，本人总算拿到了一个 Offer。有了 Offer 在手，内心压力顿时减轻不少，求职之路也暂告一段落。 回顾这段求职之旅，我心存感激；在求职之路上，众多师兄、同门、同学及朋友们无私的援助与鼓励，为我提供了莫大的支持，在此深表感激！但在这漫长的求职期间，本人也留下诸多遗憾，在此也就不展开了。 最后，衷心希望每个人都能收获理想的 Offer。 ———— 写于2024年7月5日。 附一个工作投递的记录（部分）： ","link":"https://blog.zhawenwen.cn/post/find_jobs_in_2024/"},{"title":"什么是 websocket？—— websocket 使用与简介","content":"1. 什么是 websocket 1.1 什么是 websocket WebSocket是一种在单个 TCP 连接上进行全双工通信的协议。 WebSocket 使得浏览器（客户端）和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。 1.2 websocket 与 http 的区别 常规的 http 协议的网站与应用中，一般都是浏览器（客户端）主动发送请求到服务端获取数据，服务端无法主动推送数据到浏览器（客户端）。 服务端想要发送数据到浏览器（客户端），都是使用http轮询的方式实现，即浏览器（客户端）主动发送请求到服务端，服务端将数据返回浏览器（客户端）中。 http轮询模式有很大的缺点，需要浏览器（客户端）一直向服务端发送请求，以获取服务器中的最新数据到浏览器（客户端）中，当服务器数据又不一定一直变化，这就造成了很多的浏览器（客户端）发送的请求是无效请求，造成了资源的严重浪费。 Websocket 协议和 HTTP 协议主要有以下区别： 连接方式 HTTP 协议：基于请求-响应模式，客户端发起请求，服务器响应。每次请求和响应都需要建立和关闭连接。 Websocket 协议：建立一次连接后，保持连接状态，允许双向通信，无需频繁建立和关闭连接。 数据传输方向 HTTP 协议：通常是客户端向服务器发送请求，服务器返回响应，数据传输方向主要是客户端到服务器。 Websocket 协议：支持服务器主动向客户端推送数据，实现双向实时通信。 开销 HTTP 协议：每次请求和响应都包含较多的头部信息，造成一定的开销。 Websocket 协议：建立连接后的通信开销相对较小。 实时性 HTTP 协议：不太适合实时数据的传输，实时性相对较差。 Websocket 协议：能够实现实时的数据交互，实时性强。 应用场景 HTTP 协议：适用于大多数一般性的网页浏览、数据获取等。 Websocket 协议：常用于在线聊天、实时游戏、金融行情实时推送等需要实时交互的场景。 2. 为什么需要 websocket 为了解决使用 http 协议的浏览器（客户端）无法快速获取服务器端的数据，websocket 就被发明了出来。 websocket 协议有如下优点： 双向通信：允许服务器主动向客户端推送数据，实现实时交互，无需客户端频繁请求。 低延迟：建立连接后，数据传输的延迟相对较低，能够快速响应。 更少的开销：相比传统的 HTTP 请求-响应模式，减少了连接建立和关闭的开销。 高效的数据传输：可以发送二进制数据，提高了数据传输的效率。 保持连接：连接一旦建立，除非出现异常，否则会一直保持，节省了重新建立连接的时间和资源。 实时性强：适用于需要实时更新数据的应用，如在线游戏、实时监控等。 3. websocket 如何使用 websocket 具体使用需要客户端与服务器端的双重支持。 3.1 websocket 服务器端代码是使用 // 引入 websocket 库；可以使用 npm install ws 安装库 const WebSocket = require('ws'); // 创建一个 WebSocket 服务器，并监听 8080 端口 const wss = new WebSocket.Server({ port: 8080 }); // 当有客户端连接成功时触发此事件 wss.on('connection', (ws) =&gt; { // 当接收到客户端发送的消息时触发此事件 ws.on('message', (message) =&gt; { // 打印接收到的消息 console.log(`Received: ${message}`); // 向客户端发送一条消息 ws.send(`You sent: ${message} , 这是一个服务器返回的消息`); }); // 向刚连接的客户端发送一条欢迎消息 ws.send('Welcome to the WebSocket server!'); }); 在目录里新建一个名为 app.js 的文件，将上述代码拷贝进去保存；之后在当前目录中打开终端，在终端中输入 node app.js 即可运行一个 websocket 测试版服务端。 3.2 浏览器（客户端）代码与使用 3.2.1 浏览器端使用一 浏览器端可以使用第三方网站来测试与 3.1 中的 websocket 服务器端是否通联成功。 测试网址为：http://www.websocket-test.com/ 打开网址后在左上角输入 websocket 服务端地址与端口号，示例为：ws://127.0.0.1:8080 之后即可发送内容测试。 3.2.2 浏览器使用二 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;WebSocket Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;WebSocket 测试&lt;/h2&gt; &lt;div id=&quot;message&quot;&gt;&lt;/div&gt; &lt;script&gt; // 创建 WebSocket 连接 var socket = new WebSocket(&quot;ws://localhost:8080&quot;); // 连接打开时触发 socket.onopen = function (event) { var p = document.createElement('p'); p.textContent = '连接已打开'; document.getElementById('message').appendChild(p); socket.send('Hello, WebSocket!'); }; // 接收到消息时触发 socket.onmessage = function (event) { var p = document.createElement('p'); p.textContent = '收到消息: '+ event.data; document.getElementById('message').appendChild(p); }; // 连接关闭时触发 socket.onclose = function (event) { var p = document.createElement('p'); p.textContent = '连接已关闭'; document.getElementById('message').appendChild(p); }; // 发生错误时触发 socket.onerror = function (error) { var p = document.createElement('p'); p.textContent = '错误: '+ error.message; document.getElementById('message').appendChild(p); }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在目录中新建一个文件 index.html ,将上述代码复制到 index.html 中，然后使用浏览器打开该文件。 4. 总结 本文档是本人学习使用 websocket 的一点记录，文中的代码片段仅为最基础的测试代码，仅用于测试 websocket 双向通联是否成功。 写于：2024.07.01 参考文档： https://zhuanlan.zhihu.com/p/690282564 https://www.cnblogs.com/chyingp/p/websocket-deep-in.html https://www.runoob.com/html/html5-websocket.html http://www.websocket-test.com/ https://www.doubao.com/ ","link":"https://blog.zhawenwen.cn/post/what_is_websocket/"},{"title":"构建NPS内网穿透服务客户端GUI界面","content":"本教程使用 PySimpleGUI 绘制内网穿透服务客户端 GUI页面，使用 pyinstaller 打包构建出 exe 程序，适用于windows 操作系统 1、问题来源 2、操作教程 2.1 原理 2.2 NPS_GUI界面代码 2.3 python 程序转 exe 程序 3、总结 1、问题来源 本人之前撰写过一个 使用nps搭建内网穿透并配置泛域名解析的教程，但其中的运行客户端程序使用的是 CMD 命令行进行操作，并且需要配置的参数较多，总是记不住。 所以就在考虑是否能将 cmd 命令程序转成 EXE GUI程序，方便配置参数运行。本教程就营运而生了。 2、操作教程 2.1 原理 PySimpleGUI是一个用于创建图形用户界面（GUI）的Python模块。本教程使用 PySimpleGUI 为 NPS内网穿透客户端程序(v0.26.0)制作了一个GUI界面。 2.2 NPS_GUI界面代码 首先新建一个目录为 nps_gui ，在目录中新建一个 main.py 程序，并将与 nps 服务端配套的 npc.exe 文件复制到该目录下。 main.py 程序为主程序，用来绘制 GUI 界面，调用 CMD 命令运行程序。 main.py 程序内容如下： # main.py import subprocess import threading import PySimpleGUI as sg # 定义版本号和作者信息 version = &quot;0.0.1&quot; author = &quot;巧遇科技工作室&quot; about_me = &quot;本程序是NPS内网穿透服务的GUI界面，用来辅助NPS内网穿透服务客户端进行使用，与之配套的NPS版本为0.26.10。&quot; def read_output(process, output_element): &quot;&quot;&quot; 读取子进程的输出并将其传递给GUI线程显示的函数 &quot;&quot;&quot; for line in process.stdout: output_element.print(line.strip()) for line in process.stderr: output_element.print(line.strip()) # 定义GUI布局 layout = [ [sg.Menu([['关于', ['本程序介绍','版本号', '作者']]])], [sg.Text(&quot;服务端地址(IP):&quot;), sg.Input(default_text=&quot;nps.qiaoyukeji.cn&quot;,key=&quot;-ADDRESS-&quot;)], [sg.Text(&quot;服务端端口号:&quot;), sg.Input(default_text=&quot;28024&quot;,key=&quot;-PORT-&quot;)], [sg.Text(&quot;验证密钥(vkey):&quot;), sg.Input(key=&quot;-VKEY-&quot;)], [sg.Text(&quot;连接方式:&quot;), sg.Input(default_text=&quot;tcp&quot;,key=&quot;-TYPE-&quot;)], [sg.Button(&quot;连接远程穿透服务器&quot;), sg.Button(&quot;退出&quot;)], [sg.Output(size=(60, 10), key=&quot;-OUTPUT-&quot;)] ] # 创建窗口 window = sg.Window(&quot;NPS内网穿透GUI工具（v0.0.1）&quot;, layout) output_element = window[&quot;-OUTPUT-&quot;] # 事件循环 while True: event, values = window.read() if event == sg.WINDOW_CLOSED or event == &quot;退出&quot;: break if event == &quot;连接远程穿透服务器&quot;: address = values[&quot;-ADDRESS-&quot;] port = values[&quot;-PORT-&quot;] vkey = values[&quot;-VKEY-&quot;] type = values[&quot;-TYPE-&quot;] command = f&quot;npc.exe -server={address}:{port} -vkey={vkey} -type={type}&quot; startupinfo = subprocess.STARTUPINFO() startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW process = subprocess.Popen( command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1, startupinfo=startupinfo, creationflags=subprocess.CREATE_NO_WINDOW ) # 创建线程读取子进程输出并传递给GUI线程显示 output_thread = threading.Thread(target=read_output, args=(process, output_element), daemon=True) output_thread.start() if event == &quot;版本号&quot;: sg.popup(f&quot;版本号: {version}&quot;) if event == &quot;作者&quot;: sg.popup(f&quot;作者: {author}&quot;) if event == &quot;本程序介绍&quot;: sg.popup(f&quot;{about_me}&quot;) # 关闭窗口 window.close() 目录下输入 python main.py 运行程序，程序的运行图如下所示。 填写好自己的 nps 服务端的 网址(IP)、端口、验证密钥(vkey)与连接方式，点击连接显示连接成功。 至此，python 代码版的 nps 客户端 GUI 程序已完成。 2.3 python 程序转 exe 程序 python 版的程序虽然已经完成，但是需要电脑先安装 python 运行环境，并且安装对应的 python 库，之后运行 python 代码才能正真的运行起来程序，对于普通人来说过于麻烦与繁琐了。 能不能打包成 exe 文件，无需安装，双击就能运行呢？ 答案是肯定的，就是使用 pyinstaller 。 PyInstaller 是一个用于将 Python 应用程序打包成可执行文件的工具。它可以将 Python 脚本及其依赖的库、资源文件等打包成一个独立的可执行文件，方便在没有 Python 解释器的环境中运行。 首先安装使用 pip install pyinstaller 安装 pyinstaller ； 之后在上面的目录中运行 PyInstaller 打包程序； pyinstaller --onefile --hidden-import PySimpleGUI main.py --name &quot;NPS内网穿透客户端GUI程序&quot; --noconsole --onefile：指定生成一个单个的可执行文件，而不是生成一个文件夹包含多个文件。这意味着所有的依赖项将被打包到一个可执行文件中。 --hidden-import PySimpleGUI：指定需要导入的额外模块或库。在这个例子中，指定了需要导入PySimpleGUI库，因为脚本&quot;main.py&quot;中使用了PySimpleGUI。这样PyInstaller会确保将该库包含在生成的可执行文件中。 main.py：要打包的Python脚本的文件名或路径。在这个例子中，指定了&quot;main.py&quot;作为要打包的脚本。 --name &quot;NPS内网穿透客户端GUI程序&quot;：指定生成的可执行文件的名称。在这个例子中，指定了生成的可执行文件的名称为&quot;NPS内网穿透客户端GUI程序&quot;。 --noconsole：指定生成的可执行文件在运行时不显示控制台窗口。这适用于图形用户界面（GUI）应用程序，因为它们通常不需要显示控制台输出。 上述打包程序就可以在目录下生成一个 dist 目录、将 main.py 打包成一个 exe 程序放置在 dist 目录中，然后我们需要将 npc.exe 也复制一份到 dist 目录中。 在 dist 目录中双击 NPS内网穿透客户端GUI程序.exe 即可正常运行 NPS_GUI 程序。 我们可以将 NPS内网穿透客户端GUI程序.exe 与 npc.exe 两个文件打包成一个压缩包发送给他人，他人无需安装配置运行环境、仅需解压缩后双击程序即可运行程序。 至此 nps 客户端程序 GUI 界面程序已全部完成。 3、总结 本教程已在 Gitee、Github中进行开源。 Gitee：https://gitee.com/qiaoyukeji/nps_gui Github：https://github.com/qiaoyukeji/nps_gui 本教程使用的是 PySimpleGUI 绘制 GUI 界面，由于 PySimpleGUI 库本身的问题，第一次使用会提示填入授权码或者选择忽略跳过。 授权码 PySimpleGUI 官方免费提供，但需要注册领取，填入注册授权码后可一直免费使用。 选择忽略将导致 PySimpleGUI 绘制的程序将只能试用31天，注册填入授权码即可解决 ","link":"https://blog.zhawenwen.cn/post/nps_gui/"},{"title":"nanopc-T4硬件连接与数据采集上传物联网平台交接文档（内部交接使用）","content":"本文档为实验室内部交接文档，无其他含义 nanopc-T4硬件连接与数据采集上传 内容：硬件交接（nanopc-T4） 时间：2024.04.01 一、nanopc-T4硬件连接 需要硬件：nanopc-T4、罗技C920摄像头、氨气传感器、四合一传感器等、RS485 二、nanopc-T4运行软件 2.1 使用SSH协议连接nanopc-T4 将 nanopc-T4 与电脑连接到同一个网段（路由器）中，在电脑中安装 xshell 软件连接到 nanopc-T4。 普通账号密码：pi，pi root账号密码：root，fa 2.2 获取运行程序并修改设备ID 在nanopc-T4 中下载需要运行的程序，通过 Git 获取运行程序，https://gitee.com/qiaoyukeji/nanopc2jetlinks4mqtt， 所有要运行的具体内容都在程序的 test_008_mqttControl 目录中，修改运行程序中的设备 ID 2.3 设置程序的自动启动与nanopc-T4的自动重启 设置程序的自启动等方法在 test_008_mqttControl 中的 readme.md 中 三、物联网平台相关操作 平台网址：http://aau.aau506.cn 账号密码： 3.1 新建设备 按前期标准设置 id 号 3.2 设置连接密钥并配置物模型 设置好连接的账号密码、并配置好属性定义物模型与功能定义物模型 四、视频实时采集 4.1 腾讯云直播（仅需第一次修改） 添加推流域名，领取免费的20G测试流量 4.2 域名解析（仅需第一次修改） 4.3 nanopc-T4端运行 运行程序在 test_009_onlyFFmpeg 目录中 4.4 可视化展示端修改程序展示（仅需第一次修改） 修改 大数据可视化界面的 play.js 平台网址：http://1.117.229.138:8888/qiaoyu 账号密码： ","link":"https://blog.zhawenwen.cn/post/inside_001/"},{"title":"2023年年度总结回顾（流水账）","content":"2023年是难忘的一年，前半年主要在改小论文、写程序、调试开发板；后半年主要找工作、准备考试等，时间过的非常的匆忙，以至于比以前少了很多的乐趣，本次将 2023 年的一些我的日常活动做个流水账总结，自我勉励。 待到秋来九月八，我花开后百花杀。冲天香阵透长安，满城尽带黄金甲。 一、 年度数据总结 博客文章： 2023年，本人共撰写博客教程 17 篇，分别发布在本人博客、CSDN、知乎、掘金等平台上；个人博客浏览量 14562，CSDN 浏览量 16217，知乎浏览量 3.7 万，掘金浏览量 5624 ，总浏览量（不完全统计）7.5万，总收藏量 300+ 。 Github&amp;Gitee： 2023年，本人在 Github/Gitee 平台开源项目 4个，提交代码 100+ 次，收获 Star 14 个，fork 2 次。 二、年度流水账 由于2022年年底众所周知的原因，学校提前放假，我也早早的回家了。 2023年1月1日，老家，干枯的池塘。 2023年1月15日，老家，下雪了。 2023年1月19日，老家，年前一起炸糯米圆子。 2023年1月30日，独秀山一日游 + 家乡池塘网鱼。 2023年2月11日，开学了，实验室一起吃火锅。 2023年2月18，在学校，已毕业的师兄组局请吃饭。 2023年2月20日~2023年2月22日，实验室一起出差去合作的养殖基地。 2023年3月4日，实验室小伙伴们一起植物园一日游。 2023年3月11日，和小伙伴们一起牛蛙铜火锅搞起。 2023年3月13日~2023年3月14日，第二次出差去养殖基地安装设备。 2023年3月30日，去医院拔牙齿，拔完最后一颗歪的智齿，吃了一周流食。 2023年4月7日，由于元旦提前放假了，没有一起吃饭，老师补请吃饭。 2023年4月9日，实验室一行十多人出发去往巢湖姆山岛一日游。 2023年5月20日，研一开题结束，实验室一行去火锅撸串。 2023年5月27日，在实验室看恐怖片。 2023年6月2日，无线电台执照 GET。 2023年6月4日，实验室毕业答辩通过聚餐。 2023年6月17日，师兄们毕业请吃饭。 2023年7月1日，杏花公园相亲角。 2023年7月、8月、9月、10月部分数据丢失。 2023年11月22日，工作没找到，却收到了智联招聘邮寄的 J20 模型。 2023年11月26日，参加 2024年国家公务员考试，考试内容非常难，试卷都没有写完；考试地点也非常远，连车都打不到。 2023年12月3日，参加国家电网校园招聘统一考试。 2023年12月9日，参加南方电网校园招聘统一考试。 2023年12月16日，考完四六级小伙伴们一起吃火锅。 2023年12月18日，下大雪了。 2023年12月31日，跨年夜吃饭等了好久，有两个多小时，庐州太太给打了 8.5 折。 2023年下半年非常之忙，一边投简历找工作、一边准备各项考试。投简历投了大概 100+ 家，收到笔试没多少，面试更是寥寥无几，工作难找呀。 希望 2024 年找工作能够顺风顺水，论文写作也能够一帆风顺。 他日若遂凌云志，敢笑黄巢不丈夫。 ","link":"https://blog.zhawenwen.cn/post/2023/"},{"title":"Rust编程入门——第三章_通用编程概念","content":"一门赋予每个人构建可靠且高效软件能力的语言。 第三章 通用编程概念 变量与可变性 数据类型 标量类型 符合类型 函数 注释 控制流 3.1 变量与可变性 3.1.1 变量 申明变量使用 let 关键字 默认情况下，变量是不可变的（immutable） fn main() { println!(&quot;Hello, world!&quot;); let x: i32=5; println!(&quot;the value of x is {}&quot;,x); } 申明变量时，在变量前面加上 mut，就可以使变量可变 fn main() { println!(&quot;Hello, world!&quot;); let mut x: i32=5; x=8; println!(&quot;the value of x is {}&quot;,x); } 3.1.2 常量 常量（constant），常量在绑定值以后是不可变的，但是让他与不可变的变量有很多区别： 不可以使用 mut ，常量永远都是不可变的 申明常量使用 const 关键字，它的类型必须被标注 常量可以在任何作用域内申明，包括全局作用域 常量只能绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算的值 在程序运行期间，常量在其申明的作用域内一直有效 命名规范：Rust 里常量使用全大写字母，每个单词之间用下划线分开，例如： MAX_POINTS const MAX_POINTS:u32 = 100_000; const MAX_POINTS:u32 = 100_000; fn main() { println!(&quot;Hello, world!&quot;); println!(&quot;the number is {}&quot;,MAX_POINTS) } 3.1.3 Shadowing（隐藏） 可以使用相同的名字申明新的变量，新的变量就会 Shadow（隐藏）之前申明的同名变量 在后续的代码中这个变量名代表的就是新的变量 const MAX_POINTS:u32 = 100_000; fn main() { println!(&quot;Hello, world!&quot;); println!(&quot;the number is {}&quot;,MAX_POINTS) } Shadow 和把变量标记为 mut 是不一样的： 如果不使用 let 关键字，那么重新给非 mut 的变量赋值会导致编译错误 而使用 let 申明的同名新变量，也是不可变的 使用 let 申明的同名新变量，他的类型可以与之前不同 fn main() { let spaces = &quot; &quot;; let spaces=spaces.len(); println!(&quot;the number is {}&quot;, spaces) // 4 } 3.2 数据类型 标量和复合类型 Rust 是静态编译语言，在编译时必须知道所有变量的类型 基于使用的值，编译器通常能够推断出它的具体类型 但如果可能的类型较多（如将 String 转为整数的 parse 方法），就必须添加类型的标注，否则编译会报错 fn main() { let guess:i32 = &quot;42&quot;.parse().expect(&quot;not a number&quot;); println!(&quot;number is {}&quot;,guess); } 3.2.1 标量类型 一个标量类型代表一个单个的值 Rust 有四个主要的标量类型： 整数类型 浮点类型 布尔类型 字符类型 3.2.2 整数类型 3.2.2.1 基础介绍 整数类型没有小数部分 例如 u32 就是一个无符号的整数类型，占据32位空间 无符号整数类型以 u 开头 有符号整数类型以 i 开头 Rust 的整数类型列表如图： 每种都分为 i 和 u ，以及固定位数 有符号的范围： -2(n-1)~2(n-1)-1 无符号的范围：0~2^n-1 3.2.2.2 isize 和 usize isize 和 usize 类型的位数由程序运行的计算机的架构所决定的： 如果是 64 位计算机，那就是 64 位的 使用 isize 和 usize 的主要场景是对某种集合进行索引操作 3.2.2.3 整数字面值 除了 byte 类型外，所有的数值字面值都允许使用类型后缀 例如 57u8 如果不太清楚应该使用那种类型，可以使用 Rust 相应的默认类型 整数的默认类型就是 i32 总体上来说速冻更快，即使在 64 位系统中 3.2.2.4 整数溢出 例如：u8 的范围是 0-255，如果你把一个 u8 变量的值设为 256 ，那么： 调试模式下编译：Rust 会检查整数溢出，如果发生溢出，程序在运行时就会 panic 发布模式下(--release)编译：Rust 不会检查可能导致 panic 的整数溢出 如果溢出发生：Rust 会执行“环绕”操作： 256 变成 0，257 变成 1 ... 3.2.3 浮点类型 3.2.3.1 基础介绍 Rust 有两种基础的浮点类型，也就是含有小数部分的类型 f32，32位，单精度 f64，64为，双精度 Rust 的浮点类型使用了 IEEE-754 标准来表达 f64 是默认类型，因为在现代 CPU 上 f64 和 f32 的速度差不多，而且精度更高 3.2.3.2 数值操作 加减乘除余等 fn main() { let sum = 5 + 10; let difference = 95.5 - 4.3; let product = 4 * 30; let quotient = 56.7 / 32.2; let reminder = 54 % 5; } 3.2.4 布尔类型 Rust 的布尔类型也有两个值：true 和 false 一个字节大小 符号是 bool fn main() { let t = true; let m: bool = false; } 3.2.5 字符类型 Rust 语言中 char 类型被用来描述语言中最基础的单个字符。 字符类型的字面值使用单引号 占用 4 个字节大小 是 Unicode 标量值，可以表示比 ASCII 多得多的字符内容：拼音、中日韩文、零长度空白字符、emoji表情等。 U+0000 到 U+D7FF U+E000 到 U+10FFFF 但 Unicode 中并没有 “字符” 的概念，所以直觉上认为的字符也许与 Rust 中的概念并不相符 fn main() { let x: &amp;str = &quot;z&quot;; let y: char='z'; let z: char='😂'; } 3.3 复合类型 复合类型可以将多个值放在一个类型里。 Rust 提供了两种基础的复合类型：元组（Tuple）、数组 3.3.1 元组（Tuple） Tuple 可以将多个类型的多个值放到一个类型里 Tuple 的长度是固定的：一旦申明就无法改变 3.3.1.1 创建 Tuple 在小括号里，将值用逗号分开 Tuple 中的每一个位置都对应一个类型，Tuple 中个元素的类型不必相同 fn main() { let tup: (i32, f64, u8) =(500,6.4,1); println!(&quot;{},{},{}&quot;,tup.0,tup.1,tup.2); } 3.3.1.2 获取 Tuple 的元素值 可以使用模式匹配来解构（destructure）一个 Tuple 来获取元素的值 fn main() { let tup: (i32, f64, u8) =(500,6.4,1); let (x,y,z) =tup; println!(&quot;{},{},{}&quot;,x,y,z); } 3.3.1.3 访问 Tuple 的元素 在 Tuple 变量使用点标记法，后接元素的索引号 fn main() { let tup: (i32, f64, u8) =(500,6.4,1); println!(&quot;{},{},{}&quot;,tup.0,tup.1,tup.2); } 3.3.2 数组 数组也可以将多个值放在同一个类型里 数组中每个元素的类型必须相同 数组的长度也是固定的 3.3.2.1 申明数组 在中括号里，各值用逗号分开 fn main() { let a = [1,2,3,4,5]; } 3.3.2.2 数组的用处 如果想让数据存放在 stack（栈）上而不是 heap（堆）上，或者想保证有固定数量的元素，这时使用数组更有好处 数组没有 Vector 灵活 Vector 和数组类似，它由标准库提供 Vector 的长度可以改变 如果你不确定应该使用数组还是 Vector ，那么估计你应该使用 Vector 3.3.2.3 数组的类型 数组的类型表示形式：[类型；长度] 例如：let a:[i32;5] = [1,2,3,4,5]; 3.3.2.4 另一种申明数组的方式 如果数组的每个元素都相同，那么可以： 在中括号中指定初始值 然后是一个 &quot;;&quot; 最后是数组的长度 例如：let a=[3;5]; 相当于 let a = [3,3,3,3,3]; 3.3.2.5 访问数组的元素 数组是在 stack 上分配的单个块的内存 可以使用索引来访问数组的元素 如果访问的索引超出了数组的范围，那么 编译会通过 运行会报错（runtime 时会 panic ） Rust 不会允许其继续访问相应地址的内存 fn main() { let a = [1,2,3,4,5]; let first = a[0]; let second = a[1]; } 3.4 函数 申明函数使用 fn 关键字 按照惯例，针对函数与变量名，Rust 使用 snake case 命名规范： 所有的字母都是小写，单词之间使用下划线分开 fn main() { println!(&quot;hello world!&quot;); another_function(); } fn another_function(){ println!(&quot;Another function&quot;); } 3.4.1 函数的参数 parameters、arguments 在函数签名里，必须包含每个参数的类型 fn main() { println!(&quot;hello world!&quot;); another_function(5); // argument } fn another_function(x:i32){ // parameter println!(&quot; the number is {}&quot;,x); } 3.4.2 函数体中的语句与表达式 函数体由一系列语句组成，可选的由一个表达式结束 Rust 是一个基于表达式的语言 语句是执行一些动作的指令 表达式会计算产生一个值 函数定义也是语句 语句不返回值，所以不可以使用 let 将一个语句赋给一个变量 3.4.3 函数的返回值 在 -&gt; 符号后边申明函数返回值的类型，但是不可以为返回值命名 在 Rust 中，返回值就是函数体里面最后一个表达式的值 若想提前返回。需使用 return 关键字，并指定一个值 fn main() { let x=five(1); println!(&quot;the number is {}&quot;,x); // 6 } fn five(x:i32)-&gt;i32{ x+5 } 3.5 控制流 ：if else 3.5.1 if 表达式 if 表达式允许您根据条件来执行不同的代码分支 这个条件必须是bool类型 if 表达式中，与条件相关联的代码块就叫做分支（arm） 可选的，在后边可以加上一个 else 表达式 fn main() { let num=3; if num&lt;5{ println!(&quot;true&quot;); }else { println!(&quot;false&quot;); } } 3.5.2 使用 else if 处理多重条件 如果使用了多于一个 else if ，那么最好使用 match 来重构代码 3.5.3 在 let 语句中使用 if 因为 if 是一个表达式，所以可以将它放在 let 语句中等号的右边 fn main() { let condition = true; let num = if condition { 5 } else { 6 }; println!(&quot;the number is {}&quot;,num); // 5 } 3.6 控制流： Rust 的循环 Rust 提供了 3 中循环：loop，while 和 for 3.6.1 loop 循环 loop 关键字告诉 Rust 反复的执行一块代码，直到喊停 可以在 loop 循环中使用 break 关键字来告诉程序何时停止循环 fn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; println!(&quot;the result is {}&quot;, result); // 20 } 3.6.2 while 条件循环 另外一种常见的循环模式是每次执行循环体之前都判断一次条件 while条件循环为这种模式而生 fn main() { let mut counter = 3; while counter != 0 { println!(&quot;number is {}&quot;, counter); counter = counter - 1; } println!(&quot;LIFTOFF!!!&quot;); } 3.6.3 使用 for 循环遍历集合 可是使用 while 或 loop 来遍历集合，但是易错且低效 fn main() { let a = [10, 20, 30, 40, 50]; let mut index = 0; while index &lt; 5 { println!(&quot;{}&quot;, a[index]); index += 1; } } 使用 for 循环更简洁紧凑，它可以针对集合中的每个元素来执行一些代码 fn main() { let a = [10, 20, 30, 40, 50]; for element in a.iter(){ println!(&quot;{}&quot;,element); } } 由于 for 循环的安全、简洁性，所以它在 Rust 里用的最多 3.6.4 Range 标准库提供 指定一个开始数字和一个结束数字，Range 可以生成它们之间的数字（不含结束） rev 方法可以反转 Range fn main() { for number in (1..4).rev(){ println!(&quot;{}&quot;,number); } println!(&quot;LIFTOFF!!!&quot;) } ","link":"https://blog.zhawenwen.cn/post/rust_learn_003/"},{"title":"C++学习——01.C++基础","content":" C++基础入门 1 C++初识 1.1 第一个C++程序 1.1.1 创建项目 1.1.2 创建文件 1.1.3 编写代码 1.1.4 运行程序 1.2 注释 1.4 常量 1.5 关键字 2 数据类型 2.1 整型 2.2 sizeof关键字 2.4 字符型 2.5 转义字符 2.6 字符串型 2.8 数据的输入 3 运算符 3.1 算术运算符 3.2 赋值运算符 3.3 比较运算符 3.4 逻辑运算符 4.1 选择结构 4.1.1 if语句 4.1.2 三目运算符 4.1.3 switch语句 4.2 循环结构 4.2.1 while循环语句 4.2.2 do...while循环语句 4.2.3 for循环语句 4.2.4 嵌套循环 4.3 跳转语句 4.3.1 break语句 4.3.2 continue语句 5 数组 5.1 概述 5.2 一维数组 5.2.1 一维数组定义方式 5.2.2 一维数组数组名 5.3 二维数组 5.3.1 二维数组定义方式 5.3.2 二维数组数组名 5.3.3 二维数组应用案例 6 函数 6.1 概述 6.2 函数的定义 6.4 值传递 6.5 函数的常见样式 7 指针 7.1 指针的基本概念 7.2 指针变量的定义和使用 7.6 指针和数组 7.8 指针、数组、函数 8 结构体 8.1 结构体基本概念 8.2 结构体定义和使用 8.3 结构体数组 8.5 结构体嵌套结构体 8.6 结构体做函数参数 8.7 结构体中 const使用场景 8.8 结构体案例 8.8.1 案例1 8.8.2 案例2 C++基础入门 1 C++初识 1.1 第一个C++程序 编写一个C++程序总共分为4个步骤 创建项目 创建文件 编写代码 运行程序 1.1.1 创建项目 ​ Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开 1.1.2 创建文件 右键源文件，选择添加-&gt;新建项 给C++文件起个名称，然后点击添加即可。 1.1.3 编写代码 #include&lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 1.1.4 运行程序 1.2 注释 作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码 两种格式 单行注释：// 描述信息 通常放在一行代码的上方，或者一条语句的末尾，对该行代码说明 多行注释： /* 描述信息 */ 通常放在一段代码的上方，对该段代码做整体说明 提示：编译器在编译代码时，会忽略注释的内容### 1.3 变量 作用：给一段指定的内存空间起名，方便操作这段内存 语法：数据类型 变量名 = 初始值; 示例： #include&lt;iostream&gt; using namespace std; int main() { //变量的定义 //语法：数据类型 变量名 = 初始值 int a = 10; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 注意：C++在创建变量时，必须给变量一个初始值，否则会报错 1.4 常量 作用：用于记录程序中不可更改的数据 C++定义常量两种方式 #define 宏常量： #define 常量名 常量值 通常在文件上方定义，表示一个常量2. const修饰的变量 const 数据类型 常量名 = 常量值 通常在变量定义前加关键字const，修饰该变量为常量，不可修改 示例： //1、宏常量 #define day 7 int main() { cout &lt;&lt; &quot;一周里总共有 &quot; &lt;&lt; day &lt;&lt; &quot; 天&quot; &lt;&lt; endl; //day = 8; //报错，宏常量不可以修改 //2、const修饰变量 const int month = 12; cout &lt;&lt; &quot;一年里总共有 &quot; &lt;&lt; month &lt;&lt; &quot; 个月份&quot; &lt;&lt; endl; //month = 24; //报错，常量是不可以修改的 system(&quot;pause&quot;); return 0; } 1.5 关键字 **作用：**关键字是C++中预先保留的单词（标识符） 在定义变量或者常量时候，不要用关键字 C++关键字如下： asm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try 提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。### 1.6 标识符命名规则 作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则 标识符不能是关键字 标识符只能由字母、数字、下划线组成 第一个字符必须为字母或下划线 标识符中字母区分大小写 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读 2 数据类型 C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存 2.1 整型 作用：整型变量表示的是整数类型的数据 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同： 数据类型 占用空间 取值范围 short(短整型) 2字节 (-2^15 ~ 2^15-1) int(整型) 4字节 (-2^31 ~ 2^31-1) long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1) long long(长长整形) 8字节 (-2^63 ~ 2^63-1) 2.2 sizeof关键字 **作用：**利用sizeof关键字可以统计数据类型所占内存大小 语法： sizeof( 数据类型 / 变量) 示例： int main() { cout &lt;&lt; &quot;short 类型所占内存空间为： &quot; &lt;&lt; sizeof(short) &lt;&lt; endl; cout &lt;&lt; &quot;int 类型所占内存空间为： &quot; &lt;&lt; sizeof(int) &lt;&lt; endl; cout &lt;&lt; &quot;long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long) &lt;&lt; endl; cout &lt;&lt; &quot;long long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl; system(&quot;pause&quot;); return 0; } ```&gt; **整型结论**：==short &lt; int &lt;= long &lt;= long long== ### 2.3 实型（浮点型） **作用**：用于==表示小数== 浮点型变量分为两种： 1. 单精度float 2. 双精度double 两者的**区别**在于表示的有效数字范围不同。 | **数据类型** | **占用空间** | **有效数字范围** | | ------------ | ------------ | ---------------- | | float | 4字节 | 7位有效数字 | | double | 8字节 | 15～16位有效数字 | **示例：** ```C++ int main() { float f1 = 3.14f; double d1 = 3.14; cout &lt;&lt; f1 &lt;&lt; endl; cout &lt;&lt; d1&lt;&lt; endl; cout &lt;&lt; &quot;float sizeof = &quot; &lt;&lt; sizeof(f1) &lt;&lt; endl; cout &lt;&lt; &quot;double sizeof = &quot; &lt;&lt; sizeof(d1) &lt;&lt; endl; //科学计数法 float f2 = 3e2; // 3 * 10 ^ 2 cout &lt;&lt; &quot;f2 = &quot; &lt;&lt; f2 &lt;&lt; endl; float f3 = 3e-2; // 3 * 0.1 ^ 2 cout &lt;&lt; &quot;f3 = &quot; &lt;&lt; f3 &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 2.4 字符型 **作用：**字符型变量用于显示单个字符 语法：char ch = 'a'; 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号 注意2：单引号内只能有一个字符，不可以是字符串 C和C++中字符型变量只占用1个字节。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元 示例： int main() { char ch = 'a'; cout &lt;&lt; ch &lt;&lt; endl; cout &lt;&lt; sizeof(char) &lt;&lt; endl; //ch = &quot;abcde&quot;; //错误，不可以用双引号 //ch = 'abcde'; //错误，单引号内只能引用一个字符 cout &lt;&lt; (int)ch &lt;&lt; endl; //查看字符a对应的ASCII码 ch = 97; //可以直接用ASCII给字符型变量赋值 cout &lt;&lt; ch &lt;&lt; endl; system(&quot;pause&quot;); return 0; } ASCII码表格： ASCII值 控制字符 ASCII值 字符 ASCII值 字符 ASCII值 字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 &quot; 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ASCII 码大致由以下两部分组成： ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。 ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。 2.5 转义字符 **作用：**用于表示一些不能显示出来的ASCII字符 现阶段我们常用的转义字符有： \\n \\\\ \\t 转义字符 含义 ASCII码值（十进制） \\a 警报 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\\\ 代表一个反斜线字符&quot;&quot; 092 ' 代表一个单引号（撇号）字符 039 &quot; 代表一个双引号字符 034 ? 代表一个问号 063 \\0 数字0 000 \\ddd 8进制转义字符，d范围0~7 3位8进制 \\xhh 16进制转义字符，h范围09，af，A~F 3位16进制 示例： int main() { cout &lt;&lt; &quot;\\\\&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\tHello&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\n&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 2.6 字符串型 作用：用于表示一串字符 两种风格 C风格字符串： char 变量名[] = &quot;字符串值&quot; 示例： int main() { char str1[] = &quot;hello world&quot;; cout &lt;&lt; str1 &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 注意：C风格的字符串要用双引号括起来 C++风格字符串： string 变量名 = &quot;字符串值&quot; 示例： int main() { string str = &quot;hello world&quot;; cout &lt;&lt; str &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;==### 2.7 布尔类型 bool 作用： 布尔数据类型代表真或假的值 bool类型只有两个值： true --- 真（本质是1） false --- 假（本质是0） bool类型占1个字节大小 示例： int main() { bool flag = true; cout &lt;&lt; flag &lt;&lt; endl; // 1 flag = false; cout &lt;&lt; flag &lt;&lt; endl; // 0 cout &lt;&lt; &quot;size of bool = &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; //1 system(&quot;pause&quot;); return 0; } 2.8 数据的输入 作用：用于从键盘获取数据 关键字： cin 语法： cin &gt;&gt; 变量 示例： int main(){ //整型输入 int a = 0; cout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl; cin &gt;&gt; a; cout &lt;&lt; a &lt;&lt; endl; //浮点型输入 double d = 0; cout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl; cin &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl; //字符型输入 char ch = 0; cout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; //字符串型输入 string str; cout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; //布尔类型输入 bool flag = true; cout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl; cin &gt;&gt; flag; cout &lt;&lt; flag &lt;&lt; endl; system(&quot;pause&quot;); return EXIT_SUCCESS; } 3 运算符 作用： 用于执行代码的运算 本章我们主要讲解以下几类运算符： 运算符类型 作用 算术运算符 用于处理四则运算 赋值运算符 用于将表达式的值赋给变量 比较运算符 用于表达式的比较，并返回一个真值或假值 逻辑运算符 用于根据表达式的值返回真值或假值 3.1 算术运算符 作用：用于处理四则运算 算术运算符包括以下符号： 运算符 术语 示例 结果 + 正号 +3 3 - 负号 -3 -3 + 加 10 + 5 15 - 减 10 - 5 5 * 乘 10 * 5 50 / 除 10 / 5 2 % 取模(取余) 10 % 3 1 ++ 前置递增 a=2; b=++a; a=3; b=3; ++ 后置递增 a=2; b=a++; a=3; b=2; -- 前置递减 a=2; b=--a; a=1; b=1; -- 后置递减 a=2; b=a--; a=1; b=2; 示例1： //加减乘除 int main() { int a1 = 10; int b1 = 3; cout &lt;&lt; a1 + b1 &lt;&lt; endl; cout &lt;&lt; a1 - b1 &lt;&lt; endl; cout &lt;&lt; a1 * b1 &lt;&lt; endl; cout &lt;&lt; a1 / b1 &lt;&lt; endl; //两个整数相除结果依然是整数 int a2 = 10; int b2 = 20; cout &lt;&lt; a2 / b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0 //两个小数可以相除 double d1 = 0.5; double d2 = 0.25; cout &lt;&lt; d1 / d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：在除法运算中，除数不能为0示例2： //取模 int main() { int a1 = 10; int b1 = 3; cout &lt;&lt; 10 % 3 &lt;&lt; endl; int a2 = 10; int b2 = 20; cout &lt;&lt; a2 % b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0 //两个小数不可以取模 double d1 = 3.14; double d2 = 1.1; //cout &lt;&lt; d1 % d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：只有整型变量可以进行取模运算 示例3： //递增 int main() { //后置递增 int a = 10; a++; //等价于a = a + 1 cout &lt;&lt; a &lt;&lt; endl; // 11 //前置递增 int b = 10; ++b; cout &lt;&lt; b &lt;&lt; endl; // 11 //区别 //前置递增先对变量进行++，再计算表达式 int a2 = 10; int b2 = ++a2 * 10; cout &lt;&lt; b2 &lt;&lt; endl; //后置递增先计算表达式，后对变量进行++ int a3 = 10; int b3 = a3++ * 10; cout &lt;&lt; b3 &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：前置递增先对变量进行++，再计算表达式，后置递增相反 3.2 赋值运算符 **作用：**用于将表达式的值赋给变量 赋值运算符包括以下几个符号： 运算符 术语 示例 结果 = 赋值 a=2; b=3; a=2; b=3; += 加等于 a=0; a+=2; a=2; -= 减等于 a=5; a-=3; a=2; *= 乘等于 a=2; a*=2; a=4; /= 除等于 a=4; a/=2; a=2; %= 模等于 a=3; a%2; a=1; 示例： int main() { //赋值运算符 // = int a = 10; a = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // += a = 10; a += 2; // a = a + 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // -= a = 10; a -= 2; // a = a - 2 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // *= a = 10; a *= 2; // a = a * 2 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // /= a = 10; a /= 2; // a = a / 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // %= a = 10; a %= 2; // a = a % 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 3.3 比较运算符 作用： 用于表达式的比较，并返回一个真值或假值 比较运算符有以下符号： 运算符 术语 示例 结果 == 相等于 4 == 3 0 != 不等于 4 != 3 1 &lt; 小于 4 &lt; 3 0 &gt; 大于 4 &gt; 3 1 &lt;= 小于等于 4 &lt;= 3 0 &gt;= 大于等于 4 &gt;= 1 1 示例： int main() { int a = 10; int b = 20; cout &lt;&lt; (a == b) &lt;&lt; endl; // 0 cout &lt;&lt; (a != b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1 system(&quot;pause&quot;); return 0; } 注意：C和C++ 语言的比较运算中， “真”用数字“1”来表示， “假”用数字“0”来表示。 3.4 逻辑运算符 **作用：**用于根据表达式的值返回真值或假值 逻辑运算符有以下符号： 运算符 术语 示例 结果 ! 非 !a 如果a为假，则!a为真； 如果a为真，则!a为假。 &amp;&amp; 与 a &amp;&amp; b 如果a和b都为真，则结果为真，否则为假。 || 或 a || b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 **示例1：**逻辑非 //逻辑运算符 --- 非 int main() { int a = 10; cout &lt;&lt; !a &lt;&lt; endl; // 0 cout &lt;&lt; !!a &lt;&lt; endl; // 1 system(&quot;pause&quot;); return 0; } 总结： 真变假，假变真示例2： 逻辑与 //逻辑运算符 --- 与 int main() { int a = 10; int b = 10; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 a = 0; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 system(&quot;pause&quot;); return 0; } 总结：逻辑与运算符总结： 同真为真，其余为假 示例3： 逻辑或 //逻辑运算符 --- 或 int main() { int a = 10; int b = 10; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 0; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 0 system(&quot;pause&quot;); return 0; } 逻辑或运算符总结： 同假为假，其余为真## 4 程序流程结构 C/C++支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构 顺序结构：程序按顺序执行，不发生跳转 选择结构：依据条件是否满足，有选择的执行相应功能 循环结构：依据条件是否满足，循环多次执行某段代码 4.1 选择结构 4.1.1 if语句 **作用：**执行满足条件的语句 if语句的三种形式 单行格式if语句 多行格式if语句 多条件的if语句 单行格式if语句：if(条件){ 条件满足执行的语句 } 示例： int main() { //选择结构-单行if语句 //输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印 int score = 0; cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl; //if语句 //注意事项，在if判断语句后面，不要加分号 if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 注意：if条件表达式后不要加分号 多行格式if语句：if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 }; 示例： int main() { int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 多条件的if语句： if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句} 示例： int main() { int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; } else if (score &gt; 500) { cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; } else if (score &gt; 400) { cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断 案例需求： 提示用户输入一个高考考试分数，根据分数做如下判断 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科； 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。 示例： int main() { int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; if (score &gt; 700) { cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl; } else if (score &gt; 650) { cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl; } } else if (score &gt; 500) { cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; } else if (score &gt; 400) { cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 练习案例： 三只小猪称体重 有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？ 4.1.2 三目运算符 作用： 通过三目运算符实现简单的判断 语法：表达式1 ? 表达式2 ：表达式3 解释： 如果表达式1的值为真，执行表达式2，并返回表达式2的结果； 如果表达式1的值为假，执行表达式3，并返回表达式3的结果。 示例： int main() { int a = 10; int b = 20; int c = 0; c = a &gt; b ? a : b; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; //C++中三目运算符返回的是变量,可以继续赋值 (a &gt; b ? a : b) = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰 4.1.3 switch语句 **作用：**执行多条件分支语句 语法： switch(表达式) { case 结果1：执行语句;break; case 结果2：执行语句;break; ... default:执行语句;break; } 示例： int main() { //请给电影评分 //10 ~ 9 经典 // 8 ~ 7 非常好 // 6 ~ 5 一般 // 5分以下 烂片 int score = 0; cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl; cin &gt;&gt; score; switch (score) { case 10: case 9: cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl; break; case 8: cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl; break; case 7: case 6: cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl; break; default: cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl; break; } system(&quot;pause&quot;); return 0; } 注意1：switch语句中表达式类型只能是整型或者字符型 注意2：case里如果没有break，那么程序会一直向下执行 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间 4.2 循环结构 4.2.1 while循环语句 作用： 满足循环条件，执行循环语句 语法： while(循环条件){ 循环语句 } 解释：只要循环条件的结果为真，就执行循环语句 示例： int main() { int num = 0; while (num &lt; 10) { cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; num++; } system(&quot;pause&quot;); return 0; } 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环 while循环练习案例：猜数字 案例描述： 系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。 4.2.2 do...while循环语句 作用： 满足循环条件，执行循环语句 语法： do{ 循环语句 } while(循环条件); **注意：**与while的区别在于do...while会先执行一次循环语句，再判断循环条件 示例： int main() { int num = 0; do { cout &lt;&lt; num &lt;&lt; endl; num++; } while (num &lt; 10); system(&quot;pause&quot;); return 0; } 总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件 练习案例：水仙花数 **案例描述：**水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身 例如：1^3 + 5^3+ 3^3 = 153 请利用do...while语句，求出所有3位数中的水仙花数 4.2.3 for循环语句 作用： 满足循环条件，执行循环语句 语法： for(起始表达式;条件表达式;末尾循环体) { 循环语句; } 示例： int main() { for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; i &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 详解： 注意：for循环中的表达式，要用分号进行分隔 总结：while , do...while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用练习案例：敲桌子 案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。 4.2.4 嵌套循环 作用： 在循环体中再嵌套一层循环，解决一些实际问题 例如我们想在屏幕中打印如下图片，就需要利用嵌套循环 示例： int main() { //外层循环执行1次，内层循环执行1轮 for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 练习案例： 乘法口诀表 案例描述：利用嵌套循环，实现九九乘法表 4.3 跳转语句 4.3.1 break语句 作用: 用于跳出选择结构或者循环结构 break使用的时机： 出现在switch条件语句中，作用是终止case并跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环语句 示例1： int main() { //1、在switch 语句中使用break cout &lt;&lt; &quot;请选择您挑战副本的难度：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、普通&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、中等&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3、困难&quot; &lt;&lt; endl; int num = 0; cin &gt;&gt; num; switch (num) { case 1: cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl; break; case 2: cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl; break; case 3: cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl; break; } system(&quot;pause&quot;); return 0; } 示例2： int main() { //2、在循环语句中用break for (int i = 0; i &lt; 10; i++) { if (i == 5) { break; //跳出循环语句 } cout &lt;&lt; i &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 示例3： int main() { //在嵌套循环语句中使用break，退出内层循环 for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { if (j == 5) { break; } cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 4.3.2 continue语句 **作用：**在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环 示例： int main() { for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { continue; } cout &lt;&lt; i &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 注意：continue并没有使整个循环终止，而break会跳出循环#### 4.3.3 goto语句 **作用：**可以无条件跳转语句 语法： goto 标记; **解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置 示例： int main() { cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; goto FLAG; cout &lt;&lt; &quot;2&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3&quot; &lt;&lt; endl; cout &lt;&lt; &quot;4&quot; &lt;&lt; endl; FLAG: cout &lt;&lt; &quot;5&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 注意：在程序中不建议使用goto语句，以免造成程序流程混乱 5 数组 5.1 概述 所谓数组，就是一个集合，里面存放了相同类型的数据元素 特点1： 数组中的每个数据元素都是相同的数据类型 特点2： 数组是由连续的内存位置组成的 5.2 一维数组 5.2.1 一维数组定义方式 一维数组定义的三种方式： 数据类型 数组名[ 数组长度 ]; 数据类型 数组名[ 数组长度 ] = { 值1，值2 ...}; 数据类型 数组名[ ] = { 值1，值2 ...}; 示例 int main() { //定义方式1 //数据类型 数组名[元素个数]; int score[10]; //利用下标赋值 score[0] = 100; score[1] = 99; score[2] = 85; //利用下标输出 cout &lt;&lt; score[0] &lt;&lt; endl; cout &lt;&lt; score[1] &lt;&lt; endl; cout &lt;&lt; score[2] &lt;&lt; endl; //第二种定义方式 //数据类型 数组名[元素个数] = {值1，值2 ，值3 ...}; //如果{}内不足10个数据，剩余数据用0补全 int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 }; //逐个输出 //cout &lt;&lt; score2[0] &lt;&lt; endl; //cout &lt;&lt; score2[1] &lt;&lt; endl; //一个一个输出太麻烦，因此可以利用循环进行输出 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; score2[i] &lt;&lt; endl; } //定义方式3 //数据类型 数组名[] = {值1，值2 ，值3 ...}; int score3[] = { 100,90,80,70,60,50,40,30,20,10 }; for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; score3[i] &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名 总结2：数组中下标是从0开始索引 5.2.2 一维数组数组名 一维数组名称的用途： 可以统计整个数组在内存中的长度 可以获取数组在内存中的首地址示例： int main() { //数组名用途 //1、可以获取整个数组占用内存空间大小 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; //2、可以通过数组名获取到数组首地址 cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl; cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl; //arr = 100; 错误，数组名是常量，因此不可以赋值 system(&quot;pause&quot;); return 0; } 注意：数组名是常量，不可以赋值 总结1：直接打印数组名，可以查看数组所占内存的首地址 总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小练习案例1：五只小猪称体重 案例描述： 在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250}; 找出并打印最重的小猪体重。 **练习案例2：**数组元素逆置 **案例描述：**请声明一个5个元素的数组，并且将元素逆置. (如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);#### 5.2.3 冒泡排序 作用： 最常用的排序算法，对数组内元素进行排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。 重复以上的步骤，每次比较次数-1，直到不需要比较示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序 int main() { int arr[9] = { 4,2,8,0,5,7,1,3,9 }; for (int i = 0; i &lt; 9 - 1; i++) { for (int j = 0; j &lt; 9 - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; arr[i] &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 5.3 二维数组 二维数组就是在一维数组上，多加一个维度。 5.3.1 二维数组定义方式 二维数组定义的四种方式： 数据类型 数组名[ 行数 ][ 列数 ]; 数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } }; 数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 建议：以上4种定义方式，利用第二种更加直观，提高代码的可读性 示例： int main() { //方式1 //数组类型 数组名 [行数][列数] int arr[2][3]; arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3; arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 3; j++) { cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //方式2 //数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } }; int arr2[2][3] = { {1,2,3}, {4,5,6} }; //方式3 //数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4 }; int arr3[2][3] = { 1,2,3,4,5,6 }; //方式4 //数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4 }; int arr4[][3] = { 1,2,3,4,5,6 }; system(&quot;pause&quot;); return 0; } 总结：在定义二维数组时，如果初始化了数据，可以省略行数 5.3.2 二维数组数组名 查看二维数组所占内存空间 获取二维数组首地址示例： int main() { //二维数组数组名 int arr[2][3] = { {1,2,3}, {4,5,6} }; cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl; //地址 cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结1：二维数组名就是这个数组的首地址 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小 5.3.3 二维数组应用案例 考试成绩统计： 案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩 语文 数学 英语 张三 100 100 100 李四 90 50 100 王五 60 70 80 int main() { int scores[3][3] = { {100,100,100}, {90,50,100}, {60,70,80}, }; string names[3] = { &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; }; for (int i = 0; i &lt; 3; i++) { int sum = 0; for (int j = 0; j &lt; 3; j++) { sum += scores[i][j]; } cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 6 函数 6.1 概述 作用： 将一段经常使用的代码封装起来，减少重复代码 一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。 6.2 函数的定义 函数的定义一般主要有5个步骤： 1、返回值类型 2、函数名 3、参数表列 4、函数体语句 5、return 表达式 语法： 返回值类型 函数名 （参数列表） { 函数体语句 return 表达式 } 返回值类型 ：一个函数可以返回一个值。在函数定义中 函数名：给函数起个名称 参数列表：使用该函数时，传入的数据 函数体语句：花括号内的代码，函数内需要执行的语句 return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据示例： 定义一个加法函数，实现两个数相加 //函数定义 int add(int num1, int num2) { int sum = num1 + num2; return sum; } ```### 6.3 函数的调用 **功能：** 使用定义好的函数 **语法：**` 函数名（参数）` **示例：** ```C++ //函数定义 int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参 { int sum = num1 + num2; return sum; } int main() { int a = 10; int b = 10; //调用add函数 int sum = add(a, b);//调用时的a，b称为实际参数，简称实参 cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl; a = 100; b = 100; sum = add(a, b); cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参 6.4 值传递 所谓值传递，就是函数调用时实参将数值传入给形参 值传递时，如果形参发生，并不会影响实参 示例： void swap(int num1, int num2) { cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl; int temp = num1; num1 = num2; num2 = temp; cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl; //return ; 当函数声明时候，不需要返回值，可以不写return } int main() { int a = 10; int b = 20; swap(a, b); cout &lt;&lt; &quot;mian中的 a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;mian中的 b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结： 值传递时，形参是修饰不了实参的 6.5 函数的常见样式 常见的函数样式有4种 无参无返 有参无返 无参有返 有参有返 示例： //函数常见样式 //1、 无参无返 void test01() { //void a = 10; //无类型不可以创建变量,原因无法分配内存 cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl; //test01(); 函数调用 } //2、 有参无返 void test02(int a) { cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; endl; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; } //3、无参有返 int test03() { cout &lt;&lt; &quot;this is test03 &quot; &lt;&lt; endl; return 10; } //4、有参有返 int test04(int a, int b) { cout &lt;&lt; &quot;this is test04 &quot; &lt;&lt; endl; int sum = a + b; return sum; } ```### 6.6 函数的声明 **作用：** 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 * 函数的**声明可以多次**，但是函数的**定义只能有一次** **示例：** ```C++ //声明可以多次，定义只能一次 //声明 int max(int a, int b); int max(int a, int b); //定义 int max(int a, int b) { return a &gt; b ? a : b; } int main() { int a = 100; int b = 200; cout &lt;&lt; max(a, b) &lt;&lt; endl; system(&quot;pause&quot;); return 0; } ```### 6.7 函数的分文件编写 **作用：** 让代码结构更加清晰 函数分文件编写一般有4个步骤 1. 创建后缀名为.h的头文件 2. 创建后缀名为.cpp的源文件 3. 在头文件中写函数的声明 4. 在源文件中写函数的定义 **示例：** ```C++ //swap.h文件 #include&lt;iostream&gt; using namespace std; //实现两个数字交换的函数声明 void swap(int a, int b); //swap.cpp文件 #include &quot;swap.h&quot; void swap(int a, int b) { int temp = a; a = b; b = temp; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; } //main函数文件 #include &quot;swap.h&quot; int main() { int a = 100; int b = 200; swap(a, b); system(&quot;pause&quot;); return 0; } 7 指针 7.1 指针的基本概念 指针的作用： 可以通过指针间接访问内存 内存编号是从0开始记录的，一般用十六进制数字表示 可以利用指针变量保存地址 7.2 指针变量的定义和使用 指针变量定义语法： 数据类型 * 变量名； 示例： int main() { //1、指针的定义 int a = 10; //定义整型变量a //指针定义语法： 数据类型 * 变量名 ; int * p; //指针变量赋值 p = &amp;a; //指针指向变量a的地址 cout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址 cout &lt;&lt; p &lt;&lt; endl; //打印指针变量p //2、指针的使用 //通过*操作指针变量指向的内存 cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 指针变量和普通变量的区别 普通变量存放的是数据,指针变量存放的是地址 指针变量可以通过&quot; * &quot;操作符，操作指针变量指向的内存空间，这个过程称为解引用 总结1： 我们可以通过 &amp; 符号 获取变量的地址 总结2：利用指针可以记录地址 总结3：对指针变量解引用，可以操作指针指向的内存### 7.3 指针所占内存空间 提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？ 示例： int main() { int a = 10; int * p; p = &amp;a; //指针指向数据a的地址 cout &lt;&lt; *p &lt;&lt; endl; //* 解引用 cout &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; sizeof(char *) &lt;&lt; endl; cout &lt;&lt; sizeof(float *) &lt;&lt; endl; cout &lt;&lt; sizeof(double *) &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：所有指针类型在32位操作系统下是4个字节### 7.4 空指针和野指针 空指针：指针变量指向内存中编号为0的空间 用途： 初始化指针变量 注意： 空指针指向的内存是不可以访问的 示例1：空指针 int main() { //指针变量p指向内存地址编号为0的空间 int * p = NULL; //访问空指针报错 //内存编号0 ~255为系统占用内存，不允许用户访问 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 野指针：指针变量指向非法的内存空间 示例2：野指针 int main() { //指针变量p指向内存地址编号为0x1100的空间 int * p = (int *)0x1100; //访问野指针报错 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; } ```&gt; 总结：空指针和野指针都不是我们申请的空间，因此不要访问。 ### 7.5 const修饰指针 const修饰指针有三种情况 1. const修饰指针 --- 常量指针 2. const修饰常量 --- 指针常量 3. const即修饰指针，又修饰常量 **示例：**```c++ int main() { int a = 10; int b = 10; //const修饰的是指针，指针指向可以改，指针指向的值不可以更改 const int * p1 = &amp;a; p1 = &amp;b; //正确 //*p1 = 100; 报错 //const修饰的是常量，指针指向不可以改，指针指向的值可以更改 int * const p2 = &amp;a; //p2 = &amp;b; //错误 *p2 = 100; //正确 //const既修饰指针又修饰常量 const int * const p3 = &amp;a; //p3 = &amp;b; //错误 //*p3 = 100; //错误 system(&quot;pause&quot;); return 0; } 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量 7.6 指针和数组 作用： 利用指针访问数组中元素 示例： int main() { int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; int * p = arr; //指向数组的指针 cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) { //利用指针遍历数组 cout &lt;&lt; *p &lt;&lt; endl; p++; } system(&quot;pause&quot;); return 0; } ```### 7.7 指针和函数 **作用：** 利用指针作函数参数，可以修改实参的值 **示例：** ```C++ //值传递 void swap1(int a ,int b) { int temp = a; a = b; b = temp; } //地址传递 void swap2(int * p1, int *p2) { int temp = *p1; *p1 = *p2; *p2 = temp; } int main() { int a = 10; int b = 20; swap1(a, b); // 值传递不会改变实参 swap2(&amp;a, &amp;b); //地址传递会改变实参 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递 7.8 指针、数组、函数 案例描述： 封装一个函数，利用冒泡排序，实现对整型数组的升序排序 例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; 示例： //冒泡排序函数 void bubbleSort(int * arr, int len) //int * arr 也可以写为int arr[] { for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } //打印数组函数 void printArray(int arr[], int len) { for (int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; endl; } } int main() { int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; int len = sizeof(arr) / sizeof(int); bubbleSort(arr, len); printArray(arr, len); system(&quot;pause&quot;); return 0; } 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针 8 结构体 8.1 结构体基本概念 结构体属于用户自定义的数据类型，允许用户存储不同的数据类型 8.2 结构体定义和使用 语法：struct 结构体名 { 结构体成员列表 }； 通过结构体创建变量的方式有三种： struct 结构体名 变量名 struct 结构体名 变量名 = { 成员1值 ， 成员2值...} 定义结构体时顺便创建变量 示例： //结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }stu3; //结构体变量创建方式3 int main() { //结构体变量创建方式1 struct student stu1; //struct 关键字可以省略 stu1.name = &quot;张三&quot;; stu1.age = 18; stu1.score = 100; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl; //结构体变量创建方式2 struct student stu2 = { &quot;李四&quot;,19,60 }; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl; stu3.name = &quot;王五&quot;; stu3.age = 18; stu3.score = 80; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结1：定义结构体时的关键字是struct，不可省略 总结2：创建结构体变量时，关键字struct可以省略 总结3：结构体变量利用操作符 ''.'' 访问成员 8.3 结构体数组 作用： 将自定义的结构体放入到数组中方便维护 语法： struct 结构体名 数组名[元素个数] = { {} , {} , ... {} } 示例： //结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 } int main() { //结构体数组 struct student arr[3]= { {&quot;张三&quot;,18,80 }, {&quot;李四&quot;,19,60 }, {&quot;王五&quot;,20,70 } }; for (int i = 0; i &lt; 3; i++) { cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } ```### 8.4 结构体指针 **作用：** 通过指针访问结构体中的成员 * 利用操作符 `-&gt; `可以通过结构体指针访问结构体属性 **示例：** ```C++ //结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 };int main() { struct student stu = { &quot;张三&quot;,18,100, }; struct student * p = &amp;stu; p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员 8.5 结构体嵌套结构体 作用： 结构体中的成员可以是另一个结构体 例如： 每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体 示例： //学生结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; //教师结构体定义 struct teacher { //成员列表 int id; //职工编号 string name; //教师姓名 int age; //教师年龄 struct student stu; //子结构体 学生 };int main() { struct teacher t1; t1.id = 10000; t1.name = &quot;老王&quot;; t1.age = 40; t1.stu.name = &quot;张三&quot;; t1.stu.age = 18; t1.stu.score = 100; cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl; cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结： 在结构体中可以定义另一个结构体作为成员，用来解决实际问题 8.6 结构体做函数参数 作用： 将结构体作为参数向函数中传递 传递方式有两种： 值传递 地址传递 示例： //学生结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; //值传递 void printStudent(student stu ) { stu.age = 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; } //地址传递 void printStudent2(student *stu) { stu-&gt;age = 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl; } int main() { student stu = { &quot;张三&quot;,18,100}; //值传递 printStudent(stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; cout &lt;&lt; endl; //地址传递 printStudent2(&amp;stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递 8.7 结构体中 const使用场景 作用： 用const来防止误操作 示例： //学生结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; //const使用场景 void printStudent(const student *stu) //加const防止函数体中的误操作 { //stu-&gt;age = 100; //操作失败，因为加了const修饰 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl; } int main() { student stu = { &quot;张三&quot;,18,100 }; printStudent(&amp;stu); system(&quot;pause&quot;); return 0; } 8.8 结构体案例 8.8.1 案例1 案例描述： 学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下 设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员 学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值 最终打印出老师数据以及老师所带的学生数据。 示例： struct Student { string name; int score; }; struct Teacher { string name; Student sArray[5]; }; void allocateSpace(Teacher tArray[] , int len) { string tName = &quot;教师&quot;; string sName = &quot;学生&quot;; string nameSeed = &quot;ABCDE&quot;; for (int i = 0; i &lt; len; i++) { tArray[i].name = tName + nameSeed[i]; for (int j = 0; j &lt; 5; j++) { tArray[i].sArray[j].name = sName + nameSeed[j]; tArray[i].sArray[j].score = rand() % 61 + 40; } } } void printTeachers(Teacher tArray[], int len) { for (int i = 0; i &lt; len; i++) { cout &lt;&lt; tArray[i].name &lt;&lt; endl; for (int j = 0; j &lt; 5; j++) { cout &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; tArray[i].sArray[j].name &lt;&lt; &quot; 分数：&quot; &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl; } } } int main() { srand((unsigned int)time(NULL)); //随机数种子 头文件 #include &lt;ctime&gt; Teacher tArray[3]; //老师数组 int len = sizeof(tArray) / sizeof(Teacher); allocateSpace(tArray, len); //创建数据 printTeachers(tArray, len); //打印数据 system(&quot;pause&quot;); return 0; } 8.8.2 案例2 案例描述： 设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。 通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。 五名英雄信息如下： {&quot;刘备&quot;,23,&quot;男&quot;}, {&quot;关羽&quot;,22,&quot;男&quot;}, {&quot;张飞&quot;,20,&quot;男&quot;}, {&quot;赵云&quot;,21,&quot;男&quot;}, {&quot;貂蝉&quot;,19,&quot;女&quot;}, ```**示例：** ```C++ //英雄结构体 struct hero { string name; int age; string sex; }; //冒泡排序 void bubbleSort(hero arr[] , int len) { for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (arr[j].age &gt; arr[j + 1].age) { hero temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } //打印数组 void printHeros(hero arr[], int len) { for (int i = 0; i &lt; len; i++) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 性别： &quot; &lt;&lt; arr[i].sex &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].age &lt;&lt; endl; } } int main() { struct hero arr[5] = { {&quot;刘备&quot;,23,&quot;男&quot;}, {&quot;关羽&quot;,22,&quot;男&quot;}, {&quot;张飞&quot;,20,&quot;男&quot;}, {&quot;赵云&quot;,21,&quot;男&quot;}, {&quot;貂蝉&quot;,19,&quot;女&quot;}, }; int len = sizeof(arr) / sizeof(hero); //获取数组元素个数 bubbleSort(arr, len); //排序 printHeros(arr, len); //打印 system(&quot;pause&quot;); return 0; } ","link":"https://blog.zhawenwen.cn/post/C++_001/"},{"title":"24秋招：前端面试题学习与记录_001","content":" 参考：https://www.bilibili.com/video/BV12E41137h7 1、H5+C3 部分 1.1 cookies，sessionStorage 和 localStorage 问题：请描述一下cookies,sessionStorage和localStorage的区别？ 分析：考察求职者对于本地存储的方式是否熟悉，因为初学者会把 cookies 和 sessionStorage 与 localStorage 搞混 解答： cookies ：它是网站用来标记用户身份的一段数据，通常情况下是一段加密的字符串，并且默认情况之下只会在同源的HTTP请求中携带 sessionStorage：它是浏览器本地存储的一种方式，以键值对的形式进行存储，并且存储的数据会在浏览器关闭之后自动删除 localStorage：它也是浏览器本地存储的一种方式，和sessionStorage一样，也是以键值对的形式存在的，不过它存储的是一个持久化的数据，一般不主动删除，数据会一直存在 1.2 display:none; 与 visibility:hidden; 问题：display:none;与visibility:hidden;的区别？ 分析：这是一个比较容易出现错误的CSS问题，没有大量实际开发经验的开发者，很难了解它们之间的区别 解答： 共同点：它们都可以让元素不可见 不同点： display:none; 会让元素完全从渲染树中消失，不渲染的时候不占据任何空间。而 visibility:hidden; 不会让元素从渲染树消失，不渲染时元素继续占据空间，只是内容不可见 display:none; 是非继承属性，子孙节点消失是因为元素从渲染树消失造成，通过修改子孙节点属性无法显示；而 visibility:hidden; 是继承属性，子孙节点消失由于继承了 hidden ，通过设置 visibility:visible; 可以让子孙节点显式 1.3 为什么要初始化 CSS 样式 问题：为什么要初始化CSS样式？ 分析：这个问题主要是看你有没有实际开发的经验，因为对于没有实际开发经验的同学，是不知道在正式项目开发时要初始化 CSS 样式的，也就是清理掉一些元素默认所携带的样式，比如默认的 padding 和 margin 解答： 因为浏览器的兼容问题，不同浏览器对有些元素的默认样式是不同的，并且默认的样式会影响到项目最终的布局，如果没对 CSS 初始化，那么有可能会出现浏览器之间的页面显示差异。 1.4 PostCSS 问题：什么是 postcss ，以及 postcss 有什么作用？ 分析：有很多已经工作了两年、三年的开发者依然无法解释清楚 postcss 是什么，以及它的作用 解答： 首先明确 postcss 是一个平台 基于这个平台，可以使用一些插件，来优化 css 的代码。比如说：autoprefixer 插件，他就需要基于 postcss 使用，作用是可以帮助我们为 CSS 增加上不同的浏览器前缀。 2、JavaScript 部分 2.1 闭包 问题：解释一下什么是闭包？以及闭包解决了什么问题？ 分析：闭包的问题一直是在前端方面非常被关注的问题，这个问题作为面试题经久不衰 解答： 什么是闭包？ 闭包就是能够读取其他函数内部变量的=一个函数。通常情况下，我们会在一个函数中，去创建另外一个函数，然后通过新创建的这个函数来访问上层函数的局部变量，被访问到的局部变量会始终保存在内存之中。 2.2 原型与原型链 原型与原型链分别是什么？有什么特点？ 分析：原型和原型链的问题和闭包一样，也是面试被问到频率很高的一个问题。 解答： 每个函数都有一个 prototype 属性，这个属性会指向一个对象，就是通过调用该构造函数而创建的实例的原型，可以通过实例对象的 __proto__ 来访问到这个原型对象。 实例在创建时，就会默认关联原型，并且会从原型继承属性。 而每一个原型对象又都会存在一个 constructor 属性，这个属性会指向关联的这个构造函数。 当访问一个实例对象的属性时，如果说这个实例对象中没有这个属性，那么 js 引擎就会去该实例对象的原型对象中去找 如果属性在原型对象中也找不到，那么就会去原型的原型中去找，一直到找到最上层的原型，也就是 Object 为止。 2.3 this 对象 问题：谈谈对 This 对象的理解 分析：在 JS 中一直存在着一个本不应该存在的问题，那就是关于 this 指向的问题。关于 this 的指向在其他的语言（比如java)中是非常明确的。但是因为 js 的历史问题，导致 this 的指向一直是一个重难点 解答： this 总是指向函数的直接调用者（而非间接调用者） 如果有 new 关键字，this 指向 new 出来的那个对象 在事件中，this 指向触发这个事件的对象，特殊的是，IE 中的 attachEvent 中的 this 总是指向全局对象 Window 2.4 webpack 问题：谈谈你对webpack的看法 分析：对于中级工程师来说，webpack的内容一般不会问的很深，因为除非是高软或者是架构师，否则一般不会去配置webpack，但是这并不是你可能光明正大说不会的理由 解答： webpack 是一个 JS 的模块打包工具，可以使用 webpack 管理项目中的 JS 模块依赖。 Webpack 提供了一些默认的配置，比如说 devServer，我们可以利用 devServer 来快速启动一个开发时的web服务器。 并且因为 webpack 默认只能打包 js 文件，所以 webpack 额外提供了 loader 的概念，我们可以使用 loader 来预处理一些文件，并且可以打包除了 JS 之外的任何静态资源。 另外 webpack 还提供了插性的概念，我们可以使用很多的插件来在 webpack 上做一些辅助性的工作，比如 HtmlWebpackPlugin 这种用来创建 HTML 文件的插件。 2.5 promise 问题：谈谈你对 promise 的了解 分析：promise是目前开发中经常会用到的一个知识点，所以它是必须要掌握的 解答： 首先 promise 是 ES6 提出的一个异步编程解决方案。相比于传统的容易陷入回调地狱的异步回调方案来说，promise 会让异步的操作变得更加的优雅。 ES6 规定 promise 是一个构造函数，所以我们需要通过 new 关键字来生成一个 promise 的实例对象。 Promise 的构造函数接受一个函数作为参数，函数中的代码在 new primise 的时候，会立刻执行，我们可以在这里去执行异步代码的操作。并且该函数默认存在两个参数分别是 resolve和reject，这两个参数也是函数，用来标记异步执行的状态。 比如 resolve，当 promise 的异步操作完成的时候，我们可以调用 resolve 函数，来标记当前的异步操作已经完成了。 而 reject，是在异步操作失败的时候进行调用，用来标记当前的异步操作失败了。 这些标记的状态我们可以通过 promise 实例对象的 .then 方法和 .catch 方法接收。其中，.then 方法是异步完成的回调，.catach 是异步失败的回调。 2.6 null、undefined 问题：null和undefined的区别是什么？ 分析：这个问题多出现在笔试中，是考察工程师基础知识掌握程度的一个很好的题目 解答： undefined ：表示不存在这个值，是一个变量的最原始状态 null ：是一个具体的值，只不过这个值是一个空值而已 2.7 同步与异步 问题：什么是同步？什么是异步？他们的区别是什么？ 分析：对于任何一门编程语言来说，同步和异步的概念永远都是一个重点问题 解答： 同步：线程被阻塞，等待任务返回结果。 异步：异步就是线程不会被阻塞，任务完成通知 JS 引擎。 2.8 event loop 问题：什么是 EventLoop ? 分析：询问 EventLoop，主要就是为了询问JS的一个线程机制，因为你只有了解了 JS 的单线程机制，你才可以理解什么是 EventLoop 解答： JavaScript 语言的一大特点就是单线程，也就是说，同一时间只能做一件事。 单线程就意味着，所有的任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不等不一直等着。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能行后一个任务。 异步任务指的是，不进入主线程、而进入&quot;任务队列”(task queue)的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 而当主线程中的任务完成之后，主线程从&quot;任务队列&quot;中读取事件，这个过程是循环不断的，这就是 Event Loop (事件循环)。 2.9 bind、call、apply 问题：bind、call、apply的区别？ 分析：这三个方法在 react 的项目中会使用的非常的多，并且因为这三个方法会牵扯到 this 的指向问题，所以在面试中被问到的概率会非常大 解答： call 和 apply 都是为了解决改变 this 的指向，作用都是相同的，只是传参的方式不同。 除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。 bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。 2.10 typeof 与 instanceof 问题：typeof 与 instanceof 的区别？ 分析：typeof 与 instanceof 都是在项目中会经常使用到的方法，并且这两个方法的作用经常容易搞混，所以在面试中，这两个方法会经常被问到 解答： typeof：会返回一个值的类型。对于基本数据类型，除了 null 都可以返回正确的类型。而对于 null 则会返回 object，这是 js 的一个 bug 。而对于引用数据类型来说，除了函数之外，其他的都会返回 object instanceof：它是用来判断一个对象是否是另一个对象的实例，注意它只能用来判断对象 3、Vue 部分 3.1 Vue 生命周期 问题：请说一下对 Vue 生命周期的理解 分析：如果要使用 Vue 来开发项目，那么 Vue 生命周期部分，是必须要掌握的一个内容 解答： Vue 实例从创建到销毁的过程，就是生命周期。 总共分为 8 个阶段，分别为：创建前/后，载入前/后，更新前/后，销毁前/后 3.2 双向绑定的原理 问题：请说一下 Vue 实现双向数据绑定的原理 分析：如果你的简历中有关于 Vue 的内容，那么 Vue 实现双向数据绑定的原理是有很大概率会被问到的一个知识点 解答： vue 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式。 数据劫持：通过 Object.defineProperty() 来劫持特对象各个属性的 setter，getter。 发布者-订阅者模式：在数据变动时发布者发布消息给订阅者，触发相应监听回调。 总的来说：当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 监听它们的 getter/setter 方法。这样，它们就可以让 Vue 追踪依赖，在对象的属性被==访问(get)和修改(set)==时通知变化。 3.3 参数传递 问题：请说一下 Vue 中如何实现参数的传递？ 分析：Vue 中各个组件之间的参数传递，是使用Vue进行项目开发时大慨率会用到的一个知识点 解答： 父组件给子组件传值：子组件通过 pops 属性接受数据。 子组件给父组件传值：子组件通过 $emit 方法传递参数。 兄弟组件传值：对于兄弟组件之间传值来说，兄弟组件之间其实没有任何的相互依赖关系，也就是说他们之间其实没有关系。而对于没有关系的两个组件，如果想要进行数据传递，那么就需要有一个第三方。通过这个第三方来为两个没有关系的组件建立关系。目前比较通用的方式，主要有两种： 一个是 eventBus 方案，建立一个事件中心，通过它传递事件来进行数据传递。 第二个就是通过 vuex 来进行数据共享。 3.4 路由 VueRouter 问题：请说一下 Vue 的路由实现：hash 模式和 history 模式 分析：这个问题对于初、中级工程师来说被问到主要是一个加分项，因为路由模式在进行项目开发的时候所产生的影响比较有限，更大的影响是在项目部署之后的生产环境中 解答： hash 模式：是vue-router的默认模式使用哈希，URL 中会出现 # 号字符， # 以及 # 后面的字符称之为哈希(hash)。特点：hash 虽然在URL中，但不被包括在HTTP请求中。 history 模式：国内线上项目使用的比较多的还是 history 模式，这种模式下 URL 中不会存在 # 这种难看的字符。不过这种模式下，需要后台进行配合，因为 Vue 打包的项目通常是一个单页的应用，也就是任何的 URL 其实指向的都是一个HTML文件，所以我们需要在 apache 或者 nginx 中进行配置，当 URL 匹配不到资源时，指向同一个 html 页面的配置。 3.5 KeepAlive 问题：&lt;keep-alive&gt;&lt;\\keep-alive&gt; 的作用是什么？ 分析：keepAlive 是构建公司级项目时经常会使用到的一个知识点 解答： KeepAlive 的作用：&lt;keep-alive&gt;&lt;/keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，住要用于保留组件状态或避免重新渲染。 4、总结 目的：让大家可以针对每一个技术问题，以一种正确的方式，表达出自己心中对这个问题的理解。 其他前端面试题整理：https://interview.poetries.top/ ","link":"https://blog.zhawenwen.cn/post/24_js_interview_001/"},{"title":"ESP32cam系列教程003：ESP32cam实现远程 HTTP_OTA 自动升级","content":" 1.什么是 OTA 2. ESP32cam HTTP_OTA 本地准备 2.1 HTTP OTA 升级原理 2.2 开发板本地基准程序（程序版本：1_0_0） 2.3 开发板升级程序（程序版本：1_0_1） 2.4 本地 HTTP_OTA 升级测试 2.4.1 本地运行一个 HTTP 服务 2.4.2 替换远程链接并将要升级的程序打包成 .bin 文件 2.4.3 替换远程链接并烧录基准程序（版本为：1_0_0 的程序）测试升级是否成功 3. HTTP_OTA 升级展望 3.1 后期版本更新可通过 HTTP_OTA 实现 3.2 借助网络云平台实现远程 HTTP_OTA 升级 本教程是 ESP32cam 的系列教程之三，使用 Arduino IDE 对 ESP32cam 开发板进行开发。 本教程代码同样使用与其他 ESP32 开发板。 1.什么是 OTA OTA 即空中下载技术（Over-the-Air Technology），其可以安全方便地升级设备的固件或软件。远程升级还可以大大降低成本，节省资源，它已成为物联网设备和产品制造商的关键技术之一。 ESP32 开发板支持 3 种 OTA 方式： Arduino IDE ：主要用于软件开发阶段，实现不接线固件烧录 Web_OTA：通过 Web 浏览器手动提供应用程序更新模块 HTTP_OTA：固件存放到 http 服务器端，设备自动判断是否需要联网下载固件升级 本文主要介绍：HTTP_OTA 的原理与实现。 2. ESP32cam HTTP_OTA 本地准备 2.1 HTTP OTA 升级原理 本地程序在开机连接 WIFI 后发送 http 请求获取远程服务器中的升级 json 文件。 通过对比 json 中的远程版本信息与本地的版本信息判断是否一致。 若远程版本信息与本地版本不一致，则本地需要更新程序。 通过 json 中的版本信息在远程服务器中拉取需要更新的程序的 .bin 文件。 依据下载下来的 .bin 自动完成版本的升级，然后自动重启开发板。 重复第一步获取远程 json 文件判断是否需要更新。 2.2 开发板本地基准程序（程序版本：1_0_0） 本地 1_0_0 版本程序主要内容如下： 当前版本（非常重要，升级依据） 远程升级的 json 链接与远程固件的文件夹链接 获取并解析 json 的函数 httpGETRequest 依据 json 判断是否需要更新的函数 isOrNotNeedUpdate 以及其他基础信息组成 #include &lt;WiFi.h&gt; #include &lt;HTTPClient.h&gt; #include &lt;ESP32httpUpdate.h&gt; #include &lt;Arduino_JSON.h&gt; /**********根据实际修改**********/ const char* wifi_ssid = &quot;TP-LINK_1760&quot;; // WIFI名称，区分大小写，不要写错 const char* wifi_password = &quot;987654321&quot;; // WIFI密码 // 特别重要，升级依据！！！ // 设置当前代码版本 格式 1_0_0 char* version = &quot;1_0_0&quot;; //远程固件链接，只支持http const char* baseUpdateUrl = &quot;http://example.cn/esp32/&quot;; const char* updateJson = &quot;http://example.cn/esp32/esp32_update.json&quot;; // esp32_update.json // { // &quot;version&quot;:&quot;1_0_1&quot; // } /**********根据实际修改**********/ int need_ota_update = 0; int i = 0; String jsonBuffer; // 获取远程 json 升级文件 String httpGETRequest(const char* serverName) { WiFiClient client; HTTPClient http; String payload = &quot;&quot;; //连接目标网址 http.begin(client, serverName); //发送HTTP站点请求 int httpCode = http.GET(); if (httpCode &gt; 0) { Serial.printf(&quot;[HTTP] GET... code: %d\\n&quot;, httpCode); payload = http.getString(); } else { Serial.printf(&quot;[HTTP] GET... failed, error: %s\\n&quot;, http.errorToString(httpCode).c_str()); } http.end(); //关闭连接 //返回获得的数据用于Json处理 return payload; } // 依据json文件中版本号与本地版本号，判断是否需要进行更新 void isOrNotNeedUpdate(){ // 获取远程的升级 json ，判断内部版本与本地是否相同，判断是否需要升级 jsonBuffer = httpGETRequest(updateJson); Serial.println(jsonBuffer); //将解析的Json对象值储存在Jsonu缓冲区中 JSONVar myObject = JSON.parse(jsonBuffer); Serial.println(myObject); // Serial.println(myObject[&quot;version&quot;]); const char* ota_version = myObject[&quot;version&quot;]; // Serial.println(ota_version); Serial.println(&quot;---&quot;); Serial.print(&quot;远程版本： &quot;); Serial.println(ota_version); Serial.print(&quot;本地版本： &quot;); Serial.println(version); // char * 与 const char * 比较 // 判断远程版本与本地版本是否相同 if (String(version) == String(ota_version)) { need_ota_update = 0; Serial.println(&quot;无需升级。。。&quot;); } else { need_ota_update = 1; Serial.println(&quot;需要升级。。。&quot;); Serial.print(&quot;OTA 升级地址为：&quot;); // 升级的完整链接， 例如：http://example.cn/esp32/esp32_1_0_1.bin String fullUpdateUrl = String(baseUpdateUrl) + &quot;esp32_&quot; + ota_version + &quot;.bin&quot;; Serial.println(String(fullUpdateUrl)); // 获取远程 bin 文件进行升级 t_httpUpdate_return ret = ESPhttpUpdate.update(fullUpdateUrl); Serial.println(ret); switch (ret) { case HTTP_UPDATE_FAILED: Serial.printf(&quot;HTTP_UPDATE_FAILED Error (%d): %s\\n&quot;, ESPhttpUpdate.getLastError(), ESPhttpUpdate.getLastErrorString().c_str()); break; case HTTP_UPDATE_NO_UPDATES: Serial.println(&quot;HTTP_UPDATE_NO_UPDATES&quot;); break; case HTTP_UPDATE_OK: Serial.println(&quot;HTTP_UPDATE_OK&quot;); break; default: Serial.println(ret); } // version=(char *)ota_version; } need_ota_update = 0; } void setup() { Serial.begin(115200); //波特率115200 Serial.print(&quot;Connection WIFI&quot;); WiFi.begin(wifi_ssid, wifi_password); //连接wifi while (WiFi.status() != WL_CONNECTED) { //等待连接wifi delay(500); Serial.print(&quot;.&quot;); } Serial.println(&quot;&quot;); // 调用判断是否需要升级函数 isOrNotNeedUpdate(); } void loop() { // 主程序 Serial.println(i); i++; delay(2000); } 2.3 开发板升级程序（程序版本：1_0_1） 本测试升级程序如下，仅仅在程序版本与主程序中做了调整，以便更清楚的看出是否OTA升级成功。 #include &lt;WiFi.h&gt; #include &lt;HTTPClient.h&gt; #include &lt;ESP32httpUpdate.h&gt; #include &lt;Arduino_JSON.h&gt; /**********根据实际修改**********/ const char* wifi_ssid = &quot;TP-LINK_1760&quot;; // WIFI名称，区分大小写，不要写错 const char* wifi_password = &quot;987654321&quot;; // WIFI密码 // 特别重要，升级依据！！！ // 设置当前代码版本 格式 1_0_0 char* version = &quot;1_0_1&quot;; //远程固件链接，只支持http const char* baseUpdateUrl = &quot;http://example.cn/esp32/&quot;; const char* updateJson = &quot;http://example.cn/esp32/esp32_update.json&quot;; // esp32_update.json // { // &quot;version&quot;:&quot;1_0_1&quot; // } /**********根据实际修改**********/ int need_ota_update = 0; int i = 0; String jsonBuffer; // 获取远程 json 升级文件 String httpGETRequest(const char* serverName) { WiFiClient client; HTTPClient http; String payload = &quot;&quot;; //连接目标网址 http.begin(client, serverName); //发送HTTP站点请求 int httpCode = http.GET(); if (httpCode &gt; 0) { Serial.printf(&quot;[HTTP] GET... code: %d\\n&quot;, httpCode); payload = http.getString(); } else { Serial.printf(&quot;[HTTP] GET... failed, error: %s\\n&quot;, http.errorToString(httpCode).c_str()); } http.end(); //关闭连接 //返回获得的数据用于Json处理 return payload; } // 依据json文件中版本号与本地版本号，判断是否需要进行更新 void isOrNotNeedUpdate(){ // 获取远程的升级 json ，判断内部版本与本地是否相同，判断是否需要升级 jsonBuffer = httpGETRequest(updateJson); Serial.println(jsonBuffer); //将解析的Json对象值储存在Jsonu缓冲区中 JSONVar myObject = JSON.parse(jsonBuffer); Serial.println(myObject); // Serial.println(myObject[&quot;version&quot;]); const char* ota_version = myObject[&quot;version&quot;]; // Serial.println(ota_version); Serial.println(&quot;---&quot;); Serial.print(&quot;远程版本： &quot;); Serial.println(ota_version); Serial.print(&quot;本地版本： &quot;); Serial.println(version); // char * 与 const char * 比较 // 判断远程版本与本地版本是否相同 if (String(version) == String(ota_version)) { need_ota_update = 0; Serial.println(&quot;无需升级。。。&quot;); } else { need_ota_update = 1; Serial.println(&quot;需要升级。。。&quot;); Serial.print(&quot;OTA 升级地址为：&quot;); // 升级的完整链接， 例如：http://example.cn/esp32/esp32_1_0_1.bin String fullUpdateUrl = String(baseUpdateUrl) + &quot;esp32_&quot; + ota_version + &quot;.bin&quot;; Serial.println(String(fullUpdateUrl)); // 获取远程 bin 文件进行升级 t_httpUpdate_return ret = ESPhttpUpdate.update(fullUpdateUrl); Serial.println(ret); switch (ret) { case HTTP_UPDATE_FAILED: Serial.printf(&quot;HTTP_UPDATE_FAILED Error (%d): %s\\n&quot;, ESPhttpUpdate.getLastError(), ESPhttpUpdate.getLastErrorString().c_str()); break; case HTTP_UPDATE_NO_UPDATES: Serial.println(&quot;HTTP_UPDATE_NO_UPDATES&quot;); break; case HTTP_UPDATE_OK: Serial.println(&quot;HTTP_UPDATE_OK&quot;); break; default: Serial.println(ret); } // version=(char *)ota_version; } need_ota_update = 0; } void setup() { Serial.begin(115200); //波特率115200 Serial.print(&quot;Connection WIFI&quot;); WiFi.begin(wifi_ssid, wifi_password); //连接wifi while (WiFi.status() != WL_CONNECTED) { //等待连接wifi delay(500); Serial.print(&quot;.&quot;); } Serial.println(&quot;&quot;); // 调用判断是否需要升级函数 isOrNotNeedUpdate(); } void loop() { // 主程序 Serial.println(i); Serial.println(&quot;OTA 升级成功&quot;); i++; delay(2000); } 2.4 本地 HTTP_OTA 升级测试 2.4.1 本地运行一个 HTTP 服务 这里使用 vscode 进行： 用 vscode 打开一个空白文件夹 在文件夹中新建目录 esp32，文件 index.html ，目录下新建文件 esp32_update.json esp32_update.json 中内容是 {&quot;version&quot;:&quot;1_0_1&quot;} ,表明当前远程的版本为 1_0_1 index.html 中为标准html结构文件 在 index.html 界面中右键&gt;Open with Live Server 打开 替换 127.0.0.1 为本地 192.168.1.XXX 并拼接 /esp32/esp32_update.json ,如下图所示 2.4.2 替换远程链接并将要升级的程序打包成 .bin 文件 将 arduino IDE 中的程序的远程链接替换成本地 HTTP 服务器链接 工具中 开发板和 Partition Scheme 选择如下图： 项目中选择导出已编译的二进制文件，导出的二进制文件在同级目录下。 将导出的 .bin 文件重命名为 esp32_1_0_x.bin 样式，并复制到 2.4.1 节中的 esp32目录中，保证使用 http://192.168.1.x/esp32/esp32_1_0_x.bin 能够下载到该文件。 2.4.3 替换远程链接并烧录基准程序（版本为：1_0_0 的程序）测试升级是否成功 将 arduino IDE 中的程序的远程链接替换成本地 HTTP 服务器链接 将 2.4.1 节中的 esp32_update.json 内部版本改为 1_0_0 ，保证一开始不升级。 将程序烧录进 esp32 开发板中。然后打开串口监视器 串口调试器中显示不需要升级 将 2.4.1 节中的 esp32_update.json 内部版本改为 1_0_1 ，然后重启开发板。 由上图可知，开发板自动判断是否需要升级并自动OTA升级成功。 3. HTTP_OTA 升级展望 3.1 后期版本更新可通过 HTTP_OTA 实现 通过第二节可知，可以通过 HTTP_OTA 实现 esp32 开发板的隔空升级，这样可以在一台设备上测试好了程序后，上传 .bin 文件到第 2.4.1 节中的 HTTP 服务器文件夹中，实现其他开发板批量升级。 3.2 借助网络云平台实现远程 HTTP_OTA 升级 第 2.4 节是使用本地 HTTP 服务器进行升级的，我们也可以使用云服务厂商的对象云存储服务，将需要升级的 .bin 文件与 esp32_update.json 放到云服务厂商的对象云存储服务中，使用提供的公网域名替换程序代码中的远程固件连接，真正实现远程 OTA 快速自动升级服务。 注意： 本地 HTTP_OTA 升级时，本机电脑需要和 esp32 开发板连在同一个网络下，否则 esp32 开发板无法访问固件地址。 使用云服务厂商的对象云存储服务，对象云存储需要设置禁止缓存，否则可能会获取之前缓存的版本而不是最新版，导致不必要的错误。 ","link":"https://blog.zhawenwen.cn/post/esp32cam_http_ota/"},{"title":"ESP32cam系列教程002：ESP32cam通过MQTT协议上传图片数据到阿里云IOT平台","content":" 1. ESP32cam通过MQTT协议上传图片数据到阿里云平台 1.1 阿里云物联网平台相关配置 1.2 esp32cam 通过 mqtt 协议上传图片到阿里云IOT平台 2. 从阿里云IOT平台获取图片数据并保存到本地 2.1 阿里云物联网平台相关配置 2.2 将阿里云平台中的数据通过AMQP实时拉取到本地 2.2.1 Node.js 获取阿里云物联网平台图片数据 2.2.2 Python 获取阿里云物联网平台图片数据（仅供参考） 1. ESP32cam通过MQTT协议上传图片数据到阿里云平台 1.1 阿里云物联网平台相关配置 进入阿里云物联网平台创建公共实例 阿里云物联网平台网址：https://iot.console.aliyun.com/ 选择 华东2（上海）节点，开通公共实例。 创建产品与设备 创建产品： 在产品中的功能定义中创建功能模块用来存储图片文本： 创建设备： 在设备的物模型数据中就有 img 的模块： 自此，阿里云物联网平台的准备工作就已全部完成。 1.2 esp32cam 通过 mqtt 协议上传图片到阿里云IOT平台 注：本人使用 Arduino IDE 开发 ESP32cam 程序，如何使用 Arduino IDE 开发 ESP32 程序请参考本人其他博客。博客：Arduino 配置 ESP32 开发环境 在 Arduino IDE 中新建一个项目，需要有三个文件： send_img_aliyun.ino aliyunmqtt.cpp aliyunmqtt.h 其中 send_img_aliyun.ino 为上传图片数据到阿里云物联网平台的主程序，aliyunmqtt.cpp 与 aliyunmqtt.h 是连接阿里云物联网平台的校验程序。 仅需修改 send_img_aliyun.ino 中 WIFI 账号与密码 和 阿里云物联网平台三元组（见下图）即可，aliyunmqtt.cpp 与 aliyunmqtt.h 文件无需修改任何内容。由于 ESP32cam 性能问题， send_img_aliyun.ino 中将一个图片分为多段进行传输，每段为 800，详见代码。 这里直接给出代码： send_img_aliyun.ino : // send_img_aliyun.ino #include &lt;WiFi.h&gt; #include &lt;Wire.h&gt; #include &lt;PubSubClient.h&gt; #include &lt;ArduinoJson.h&gt; // #include &quot;aliyun_mqtt.h&quot; #include &quot;aliyunmqtt.h&quot; #include &quot;esp_camera.h&quot; #include &lt;SPIFFS.h&gt; #include &quot;FS.h&quot; // SD Card ESP32 #include &quot;SD_MMC.h&quot; // SD Card ESP32 #include &quot;soc/soc.h&quot; // Disable brownour problems #include &quot;soc/rtc_cntl_reg.h&quot; // Disable brownour problems #include &quot;driver/rtc_io.h&quot; #include &lt;EEPROM.h&gt; // 内存存储相关配置 #define EEPROM_SIZE 1 int pictureNumber = 0; String msg; int buttonState = 0; int btnHold = 0; // #define SENSOR_PIN 10 //以下信息需要自己修改 #define WIFI_SSID &quot;TP-LINK_1760&quot; //替换自己的WIFI #define WIFI_PASSWD &quot;987654321&quot; //替换自己的WIFI密码 // 阿里云物联网 三元组 #define PRODUCT_KEY &quot;k0xxxxxIM&quot; //替换自己的PRODUCT_KEY #define DEVICE_NAME &quot;esp001_001&quot; //替换自己的DEVICE_NAME #define DEVICE_SECRET &quot;589xxxxxxxxxxxxxxxxxxxe0f&quot; //替换自己的DEVICE_SECRET \\ //以下不需修改 #define ALINK_BODY_FORMAT &quot;{\\&quot;id\\&quot;:\\&quot;123\\&quot;,\\&quot;version\\&quot;:\\&quot;1.0\\&quot;,\\&quot;method\\&quot;:\\&quot;%s\\&quot;,\\&quot;params\\&quot;:%s}&quot; #define ALINK_TOPIC_PROP_POST &quot;/sys/&quot; PRODUCT_KEY &quot;/&quot; DEVICE_NAME &quot;/thing/event/property/post&quot; #define ALINK_TOPIC_PROP_POSTRSP &quot;/sys/&quot; PRODUCT_KEY &quot;/&quot; DEVICE_NAME &quot;/thing/event/property/post_reply&quot; #define ALINK_TOPIC_PROP_SET &quot;/sys/&quot; PRODUCT_KEY &quot;/&quot; DEVICE_NAME &quot;/thing/service/property/set&quot; #define ALINK_METHOD_PROP_POST &quot;thing.event.property.post&quot; #define ALINK_TOPIC_DEV_INFO &quot;/ota/device/inform/&quot; PRODUCT_KEY &quot;/&quot; DEVICE_NAME &quot;&quot; #define ALINK_VERSION_FROMA &quot;{\\&quot;id\\&quot;: 123,\\&quot;params\\&quot;: {\\&quot;version\\&quot;: \\&quot;%s\\&quot;}}&quot; unsigned long lastMs = 0; // 测试 初始温度 int i = 15; WiFiClient espClient; PubSubClient mqttClient(espClient); //CAMERA_MODEL_AI_THINKER类型摄像头的引脚定义 #define PWDN_GPIO_NUM 32 #define RESET_GPIO_NUM -1 #define XCLK_GPIO_NUM 0 #define SIOD_GPIO_NUM 26 #define SIOC_GPIO_NUM 27 #define Y9_GPIO_NUM 35 #define Y8_GPIO_NUM 34 #define Y7_GPIO_NUM 39 #define Y6_GPIO_NUM 36 #define Y5_GPIO_NUM 21 #define Y4_GPIO_NUM 19 #define Y3_GPIO_NUM 18 #define Y2_GPIO_NUM 5 #define VSYNC_GPIO_NUM 25 #define HREF_GPIO_NUM 23 #define PCLK_GPIO_NUM 22 static camera_config_t camera_config = { .pin_pwdn = PWDN_GPIO_NUM, .pin_reset = RESET_GPIO_NUM, .pin_xclk = XCLK_GPIO_NUM, .pin_sscb_sda = SIOD_GPIO_NUM, .pin_sscb_scl = SIOC_GPIO_NUM, .pin_d7 = Y9_GPIO_NUM, .pin_d6 = Y8_GPIO_NUM, .pin_d5 = Y7_GPIO_NUM, .pin_d4 = Y6_GPIO_NUM, .pin_d3 = Y5_GPIO_NUM, .pin_d2 = Y4_GPIO_NUM, .pin_d1 = Y3_GPIO_NUM, .pin_d0 = Y2_GPIO_NUM, .pin_vsync = VSYNC_GPIO_NUM, .pin_href = HREF_GPIO_NUM, .pin_pclk = PCLK_GPIO_NUM, .xclk_freq_hz = 20000000, .ledc_timer = LEDC_TIMER_0, .ledc_channel = LEDC_CHANNEL_0, .pixel_format = PIXFORMAT_JPEG, // .frame_size = FRAMESIZE_VGA, // FRAMESIZE_UXGA (1600 x 1200) // FRAMESIZE_QVGA (320 x 240) // FRAMESIZE_CIF (352 x 288) // FRAMESIZE_VGA (640 x 480) // FRAMESIZE_SVGA (800 x 600) // FRAMESIZE_XGA (1024 x 768) // FRAMESIZE_SXGA (1280 x 1024) .frame_size = FRAMESIZE_QVGA, .jpeg_quality = 10, // 图像质量（jpeg_quality) 可以是 0 到 63 之间的数字。数字越小意味着质量越高 .fb_count = 1, }; void init_wifi(const char *ssid, const char *password) { WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { Serial.println(&quot;WiFi does not connect, try again ...&quot;); delay(500); } Serial.println(&quot;Wifi is connected.&quot;); Serial.println(&quot;IP address: &quot;); Serial.println(WiFi.localIP()); } void mqtt_callback(char *topic, byte *payload, unsigned int length) { Serial.print(&quot;Message arrived [&quot;); Serial.print(topic); Serial.print(&quot;] &quot;); payload[length] = '\\0'; Serial.println((char *)payload); if (strstr(topic, ALINK_TOPIC_PROP_SET)) { StaticJsonBuffer&lt;100&gt; jsonBuffer; JsonObject &amp;root = jsonBuffer.parseObject(payload); if (!root.success()) { Serial.println(&quot;parseObject() failed&quot;); return; } } } void mqtt_check_connect() { while (!mqttClient.connected()) // { while (connect_aliyun_mqtt(mqttClient, PRODUCT_KEY, DEVICE_NAME, DEVICE_SECRET)) { Serial.println(&quot;MQTT connect succeed!&quot;); //client.subscribe(ALINK_TOPIC_PROP_POSTRSP); mqttClient.subscribe(ALINK_TOPIC_PROP_SET); Serial.println(&quot;subscribe done&quot;); } } } void mqtt_interval_post() { // static int i=0; char param[512]; char jsonBuf[1024]; sprintf(jsonBuf, &quot;{\\&quot;id\\&quot;:\\&quot;1189401707\\&quot;,\\&quot;version\\&quot;:\\&quot;1.0.0\\&quot;,\\&quot;method\\&quot;:\\&quot;%s\\&quot;,\\&quot;params\\&quot;:{\\&quot;img\\&quot;:\\&quot;END\\&quot;}}&quot;); Serial.println(jsonBuf); mqttClient.publish(ALINK_TOPIC_PROP_POST, jsonBuf); Serial.println(&quot;发送结束符&quot;); delay(1000); } // 摄像头、SD卡与 SPIFFS 初始化 esp_err_t camera_init() { //initialize the camera esp_err_t err = esp_camera_init(&amp;camera_config); if (err != ESP_OK) { Serial.println(&quot;Camera Init Failed&quot;); return err; } sensor_t *s = esp_camera_sensor_get(); //initial sensors are flipped vertically and colors are a bit saturated if (s-&gt;id.PID == OV2640_PID) { // s-&gt;set_vflip(s, 1);//flip it back // s-&gt;set_brightness(s, 1);//up the blightness just a bit // s-&gt;set_contrast(s, 1); } Serial.println(&quot;Camera Init OK!&quot;); return ESP_OK; } void sd_init(void) { //SD card init if (!SD_MMC.begin()) { Serial.println(&quot;Card Mount Failed&quot;); return; } uint8_t cardType = SD_MMC.cardType(); if (cardType == CARD_NONE) { Serial.println(&quot;No SD_MMC card attached&quot;); return; } } void SPIFFS_init() { //初始化SPIFFS if (!SPIFFS.begin(true)) { Serial.println(&quot;An Error has occurred while mounting SPIFFS&quot;); } else { delay(500); Serial.println(&quot;SPIFFS mounted successfully&quot;); } //Turn-off the 'brownout detector' WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); } // 摄像头、SD卡与 SPIFFS 初始化 end void setup() { Serial.begin(115200); Serial.println(&quot;程序 Start&quot;); init_wifi(WIFI_SSID, WIFI_PASSWD); camera_init(); sd_init(); SPIFFS_init(); mqttClient.setCallback(mqtt_callback); } // the loop function runs over and over again forever void loop() { // 程序开始拍照并保存 Serial.print(&quot;进行拍照\\n&quot;); camera_fb_t *fb = esp_camera_fb_get(); if (!fb) { Serial.print(&quot;Camera capture failed&quot;); return; } else { EEPROM.begin(EEPROM_SIZE); pictureNumber = EEPROM.read(0) + 1; // Path where new picture will be saved in SD Card String path = &quot;/picture&quot; + String(pictureNumber) + &quot;.jpg&quot;; fs::FS &amp;fs = SD_MMC; Serial.printf(&quot;文件名字: %s\\n&quot;, path.c_str()); File file = fs.open(path.c_str(), FILE_WRITE); if (!file) { Serial.println(&quot;Failed to open file in writing mode&quot;); } else { file.write(fb-&gt;buf, fb-&gt;len); // payload (image), payload length Serial.println(fb-&gt;len); Serial.print(&quot;抓拍成功并保存\\n&quot;); Serial.printf(&quot;保存路径: %s\\n\\n&quot;, path.c_str()); EEPROM.write(0, pictureNumber); EEPROM.commit(); } String a1 = &quot;{\\&quot;id\\&quot;:\\&quot;1189401707\\&quot;,\\&quot;version\\&quot;:\\&quot;1.0.0\\&quot;,\\&quot;method\\&quot;:\\&quot;123\\&quot;,\\&quot;params\\&quot;:{\\&quot;img\\&quot;:\\&quot;&quot;; String a2; String a3 = &quot;\\&quot;}}&quot;; char data[4104]; // 将图片分为不超过 800 通过 MQTT 发送出去 for (int i = 0; i &lt; fb-&gt;len; i++) { sprintf(data, &quot;%02X&quot;, *(fb-&gt;buf + i)); a2 += data; if (a2.length() == 800) { String a4 = a1 + a2; String a = a4 + a3; char jsonBuf[a.length() + 1]; for (int i = 0; i &lt; a.length(); i++) jsonBuf[i] = a[i]; jsonBuf[a.length()] = '\\0'; Serial.println(jsonBuf); mqttClient.publish(ALINK_TOPIC_PROP_POST, jsonBuf); a2 = &quot;&quot;, a = &quot;&quot;, a4 = &quot;&quot;; // ms delay(200); } } if (a2.length() &gt; 0) { String a4 = a1 + a2; String a = a4 + a3; char jsonBuf[a.length() + 1]; for (int i = 0; i &lt; a.length(); i++) jsonBuf[i] = a[i]; jsonBuf[a.length()] = '\\0'; Serial.println(jsonBuf); mqttClient.publish(ALINK_TOPIC_PROP_POST, jsonBuf); a2 = &quot;&quot;, a = &quot;&quot;, a4 = &quot;&quot;; } // 将图片分为不超过 800 通过 MQTT 发送出去 end // char endBuf[100]; sprintf(endBuf, &quot;{\\&quot;id\\&quot;:\\&quot;1189401707\\&quot;,\\&quot;version\\&quot;:\\&quot;1.0.0\\&quot;,\\&quot;method\\&quot;:\\&quot;123\\&quot;,\\&quot;params\\&quot;:{\\&quot;img\\&quot;:\\&quot;END\\&quot;}}&quot;); Serial.println(endBuf); mqttClient.publish(ALINK_TOPIC_PROP_POST, endBuf); Serial.println(&quot;发送结束符&quot;); } Serial.println(&quot;图片发送完成了......&quot;); delay(1000); // 图片发送结束后发送 END if (millis() - lastMs &gt;= 10000) { lastMs = millis(); mqtt_check_connect(); // Post interval 间隔 // mqtt_interval_post(); } mqttClient.loop(); unsigned int WAIT_MS = 2000; delay(WAIT_MS); // ms Serial.println(millis() / WAIT_MS); } aliyunmqtt.h : // aliyunmqtt.h /* Aliyun_mqtt.h - Library for connect to Aliyun MQTT server with authentication by product key, device name and device secret. https://www.alibabacloud.com/help/product/30520.htm */ #ifndef _ALIYUN_MATT_H #define _ALIYUN_MATT_H #include &quot;Arduino.h&quot; #include &lt;PubSubClient.h&gt; /** * Connect to Alibaba Cloud MQTT server. In connection process, it will try several times for * possible network failure. For authentication issue, it will return false at once. * * @param mqttClient: Caller provide a valid PubSubClient object (initialized with network client). * @param productKey: Product Key, get from Alibaba Cloud Link Platform. * @param deviceName: Device Name, get from Alibaba Cloud Link Platform. * @param deviceSecret: Device Secret, get from Alibaba Cloud Link Platform. * * @param region: Optional region, use &quot;cn-shanghai&quot; as default. It can be &quot;us-west-1&quot;, * &quot;ap-southeast-1&quot; etc. Refer to Alibaba Cloud Link Platform. * * * @return true if connect succeed, otherwise false. */ extern &quot;C&quot; bool connect_aliyun_mqtt( PubSubClient &amp;mqttClient, const char *productKey, const char *deviceName, const char *deviceSecret, const char *region = &quot;cn-shanghai&quot;); /** * Two new added APIs are designed for devices with limited resource like Arduino UNO. * Since it is hard to calculate HMAC256 on such devices, the calculation can be done externally. * * These two APIs should be used together with external HMAC256 calculation tools, e.g. * http://tool.oschina.net/encrypt?type=2 * They can be used together to replace connectAliyunMQTT on resource-limited devices. */ /** * This API should be called in setup() phase to init all MQTT parameters. Since HMAC256 * calculation is executed extenrally, a fixed timestamp string should be provided, such * as &quot;23668&quot; etc. The same timestamp string is also used to calculate HMAC256 result. * * Other params are similar to them in connectAliyunMQTT. */ extern &quot;C&quot; void mqtt_prepare( const char *timestamp, const char *productKey, const char *deviceName, const char *deviceSecret, const char *region = &quot;cn-shanghai&quot;); /** * Use tools here to calculate HMAC256: http://tool.oschina.net/encrypt?type=2 * The calculated result should be defined as constants and passed when call this function. */ extern &quot;C&quot; bool connect_aliyun_mqtt_With_password(PubSubClient &amp;mqttClient, const char *password); #endif aliyunmqtt.cpp // aliyunmqtt.cpp /* Aliyun_mqtt.h - Library for connect to Aliyun MQTT server. */ // #include &quot;aliyun_mqtt.h&quot; #include &quot;aliyunmqtt.h&quot; #include &lt;SHA256.h&gt; #define MQTT_PORT 1883 #define SHA256HMAC_SIZE 32 // Verify tool: http://tool.oschina.net/encrypt?type=2 static String hmac256(const String &amp;signcontent, const String &amp;ds) { byte hashCode[SHA256HMAC_SIZE]; SHA256 sha256; const char *key = ds.c_str(); size_t keySize = ds.length(); sha256.resetHMAC(key, keySize); sha256.update((const byte *)signcontent.c_str(), signcontent.length()); sha256.finalizeHMAC(key, keySize, hashCode, sizeof(hashCode)); String sign = &quot;&quot;; for (byte i = 0; i &lt; SHA256HMAC_SIZE; ++i) { sign += &quot;0123456789ABCDEF&quot;[hashCode[i] &gt;&gt; 4]; sign += &quot;0123456789ABCDEF&quot;[hashCode[i] &amp; 0xf]; } return sign; } static String mqttBroker; static String mqttClientID; static String mqttUserName; static String mqttPassword; // call this function once void mqtt_prepare(const char *timestamp,const char *productKey, const char *deviceName,const char *deviceSecret,const char *region) { mqttBroker = productKey; mqttBroker += &quot;.iot-as-mqtt.&quot;; mqttBroker += String(region); mqttBroker += &quot;.aliyuncs.com&quot;; // Serial.println(mqttBroker); mqttUserName = deviceName; mqttUserName += '&amp;'; mqttUserName += productKey; //Serial.println(mqttUserName); mqttClientID = deviceName; // device name used as client ID mqttClientID += &quot;|securemode=3,signmethod=hmacsha256,timestamp=&quot;; mqttClientID += timestamp; mqttClientID += '|'; //Serial.println(mqttClientID); } bool connect_aliyun_mqtt_With_password(PubSubClient &amp;mqttClient, const char *password) { mqttClient.setServer(mqttBroker.c_str(), MQTT_PORT); byte mqttConnectTryCnt = 5; while (!mqttClient.connected() &amp;&amp; mqttConnectTryCnt &gt; 0) { //Serial.println(&quot;Connecting to MQTT Server ...&quot;); if (mqttClient.connect(mqttClientID.c_str(), mqttUserName.c_str(), password)) { // Serial.println(&quot;MQTT Connected!&quot;); return true; } else { byte errCode = mqttClient.state(); //Serial.print(&quot;MQTT connect failed, error code:&quot;); //Serial.println(errCode); if (errCode == MQTT_CONNECT_BAD_PROTOCOL || errCode == MQTT_CONNECT_BAD_CLIENT_ID || errCode == MQTT_CONNECT_BAD_CREDENTIALS || errCode == MQTT_CONNECT_UNAUTHORIZED) { //Serial.println(&quot;No need to try again.&quot;); break; // No need to try again for these situation } delay(3000); } mqttConnectTryCnt -= 1; } return false; } bool connect_aliyun_mqtt( PubSubClient &amp;mqttClient, const char *productKey, const char *deviceName, const char *deviceSecret, const char *region) { String timestamp = String(millis()); mqtt_prepare(timestamp.c_str(), productKey, deviceName, deviceSecret, region); // Generate MQTT Password, use deviceName as clientID String signcontent = &quot;clientId&quot;; signcontent += deviceName; signcontent += &quot;deviceName&quot;; signcontent += deviceName; signcontent += &quot;productKey&quot;; signcontent += productKey; signcontent += &quot;timestamp&quot;; signcontent += timestamp; String mqttPassword = hmac256(signcontent, deviceSecret); //Serial.print(&quot;HMAC256 data: &quot;); //Serial.println(signcontent); //Serial.print(&quot;HMAC256 key: &quot;); // Serial.println(deviceSecret); // Serial.println(mqttPassword); return connect_aliyun_mqtt_With_password(mqttClient, mqttPassword.c_str()); } 程序烧录运行结果如下图： 本地 Arduino IDE 串口显示图： 物联网平台物模型已获取数据： 注意：若Arduino IDE 串口显示正常，而物联网平台中没有获取到数据，请查看 阿里云物联网平台左侧&gt;监控运维&gt;日志服务，若日志中出现状态 460 错误，请调整本地 Arduino IDE 中引用的 PubSubClient.h 中的两个参数：MQTT_MAX_PACKET_SIZE 和 MQTT_KEEPLIVE ,分别调整为大于 1024 和大于 65 ，然后重新烧录 ESP32cam 即可解决。 自此，ESP32cam 获取图片数据存本地内存卡并通过 MQTT 协议上传阿里云物联网平台已全部完成。 2. 从阿里云IOT平台获取图片数据并保存到本地 虽然图片数据已经上传到阿里云物联网平台中存储，但平台中存储的只是图片的数据，而非图片，需要将图片数据转换成图片并在其他地方展示出来。 于是需要进行下面操作。 2.1 阿里云物联网平台相关配置 需要配置 消息转发&gt;服务端订阅： 本操作就是将 ESP32cam 上传到阿里云物联网平台中的数据转发一份到处理端，处理端通过 AMQP 获取数据并解析进行下一步操作。 2.2 将阿里云平台中的数据通过AMQP实时拉取到本地 将图片拉取到本地使用 Nodejs 和 Python 两种方式。 Node.js 程序较为完整，可将图片数据获取到并转化为图片存到本地 Python 程序仅仅获取到数据并打印出来，仅供参考。 2.2.1 Node.js 获取阿里云物联网平台图片数据 在本地运行 Nodejs 程序，通过 AMQP 实时获取 ESP32cam 上传到阿里云的图片数据组合成图片并保存到本地中。 其中部分参数配置参考： 阿里云AMQP客户端接入说明 Nodejs客户端SDK接入实例 python客户端SDK接入实例 const container = require('rhea'); const crypto = require('crypto'); const fs = require(&quot;fs&quot;); // 请根据实际情况修改下面的参数 // host，在物联网平台首页，查看开发配置中查看 var YourHost=&quot;iot-06z00xxxxt6xc.amqp.iothub.aliyuncs.com&quot; // 客户端ID，可自定义，长度不可超过64个字符 var YourClientId=&quot;esp32_001&quot; // 账号的 AccessKey。将鼠标移至账号头像上，然后单击AccessKey管理，获取AccessKey ID和AccessKey Secret。 var YourAccessKeyId=&quot;LTAI5tXXXXXXXXXXxLEMGYL2&quot; var YourAccessKeySecret=&quot;6vi2Txxxw9xxxrwig&quot; // 在对应实例的消息转发 &gt; 服务端订阅 &gt; 消费组列表查看您的消费组ID。 var YourConsumerGroupId=&quot;DEFAULT_GROUP&quot; // 物联网平台首页实例 ID var YourIotInstanceId=&quot;iot-0600uxtxxsx&quot; // 存放完整的图片字符串 var imgStr = &quot;&quot; // 16进制图片转base64 function to_base64(str) { var digits = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;; var base64_rep = &quot;&quot;; var cnt = 0; var bit_arr = 0; var bit_num = 0; for (var n = 0; n &lt; str.length; ++n) { if (str[n] &gt;= 'A' &amp;&amp; str[n] &lt;= 'Z') { ascv = str.charCodeAt(n) - 55; } else if (str[n] &gt;= 'a' &amp;&amp; str[n] &lt;= 'z') { ascv = str.charCodeAt(n) - 87; } else { ascv = str.charCodeAt(n) - 48; } bit_arr = (bit_arr &lt;&lt; 4) | ascv; bit_num += 4; if (bit_num &gt;= 6) { bit_num -= 6; base64_rep += digits[bit_arr &gt;&gt;&gt; bit_num]; bit_arr &amp;= ~(-1 &lt;&lt; bit_num); } } if (bit_num &gt; 0) { bit_arr &lt;&lt;= 6 - bit_num; base64_rep += digits[bit_arr]; } var padding = base64_rep.length % 4; if (padding &gt; 0) { for (var n = 0; n &lt; 4 - padding; ++n) { base64_rep += &quot;=&quot;; } } return base64_rep; } //创建Connection。 var connection = container.connect({ //接入域名，请参见AMQP客户端接入说明文档。 'host': YourHost, 'port': 5671, 'transport':'tls', 'reconnect':true, 'idle_time_out':60000, //userName组装方法，请参见AMQP客户端接入说明文档。 'username':YourClientId+'|authMode=aksign,signMethod=hmacsha1,timestamp=1573489088171,authId='+YourAccessKeyId+',iotInstanceId='+YourIotInstanceId+',consumerGroupId='+YourConsumerGroupId+'|', //计算签名，password组装方法，请参见AMQP客户端接入说明文档。 'password': hmacSha1(YourAccessKeySecret, 'authId='+YourAccessKeyId+'&amp;timestamp=1573489088171'), }); //创建Receiver Link var receiver = connection.open_receiver(); //接收云端推送消息的回调函数。 container.on('message', function (context) { var msg = context.message; var messageId = msg.message_id; var topic = msg.application_properties.topic; var content = Buffer.from(msg.body.content).toString(); // 输出内容。 console.log(content); // 将接收到的mqtt消息中内容转为json var imgBody = JSON.parse(content).items.img.value console.log('-------') // 如果图片没有传输完毕，则拼接图片 if (imgBody != 'END') { imgStr += imgBody } else { // 如果图片传输完毕，则将图片转为base64 console.log('imgStr:') console.log(to_base64(imgStr)) // 配置图片保存路径 var path = './img/' + new Date().getTime() + '.jpg'; var dataBuffer = new Buffer(to_base64(imgStr), 'base64'); //把base64码转成buffer对象， //用fs将图片写入本地文件 fs.writeFile(path, dataBuffer, function (err) { if (err) { console.log(err); } else { console.log('写入成功！'); } }); // 图片转换完毕后，清空imgStr，准备接受下一张图片 imgStr = &quot;&quot; } //发送ACK，注意不要在回调函数有耗时逻辑。 context.delivery.accept(); }); //计算password签名。 function hmacSha1(key, context) { return Buffer.from(crypto.createHmac('sha1', key).update(context).digest()) .toString('base64'); } Nodejs 本地运行图： 2.2.2 Python 获取阿里云物联网平台图片数据（仅供参考） # encoding=utf-8 import time import sys import hashlib import hmac import base64 import stomp import ssl import schedule import threading # 导入json模块 import json # 16进制转图片 import binascii imgStr=&quot;&quot; i=1 def connect_and_subscribe(conn): accessKey = &quot;LTAxxxxxExxxL2&quot; accessSecret = &quot;AsJWxxxxxxxxxxxxxR0xxxxxB&quot; consumerGroupId = &quot;DEFAULT_GROUP&quot; # iotInstanceId：实例ID。 iotInstanceId = &quot;iot-06z0xxxxxx6xc&quot; clientId = &quot;esp32_001&quot; # 签名方法：支持hmacmd5，hmacsha1和hmacsha256。 signMethod = &quot;hmacsha1&quot; timestamp = current_time_millis() # userName组装方法，请参见AMQP客户端接入说明文档。 # 若使用二进制传输，则userName需要添加encode=base64参数，服务端会将消息体base64编码后再推送。具体添加方法请参见下一章节“二进制消息体说明”。 username = clientId + &quot;|authMode=aksign&quot; + &quot;,signMethod=&quot; + signMethod \\ + &quot;,timestamp=&quot; + timestamp + &quot;,authId=&quot; + accessKey \\ + &quot;,iotInstanceId=&quot; + iotInstanceId \\ + &quot;,consumerGroupId=&quot; + consumerGroupId + &quot;|&quot; signContent = &quot;authId=&quot; + accessKey + &quot;&amp;timestamp=&quot; + timestamp # 计算签名，password组装方法，请参见AMQP客户端接入说明文档。 password = do_sign(accessSecret.encode(&quot;utf-8&quot;), signContent.encode(&quot;utf-8&quot;)) conn.set_listener('', MyListener(conn)) conn.connect(username, password, wait=True) # 清除历史连接检查任务，新建连接检查任务 schedule.clear('conn-check') schedule.every(1).seconds.do(do_check,conn).tag('conn-check') class MyListener(stomp.ConnectionListener): def __init__(self, conn): self.conn = conn def on_error(self, frame): print('received an error &quot;%s&quot;' % frame.body) def on_message(self, frame): print('received a message &quot;%s&quot;' % frame.body) # print('received a message :' + json.loads(frame.body).items) time.sleep(5) def on_heartbeat_timeout(self): print('on_heartbeat_timeout') def on_connected(self, headers): print(&quot;successfully connected&quot;) conn.subscribe(destination='/topic/#', id=1, ack='auto') print(&quot;successfully subscribe&quot;) def on_disconnected(self): print('disconnected') connect_and_subscribe(self.conn) def current_time_millis(): return str(int(round(time.time() * 1000))) def do_sign(secret, sign_content): m = hmac.new(secret, sign_content, digestmod=hashlib.sha1) return base64.b64encode(m.digest()).decode(&quot;utf-8&quot;) # 检查连接，如果未连接则重新建连 def do_check(conn): print('check connection, is_connected: %s', conn.is_connected()) if (not conn.is_connected()): try: connect_and_subscribe(conn) except Exception as e: print('disconnected, ', e) # 定时任务方法，检查连接状态 def connection_check_timer(): while 1: schedule.run_pending() time.sleep(10) # 接入域名，请参见AMQP客户端接入说明文档。这里直接填入域名，不需要带amqps://前缀 conn = stomp.Connection([('iot-06xxxxxc.amqp.iothub.aliyuncs.com', 61614)], heartbeats=(0,300)) conn.set_ssl(for_hosts=[('iot-06xxxxxc.amqp.iothub.aliyuncs.com', 61614)], ssl_version=ssl.PROTOCOL_TLS) try: connect_and_subscribe(conn) except Exception as e: print('connecting failed') raise e # 异步线程运行定时任务，检查连接状态 thread = threading.Thread(target=connection_check_timer) thread.start() 其中 Python 中的参数配置同 Nodejs。 参考： 阿里云AMQP客户端接入说明 Nodejs客户端SDK接入实例 python客户端SDK接入实例 Python 获取图片数据运行图如下： 至此，从阿里云IOT平台获取图片数据并保存到本地的程序已全部完成，程序目前较为简陋，仅供参考使用。 参考内容： CSDN:ESP32CAM的图片用MQTT也能传？ CSDN:ESP32CAM连接阿里云物联网平台 CSDN:ESP32-S2使用Arduino连接阿里云 CSDN:连接阿里云失败MQTT connect failed] Gitnote:ESP32cam系列教程001 ","link":"https://blog.zhawenwen.cn/post/esp32cam_mqtt_aliyun_iot/"},{"title":"JavaScript中的异步编程","content":" 1. js 中两种异步方式（单线程编程语言） 1.1 传统回调函数（Callback Function） 1.2 Promise（承诺） 1.3 async、await 语法糖 1.4 await 使用中的陷阱 1. js 中两种异步方式（单线程编程语言） 1.1 传统回调函数（Callback Function） 例如：setTimeOut 回调函数的缺点：函数回调地狱 ，一个函数执行完毕在执行内部的另外一个，一层一层的嵌套。 setTimeout(() =&gt; { console.log(&quot;等三秒后&quot;); setTimeout(() =&gt; { console.log(&quot;再等三秒后&quot;); setTimeout(() =&gt; { console.log(&quot;又等三秒后&quot;); console.log(&quot;hello&quot;) }, 3000); }, 3000); }, 3000); 单线程优点： 由于所有操作运行在一个线程中，无需考虑线程同步和资源竞争的开销，避免了线程之间的频繁切换和竞争问题，降低了开销。 1.2 Promise（承诺） promise 承诺请求会在未来某一个时刻返回。 解决了回调地狱的问题 例如：fetch 向服务器请求，返回 Promise 对象动态更新页面内容。 fetch(&quot;https://jsonplaceholder.typicode.com/post/1&quot;) .then((response) =&gt; response.json()) .then((data) =&gt; console.log(data)); Promise 的链式调用避免了代码的层层嵌套，即便是我们有一个很长的链，代码也不过是下下方增长而不是向右，因此可读性会提升很多。 如果请求中出现错误，会触发 catch ，then 将不回执行。 fetch(&quot;https://jsonplaceholder.typicode.com/post/1&quot;) .then((response) =&gt; response.json()) .then((data) =&gt; console.log(data)) .catch((error) =&gt; console.log(error)); finally 方法在 Promise 链结束之后调用，无论失败与否，用来执行清理操作。 fetch(&quot;https://jsonplaceholder.typicode.com/post/1&quot;) .then((response) =&gt; response.json()) .then((data) =&gt; console.log(data)) .catch((error) =&gt; console.log(error)) .finally(() =&gt; { // 执行清理等操作 }); 1.3 async、await 语法糖 async 与 await 是基于 Promise 之上的语法糖，可以让异步操作更加简洁明了。 首先使用 async 修饰异步函数，异步函数是指返回值为 Promise 对象的函数。被 async 修饰的 function 接收请求必须用 await 。 async function f(){ const response = await fetch(&quot;https://jsonplaceholder.typicode.com/post/1&quot;); const json = await response.json(); console.log(json); } f(); // 这个函数返回值永远是一个 Promise await 虽然看上去会暂停函数的执行，但在等待的过程中，JavaScript 同样可以处理其他的任务。 这是因为 await 底层是基于 Promise 和事件循环机制实现的。 1.4 await 使用中的陷阱 多个 await 会打破并行 // async function f(){ // const a = await fetch(&quot;https://jsonplaceholder.typicode.com/post/1&quot;); // const b = await fetch(&quot;https://jsonplaceholder.typicode.com/post/2&quot;); // } async function f(){ const PromiseA = fetch(&quot;https://jsonplaceholder.typicode.com/post/1&quot;); const PromiseB = fetch(&quot;https://jsonplaceholder.typicode.com/post/2&quot;); const [a,b] = await Promise.all([PromiseA, PromiseB]); } 可以使用 Promise.all 将所有的 Promise 组合起来，然后在进行 await ，修改后的程序运行效率直接提升一倍。 不能直接使用 forEach 或 map 这一类方法 尽管在回调函数中写了 await ，但是 forEach 会立刻返回，不会暂停等到所有的异步操作都执行完毕。 如果希望等待循环中的异步操作都一一完成之后才继续执行，应当使用传统的 for 循环。 async function f(){ // [1,2,3].forEach(async (i)=&gt;{ // await someAsyncOperation(); // }) for (const i of [1,2,3]) { await someAsyncOperation(); } console.log(&quot;done&quot;); } 不能在全局中使用 await 关键字 await 只能在异步函数用有效。如果想要在最外层使用 await ，需要先定义一个异步函数，然后在函数体中使用 await 。 // await someAsyncOperation(); async function f(){ await someAsyncOperation(); } // 更简介的写法 (async()=&gt;{ await someAsyncOperation(); }) 参考： 异步编程：bilibli jsonplaceholder Promise：MDN ","link":"https://blog.zhawenwen.cn/post/javascript_asyn/"},{"title":"ESP32cam系列教程001：使用webcam摄像头实时查看视频","content":" 1. ESP32cam 介绍 2. arduino IDE 2.1 安装 arduino IDE 2.2 arduino IDE 获取 ESP32 开发环境 3 内网视频实时查看 3.1 选择 文件&gt;示例&gt;ESP32&gt;Camera&gt;CameraWebServer ,进入示例代码界面。 3.2 修改示例代码中的相关参数。 3.3 运行结果 3.4 程序如下 4 烧录程序到 ESP32cam 开发板中 4.1 通过配套的下载器进行下载 4.2 通过 USB转TTL(CH340)下载器进行下载 5. 外网视频实时查看 6.参考文献 1. ESP32cam 介绍 ESP32-CAM是小尺寸的摄像头模组该模块可以作为最小系统独立工作，尺寸仅为 27*40.5*4.5mm，可广泛应用于各种物联网场合，适用于家庭智能设备、工业无线控制、无线监控、QR无线识别，无线定位系统信号以及其它物联网应用，是物联网应用的理想解决方案。[^1] 其产品特性如下： 采用低功耗双核32位CPU，可作应用处理器 主频高达240MHz，运算能力高达 600 DMIPS 内置 520 KB SRAM，外置8MB PSRAM 支持UART/SPI/I2C/PWM/ADC/DAC等接口 支持OV2640和OV7670摄像头，内置闪光灯 支持图片WiFI上传 支持TF卡 支持多种休眠模式。 内嵌Lwip和FreeRTOS 支持 STA/AP/STA+AP 工作模式 支持 Smart Config/AirKiss 一键配网 支持二次开发 ESP32cam 的接口引脚图如下所示： 2. arduino IDE 2.1 安装 arduino IDE 下载官方网址：https://www.arduino.cc/en/software 下载符合自己操作系统版本的IDE并安装。 2.2 arduino IDE 获取 ESP32 开发环境 由于 arduino IDE 中本身是没有 ESP32 的开发版，需要手动进行安装，安装方式如下： 打开 Arduino IDE ，找到 文件&gt;首选项 ,将 ESP32 的配置链接填入附加开发板管理网址中。 # 配置链接 https://dl.espressif.com/dl/package_esp32_index.json 在 Arduino IDE 中，找到 工具&gt;开发板&gt;开发板开发板管理，搜索 ESP32 或者直接选择 ESP32 Wrover Module 。 3 内网视频实时查看 3.1 选择 文件&gt;示例&gt;ESP32&gt;Camera&gt;CameraWebServer ,进入示例代码界面。 3.2 修改示例代码中的相关参数。 修改示例代码中的 wifi 和密码的名称。 修改示例代码中的摄像头类型为 CAMERA_MODEL_AI_THINKER 。 3.3 运行结果 上传成功后，按一下 ESP32cam 开发板上的 RST 按键 ，重新启动开发板。 选择 工具&gt;串口监视器，查看串口中输出的 ip，并用浏览器打开 ip 即可实时查看视频画面。 3.4 程序如下 #include &quot;esp_camera.h&quot; #include &lt;WiFi.h&gt; // // WARNING!!! PSRAM IC required for UXGA resolution and high JPEG quality // Ensure ESP32 Wrover Module or other board with PSRAM is selected // Partial images will be transmitted if image exceeds buffer size // // Select camera model // #define CAMERA_MODEL_WROVER_KIT // Has PSRAM //#define CAMERA_MODEL_ESP_EYE // Has PSRAM //#define CAMERA_MODEL_M5STACK_PSRAM // Has PSRAM //#define CAMERA_MODEL_M5STACK_V2_PSRAM // M5Camera version B Has PSRAM //#define CAMERA_MODEL_M5STACK_WIDE // Has PSRAM //#define CAMERA_MODEL_M5STACK_ESP32CAM // No PSRAM #define CAMERA_MODEL_AI_THINKER // Has PSRAM //#define CAMERA_MODEL_TTGO_T_JOURNAL // No PSRAM #include &quot;camera_pins.h&quot; const char* ssid = &quot;TP-LINK_1760&quot;; const char* password = &quot;987654321&quot;; void startCameraServer(); void setup() { Serial.begin(115200); Serial.setDebugOutput(true); Serial.println(); camera_config_t config; config.ledc_channel = LEDC_CHANNEL_0; config.ledc_timer = LEDC_TIMER_0; config.pin_d0 = Y2_GPIO_NUM; config.pin_d1 = Y3_GPIO_NUM; config.pin_d2 = Y4_GPIO_NUM; config.pin_d3 = Y5_GPIO_NUM; config.pin_d4 = Y6_GPIO_NUM; config.pin_d5 = Y7_GPIO_NUM; config.pin_d6 = Y8_GPIO_NUM; config.pin_d7 = Y9_GPIO_NUM; config.pin_xclk = XCLK_GPIO_NUM; config.pin_pclk = PCLK_GPIO_NUM; config.pin_vsync = VSYNC_GPIO_NUM; config.pin_href = HREF_GPIO_NUM; config.pin_sscb_sda = SIOD_GPIO_NUM; config.pin_sscb_scl = SIOC_GPIO_NUM; config.pin_pwdn = PWDN_GPIO_NUM; config.pin_reset = RESET_GPIO_NUM; config.xclk_freq_hz = 20000000; config.pixel_format = PIXFORMAT_JPEG; // if PSRAM IC present, init with UXGA resolution and higher JPEG quality // for larger pre-allocated frame buffer. if(psramFound()){ config.frame_size = FRAMESIZE_UXGA; config.jpeg_quality = 10; config.fb_count = 2; } else { config.frame_size = FRAMESIZE_SVGA; config.jpeg_quality = 12; config.fb_count = 1; } #if defined(CAMERA_MODEL_ESP_EYE) pinMode(13, INPUT_PULLUP); pinMode(14, INPUT_PULLUP); #endif // camera init esp_err_t err = esp_camera_init(&amp;config); if (err != ESP_OK) { Serial.printf(&quot;Camera init failed with error 0x%x&quot;, err); return; } sensor_t * s = esp_camera_sensor_get(); // initial sensors are flipped vertically and colors are a bit saturated if (s-&gt;id.PID == OV3660_PID) { s-&gt;set_vflip(s, 1); // flip it back s-&gt;set_brightness(s, 1); // up the brightness just a bit s-&gt;set_saturation(s, -2); // lower the saturation } // drop down frame size for higher initial frame rate s-&gt;set_framesize(s, FRAMESIZE_QVGA); #if defined(CAMERA_MODEL_M5STACK_WIDE) || defined(CAMERA_MODEL_M5STACK_ESP32CAM) s-&gt;set_vflip(s, 1); s-&gt;set_hmirror(s, 1); #endif WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print(&quot;.&quot;); } Serial.println(&quot;&quot;); Serial.println(&quot;WiFi connected&quot;); startCameraServer(); Serial.print(&quot;Camera Ready! Use 'http://&quot;); Serial.print(WiFi.localIP()); Serial.println(&quot;' to connect&quot;); } void loop() { // put your main code here, to run repeatedly: delay(10000); } 4 烧录程序到 ESP32cam 开发板中 4.1 通过配套的下载器进行下载 将下载器与 ESP32cam 安装到一起，使用数据线链接到电脑，安装商家提供的驱动，之后在 工具选项中选择对应的 开发板与串口。 然后点击左上角的编译验证按钮进行编译，编译成功后点击旁边的上传按钮烧录到 ESP32cam 开发板中。 4.2 通过 USB转TTL(CH340)下载器进行下载 USB转TTL下载器仅仅是连接线上与配套送的下载器不同，其他下载步骤是一样的。 USB转TTL下载器与 ESP32cam 的链接线如下： USB转TTL VCC 接 ESP32cam 5V USB转TTL GND 接 ESP32cam GND USB转TTL RXD 接 ESP32cam TXD USB转TTL TXD 接 ESP32cam RXD 下载时，需要将 GPIO1 接到 GND 上，用来启动下载模式。 5. 外网视频实时查看 外网视频实时查看分为：1. esp32cam 开发板中运行的程序；2. 服务器中运行的程序。 通过ESP32cam 将视频数据发送的服务器中，服务器运行接受程序进行接收并展示，这样的好处是可以发送到外部公网服务器中。 程序的烧录见第四章。 esp32cam 中的程序如下： #include &lt;Arduino.h&gt; #include &lt;WiFi.h&gt; #include &quot;esp_camera.h&quot; #include &lt;vector&gt; const char *ssid = &quot;TP-LINK_1760&quot;; const char *password = &quot;987654321&quot;; const IPAddress serverIP(192,168,1,104); //欲访问的地址，即服务器的ip，可内网也可公网 uint16_t serverPort = 18080; //服务器端口号 # MTU #define maxcache 1430 WiFiClient client; //声明一个客户端对象，用于与服务器进行连接 //CAMERA_MODEL_AI_THINKER类型摄像头的引脚定义 #define PWDN_GPIO_NUM 32 #define RESET_GPIO_NUM -1 #define XCLK_GPIO_NUM 0 #define SIOD_GPIO_NUM 26 #define SIOC_GPIO_NUM 27 #define Y9_GPIO_NUM 35 #define Y8_GPIO_NUM 34 #define Y7_GPIO_NUM 39 #define Y6_GPIO_NUM 36 #define Y5_GPIO_NUM 21 #define Y4_GPIO_NUM 19 #define Y3_GPIO_NUM 18 #define Y2_GPIO_NUM 5 #define VSYNC_GPIO_NUM 25 #define HREF_GPIO_NUM 23 #define PCLK_GPIO_NUM 22 static camera_config_t camera_config = { .pin_pwdn = PWDN_GPIO_NUM, .pin_reset = RESET_GPIO_NUM, .pin_xclk = XCLK_GPIO_NUM, .pin_sscb_sda = SIOD_GPIO_NUM, .pin_sscb_scl = SIOC_GPIO_NUM, .pin_d7 = Y9_GPIO_NUM, .pin_d6 = Y8_GPIO_NUM, .pin_d5 = Y7_GPIO_NUM, .pin_d4 = Y6_GPIO_NUM, .pin_d3 = Y5_GPIO_NUM, .pin_d2 = Y4_GPIO_NUM, .pin_d1 = Y3_GPIO_NUM, .pin_d0 = Y2_GPIO_NUM, .pin_vsync = VSYNC_GPIO_NUM, .pin_href = HREF_GPIO_NUM, .pin_pclk = PCLK_GPIO_NUM, .xclk_freq_hz = 20000000, .ledc_timer = LEDC_TIMER_0, .ledc_channel = LEDC_CHANNEL_0, .pixel_format = PIXFORMAT_JPEG, // .frame_size = FRAMESIZE_VGA, // FRAMESIZE_UXGA (1600 x 1200) // FRAMESIZE_QVGA (320 x 240) // FRAMESIZE_CIF (352 x 288) // FRAMESIZE_VGA (640 x 480) // FRAMESIZE_SVGA (800 x 600) // FRAMESIZE_XGA (1024 x 768) // FRAMESIZE_SXGA (1280 x 1024) .frame_size = FRAMESIZE_QVGA, .jpeg_quality = 24, // 图像质量（jpeg_quality) 可以是 0 到 63 之间的数字。数字越小意味着质量越高 .fb_count = 1, }; void wifi_init() { WiFi.mode(WIFI_STA); WiFi.setSleep(false); //关闭STA模式下wifi休眠，提高响应速度 WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print(&quot;.&quot;); } Serial.println(&quot;WiFi Connected!&quot;); Serial.print(&quot;IP Address:&quot;); Serial.println(WiFi.localIP()); } esp_err_t camera_init() { //initialize the camera esp_err_t err = esp_camera_init(&amp;camera_config); if (err != ESP_OK) { Serial.println(&quot;Camera Init Failed&quot;); return err; } sensor_t * s = esp_camera_sensor_get(); //initial sensors are flipped vertically and colors are a bit saturated if (s-&gt;id.PID == OV2640_PID) { // s-&gt;set_vflip(s, 1);//flip it back // s-&gt;set_brightness(s, 1);//up the blightness just a bit // s-&gt;set_contrast(s, 1); } Serial.println(&quot;Camera Init OK!&quot;); return ESP_OK; } void setup() { Serial.begin(115200); wifi_init(); camera_init(); } void loop() { Serial.println(&quot;Try To Connect TCP Server!&quot;); if (client.connect(serverIP, serverPort)) //尝试访问目标地址 { Serial.println(&quot;Connect Tcp Server Success!&quot;); //client.println(&quot;Frame Begin&quot;); //46 72 61 6D 65 20 42 65 67 69 6E // 0D 0A 代表换行 //向服务器发送数据 while (1){ camera_fb_t * fb = esp_camera_fb_get(); uint8_t * temp = fb-&gt;buf; //这个是为了保存一个地址，在摄像头数据发送完毕后需要返回，否则会出现板子发送一段时间后自动重启，不断重复 if (!fb) { Serial.println( &quot;Camera Capture Failed&quot;); } else { //先发送Frame Begin 表示开始发送图片 然后将图片数据分包发送 每次发送1430 余数最后发送 //完毕后发送结束标志 Frame Over 表示一张图片发送完毕 client.print(&quot;Frame Begin&quot;); //一张图片的起始标志 // 将图片数据分段发送 int leng = fb-&gt;len; int timess = leng/maxcache; int extra = leng%maxcache; for(int j = 0;j&lt; timess;j++) { client.write(fb-&gt;buf, maxcache); for(int i =0;i&lt; maxcache;i++) { fb-&gt;buf++; } } client.write(fb-&gt;buf, extra); client.print(&quot;Frame Over&quot;); // 一张图片的结束标志 Serial.print(&quot;This Frame Length:&quot;); Serial.print(fb-&gt;len); Serial.println(&quot;.Succes To Send Image For TCP!&quot;); //return the frame buffer back to the driver for reuse fb-&gt;buf = temp; //将当时保存的指针重新返还 esp_camera_fb_return(fb); //这一步在发送完毕后要执行，具体作用还未可知。 } delay(20);//短暂延时 增加数据传输可靠性 } /* while (client.connected() || client.available()) //如果已连接或有收到的未读取的数据 { if (client.available()) //如果有数据可读取 { String line = client.readStringUntil('\\n'); //读取数据到换行符 Serial.print(&quot;ReceiveData：&quot;); Serial.println(line); client.print(&quot;--From ESP32--:Hello Server!&quot;); } } Serial.println(&quot;close connect!&quot;); client.stop(); //关闭客户端 */ } else { Serial.println(&quot;Connect To Tcp Server Failed!After 10 Seconds Try Again!&quot;); client.stop(); //关闭客户端 } delay(10000); } 服务器中运行的程序（Python）: import socket import threading import time import numpy as np import cv2 begin_data = b'Frame Begin' end_data = b'Frame Over' #接收数据 # ESP32发送一张照片的流程 # 先发送Frame Begin 表示开始发送图片 然后将图片数据分包发送 每次发送1430 余数最后发送 # 完毕后发送结束标志 Frame Over 表示一张图片发送完毕 # 1430 来自ESP32cam发送的一个包大小为1430 接收到数据 data格式为b'' def handle_sock(sock, addr): temp_data = b'' t1 = int(round(time.time() * 1000)) while True: data = sock.recv(1430) # 如果这一帧数据包的开头是 b'Frame Begin' 则是一张图片的开始 if data[0:len(begin_data)] == begin_data: # 将这一帧数据包的开始标志信息（b'Frame Begin'）清除 因为他不属于图片数据 data = data[len(begin_data):len(data)] # 判断这一帧数据流是不是最后一个帧 最后一针数据的结尾时b'Frame Over' while data[-len(end_data):] != end_data: temp_data = temp_data + data # 不是结束的包 讲数据添加进temp_data data = sock.recv(1430)# 继续接受数据 直到接受的数据包包含b'Frame Over' 表示是这张图片的最后一针 # 判断为最后一个包 将数据去除 结束标志信息 b'Frame Over' temp_data = temp_data + data[0:(len(data) - len(end_data))] # 将多余的（\\r\\nFrame Over）去掉 其他放入temp_data # 显示图片 receive_data = np.frombuffer(temp_data, dtype='uint8') # 将获取到的字符流数据转换成1维数组 r_img = cv2.imdecode(receive_data, cv2.IMREAD_COLOR) # 将数组解码成图像 # r_img = r_img.reshape(480, 640, 3) # r_img = r_img.reshape(320, 240, 3) t2 = int(round(time.time() * 1000)) fps = 1000//(t2-t1) cv2.putText(r_img, &quot;FPS&quot; + str(fps), (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 0, 0), 2) cv2.imshow('server_frame', r_img) if cv2.waitKey(1) &amp; 0xFF == ord('q'): break t1 = t2 print(&quot;接收到的数据包大小：&quot; + str(len(temp_data))) # 显示该张照片数据大小 temp_data = b'' # 清空数据 便于下一章照片使用 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 这里的 ip 与端口是运行该程序的服务器的 ip 与端口，需要与 arduino 中的一致 server.bind(('192.168.1.104', 18080)) server.listen(5) CONNECTION_LIST = [] #主线程循环接收客户端连接 while True: sock, addr = server.accept() CONNECTION_LIST.append(sock) print('Connect--{}'.format(addr)) #连接成功后开一个线程用于处理客户端 client_thread = threading.Thread(target=handle_sock, args=(sock, addr)) client_thread.start() 6.参考文献 CSDN:ESP32 cam 从安装... Arduino IDE 官网 CSDN:ESP32cam 与服务器 TCP 视频传输 ESP32cam 中 WIFI 与 ADC2 CSDN:USB2TTL CH340 ","link":"https://blog.zhawenwen.cn/post/esp32cam_001/"},{"title":"解决ESP32cam中WIFI与ADC2无法共用的问题","content":" 1. ESP32cam 介绍 2. 问题来源与资料 2.1 问题来源 2.2 查阅相关资料 3. ESP32cam中 WIFI 与 ADC2 共用解决方法 1. ESP32cam 介绍 ESP32-CAM是小尺寸的摄像头模组该模块可以作为最小系统独立工作，尺寸仅为 27*40.5*4.5mm，可广泛应用于各种物联网场合，适用于家庭智能设备、工业无线控制、无线监控、QR无线识别，无线定位系统信号以及其它物联网应用，是物联网应用的理想解决方案。[1] 其产品特性如下： 采用低功耗双核32位CPU，可作应用处理器 主频高达240MHz，运算能力高达 600 DMIPS 内置 520 KB SRAM，外置8MB PSRAM 支持UART/SPI/I2C/PWM/ADC/DAC等接口 支持OV2640和OV7670摄像头，内置闪光灯 支持图片WiFI上传 支持TF卡 支持多种休眠模式。 内嵌Lwip和FreeRTOS 支持 STA/AP/STA+AP 工作模式 支持 Smart Config/AirKiss 一键配网 支持二次开发 ESP32cam 的接口引脚图如下所示： 2. 问题来源与资料 2.1 问题来源 因实验室需要，本人使用 ESP32cam 采集图片视频等信息传输到物联网平台中，同时还要采集温湿度与PH值等传感信息，同步传输到物联网平台中。 因内容较多所以分开测试： 测试 esp32cam 连接 wifi 是否使用正常 测试 esp32cam 图片是否采集正常，是否能通过 wifi 传输到外网服务器中 测试 esp32cam 是否能采集温湿度与 PH 值等传感信息并输出 这时问题就出现了，分开测试 1、2、3 项功能全部正常，但合并程序后，PH 传感器采集的值全部为 0 ，我一直以为是传感器出现问题或代码合并时出错，在这些地方耽误了好长时间；后来查阅大量资料发现是 ESP32 开发板硬件的问题。 2.2 查阅相关资料 PH值传感器是模拟量采集传感器，需要连接到 ESP32 的 ADC 接口进行数模转换，但是 ESP32系列仅仅拥有两个 ADC 数模转换器，当 ESP32 开发板连接 WIFI 的时候，WIFI 会占用 ADC2，同时 WIFI 占用 ADC2 的优先级比较高，其他模块就无法使用 ADC2 获取数值，这就是为什么PH 传感器采集的值全部为 0 的原因。但 ADC1 不受影响，此时只需要将 模拟传感器接入 ADC1 即可正常使用。 官方Github：wifi 与 ADC2 不能同时使用。[2] ESP32 开发板关于 ADC 的引脚功能定义如下：[3] 但对于 ESP32cam 开发板来说，这又是一个困难。ESP32cam 开发板并未引出 ADC1 的IO引脚，并且 ADC1 部分引脚被摄像头模块占用了，所以在 ESP32cam 开发板中，无法正常使用 ADC1 数模转换器。 ESP32cam 开发板关于 ADC 的引脚功能定义如下：[4] 3. ESP32cam中 WIFI 与 ADC2 共用解决方法 通知上述解释以及其他各种文献、教程、参考资料等都在说是因为 WIFI 与 ADC2 不能共用。 但追其本质，是 WIFI 占用 ADC2 导致其他模拟传感器不能通过 ADC2 读取数据。 问：那能不能在 ESP32 读取 ADC2 上连接的模拟传感器数据前关闭 WIFI 功能，在读取完数据之后再打开 WIFI 功能，然后将数据发送到外网平台中呢？ 答案是：能，即交替使用 WIFI 与 ADC2。 通过在 ESP32cam 开发板中进行实测，发现这样可以正常读出 ADC2 上连接的模拟信号传感器的正确数值，但每次都要多花费时间进行重连 WIFI ，重连 WIFI 的时间不定，约为 1 秒。 这种方法可以解决对非高实时性采集信息的模拟传感器使用 ADC2 采集数据的问题。 例如对 PH 值传感器，每 3 分钟或 5 分钟采集一次 PH 值信息，此时重连 WIFI 的 1 秒钟对于分钟级别的采集数据可以忽略不计。 但是对于实时性有较高要求的使用 ADC2 的模拟信号传感器来说，重连 WIFI 的 1 秒钟就变得难以接受，本方法也就没有用处了。 ESP32cam中 WIFI 与 ADC2 共用 arduino 代码如下： #include &lt;Arduino.h&gt; #include &lt;WiFi.h&gt; #include &lt;vector&gt; // ph and tem 变量设置 // 将模拟信号传感器连接到 ESP32cam 上的 GPIO2 口，该口为 ADC2 const int phPin = 2; float Value = 0; // wifi 账号与密码 const char *ssid = &quot;TP-LINK_1760&quot;; const char *password = &quot;987654321&quot;; // 初始化 wifi void wifi_init() { WiFi.mode(WIFI_STA); WiFi.setSleep(false); //关闭STA模式下wifi休眠，提高响应速度 WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print(&quot;.&quot;); } Serial.println(&quot;WiFi Connected!&quot;); Serial.print(&quot;IP Address:&quot;); Serial.println(WiFi.localIP()); } void setup() { Serial.begin(115200); // wifi 初始化 wifi_init(); pinMode(phPin, INPUT); } void loop() { // 关闭 wifi WiFi.disconnect(true); WiFi.mode(WIFI_OFF); // adc2 读取数据 pinMode(phPin, INPUT); Value = analogRead(phPin); // 打开 wifi wifi_init(); // 串口打印数据 Serial.print(Value); delay(500); } 代码运行效果图如下： https://docs.ai-thinker.com/esp32-cam ↩︎ https://github.com/espressif/arduino-esp32/issues/8356 ↩︎ https://blog.csdn.net/h56464646/article/details/125324902 ↩︎ https://mischianti.org/2021/09/02/esp32-cam-high-resolution-pinout-and-specs/ ↩︎ ","link":"https://blog.zhawenwen.cn/post/esp32cam_wifi_adc2/"},{"title":"2023个人博客数据年中汇总","content":"1. 博客数量 2023年上半年本人共撰写博客八篇，其中 Node.js 3篇，工具教程类 4 篇，申请指南 1 篇。博客总数量 43 篇。 博客文章除了发表在个人博客网站中，还同步到其他第三方博客平台，包括但不限于 CSDN、cnblogs、掘金、思否等。 个人博客网站并没有为每篇文章单独统计阅读数，所以不参与阅读数量统计。 2. 第三方平台博客数据统计 2023年上半年有 5 篇博客同步到了 CSDN 平台。博客总数 33 篇。 CSDN 平台总数据如下： 总阅读量：38091 总评论数：37 总收藏数：196 2023年上半年有 3 篇博客同步到了 cnblogs 平台。博客文章总数 11 篇，随笔总数 18 篇。 cnblogs 平台总数据如下： 文章总阅读量：5496 随笔总阅读量：48071 2023年上半年有 3 篇博客同步到了掘金平台。博客总数 9 篇。 掘金平台总数据如下： 文章总阅读量：2177 文章总收藏量：6 2023年上半年有 4 篇博客同步到了思否平台。博客总数 7 篇。 思否平台总数据如下： 总阅读数：6143 2023年上半年有 3 篇博客同步到了知乎平台。博客总数 3 篇。 知乎平台总数据如下： 总阅读量：21249 总赞同量：29 总分享量:34 3. 总结与展望 虽然所有第三方平台的阅读数总和超过了 12 万，但总体文章的专业性不强、质量不太好，点赞、评论与收藏数不高。 后期尽量保证每月撰写一篇技术博客文章，同时提高文章的专业性与质量。 写博客的主要目的是分享自己在技术方面跨过的坑与获得的收获，帮助其他人少踩一些坑。 ","link":"https://blog.zhawenwen.cn/post/the_middle_of_2023/"},{"title":"业余无线电操作证书及无线电台执照申请指南","content":" 业余无线电操作证书及无线电台执照申请指南 一、什么是业余无线电 二、获取业余无线电操作证书 2.1 考试报名 2.2 考试复习 2.2.1 官网题库下载与复习 2.2.2 微信小程序题库复习（推荐） 2.3 参加考试 2.4 获取操作证书 三、获取无线电台执照（验机） 3.1 购买符合要求的无线电台（手台、对讲机） 3.2 申请无线电台执照 业余无线电操作证书及无线电台执照申请指南 一、什么是业余无线电 业余无线电是一种在全世界非常普遍的业余爱好。喜爱业余无线电的人也被称为业余无线电爱好者或HAM，在美国政府正式注册的HAM大约有一百四十万人，在中国大约有二十多万人，在全世界总共大约六百万人。他们必须学习相关知识并通过所在国家的测试才能领取到业余无线电执照，同时领取政府分配的业余无线电呼号。业余无线电呼号是一个业余无线电爱好者的标识，此标识在全世界是不重复的，这也是业余无线电爱好者的荣誉所在。[1] 中国无线电协会业余无线电分会是中国业余无线电爱好者的组织，负责业余无线电的管理和考试。其官方网站为：http://www.cra.org.cn/。 无线电操作证书与无线电台执照是业余无线电爱好者的必备证件，类似与汽车的行驶证与驾驶证，无线电操作证书相当于驾驶证，证明你有能力操作无线电台；无线电台执照相当于行驶证，证明此无线电台是合法电台。 二、获取业余无线电操作证书 业余无线电需要参加统一的业余无线电考试获取无线电操作执照后才能合法的使用业余无线电。 2.1 考试报名 业余无线电台操作技术能力验证（以下简称：考试）每年进行3~4次，各省考试时间各不相同，可在各省业余无线电微信公众号或者在业余无线电官网中查看报名时间。 下面以业余无线电官网为例： 首先进入业余无线电官网 ：http://www.cra.org.cn/ 点击右下角 能力测验 注册账号并登陆 选择报考的省份和时间报考（第一次报考只能报考A类） 缴费 2.2 考试复习 考试内容以题库内容为主，复习题库中的内容即可。 2.2.1 官网题库下载与复习 业余无线电协会官网提供考试的的题库，下载下来进行复习即可 [2]。 2.2.2 微信小程序题库复习（推荐） 也可以使用微信小程序：HAM模拟考试 进行日常复习与练习。 2.3 参加考试 在考试时间到规定地点参加考试即可。 以安徽省合肥市为例： 考试地点在：安徽省合肥市蜀山区天乐路8号安徽省科学技术馆三楼 考试类型为：电脑机考 题目类型为：随机30题，正确25题即可通过 2.4 获取操作证书 考试通过后一周内即可获得无线电操作证书，证书会寄到你填写的地址。请及时关注群消息。 操作证书样式如下： 三、获取无线电台执照（验机） 3.1 购买符合要求的无线电台（手台、对讲机） 首先在网络购物平台或实体店中购买一台符合要求的无线电台： 无线电台必须有核准码。（询问客服并告知客服需要验机） 无线电台的频率必须是包含且不超过业余无线电频率。（频率要求见上图操作证背面） A类无线电台的功率必须小于5W[3]。 3.2 申请无线电台执照 以合肥市为例： 提前准备无线电台、身份证、操作证书、承诺书、业余无线电台设置（ 变更）申请表（国-17）、业余无线电台技术资料申报表（国-19）。（考试官方群文件中提供） 在工作时间去当地无线电管理处办理验机手续。合肥的地址在：合肥市蜀山区绿地蓝海C座1913室 材料合格 5 分钟即可办完手续，分配呼号，颁发无线电台执照。 无线电台证书样式： 注意： 验机一般在户籍所在地的无线电管理处办理 合肥支持异地验机，但必须提供工作、学习、生活等长期在此的证明。 百度百科——业余无线电 ↩︎ 官网——业余电台操作考试题库 ↩︎ 知乎——业余无线电入门 ↩︎ ","link":"https://blog.zhawenwen.cn/post/crac_ham/"},{"title":"为无登陆鉴权功能的接口与网站添加登陆鉴权功能","content":"使用 HTTP Basic Auth 和 NGINX 反向代理为无登陆鉴权功能的接口与网站添加登陆鉴权功能。 1. 缘由 2. HTTP Basic Auth 2.1 什么是 HTTP Basic Auth ？ 2.2 为接口添加 HTTP Basic Auth 鉴权 2.2.1 创建反向代理网站 2.2.2 安装 htpasswd 并生成鉴权账号和密码 2.2.3 配置反向代理与鉴权认证 2.2.4 通过 ajax 请求 api 形式访问 1. 缘由 本人部分服务的测试接口为方便日常测试调试，使用了 ip+端口 的形式进行访问，并且未配置账号密码鉴权机制。在日常测试一段时间后，终于还是收到了来自腾讯云的监管通知，说服务存在数据泄露的风险，需要进行整改，否则将强行关停服务。 于是，本人认真思考本问题、查找相关资料并结合本人的web服务实际情况，决定使用 HTTP Basic Auth 技术并结合 NGINX 反向代理来完成接口鉴权的操作。 2. HTTP Basic Auth 2.1 什么是 HTTP Basic Auth ？ HTTP 提供一个用于权限控制和认证的通用框架：基本认证（Basic access authentication），其是一种用来允许网页浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。 优点： 操作简单 所有流行的网页浏览器都支持基本认证 缺点： 认证信息仅仅使用Base64进行编码，并未使用加密算法 无法防止中间人攻击，中间人可已修改报文然后请求服务器 2.2 为接口添加 HTTP Basic Auth 鉴权 原理：本人使用 NGINX 反向代理访问接口数据服务器，并在 NGINX 反向代理配置文件中添加 Basic Auth 鉴权功能， 2.2.1 创建反向代理网站 在反向代理服务器中使用宝塔面板创建一个网站，并将域名（或任使用ip+port）解析到该网站。 2.2.2 安装 htpasswd 并生成鉴权账号和密码 首先安装 htpasswd 服务 sudo apt-get install httpd-tools htpasswd是开源的http服务器Apache Http Server的一个命令行工具，可以用来创建和更新基本认证的用户认证密码文件。 参数 -b —&gt;密码直接写在命令行中,而非使用提示输入的方式 -c —&gt;创建密码文件,如果文件存在,则覆盖 -n —&gt;不更新密码文件,将用户名密码进行标注输出 -m —&gt;使用md5算法对密码处理 -d —&gt;使用crypt算法对面处理 -s —&gt;使用sha算法对密码处理 -p —&gt;不对密码加密处理,使用明文 -D —&gt;从密码文件中删除指定用户记录 生成鉴权的账号密码文件 在指定目录下生成鉴权的账号密码文件，该目录文件普通用户需要可以访问并读写。 htpasswd -bc /usr/local/myPasswd/nginxpasswd test 123123 2.2.3 配置反向代理与鉴权认证 在刚刚创建的反向代理网站的配置文件中添加以下内容： location / { # 设置跨域相关配置 add_header 'Access-Control-Allow-Origin''*'; add_header 'Access-Control-Allow-Methods''*'; add_header 'Access-Control-Allow-Headers''*'; if ($request_method = 'OPTIONS') { return 204; } # 设置鉴权相关配置 # 帐号认证弹框的banner信息，说明服务名称 auth_basic &quot;请输出账号密码：&quot;; # 认证的帐号密码文件，也就是我们上面使用 htpasswd 创建的密码文件 auth_basic_user_file /usr/local/myPasswd/nginxpasswd; # 设置反向代理相关配置 # 配置需要被反向代理的数据接口服务器的 ip+端口 proxy_pass http: //127.0.0.1:12345; } 然后通过反向代理服务器配置的域名访问网站，会弹出输入用户名和密码的弹框： 2.2.4 通过 ajax 请求 api 形式访问 添加了 Basic Auth 鉴权的接口在使用 ajax 请求时需要在 headers 头部增加 Authorization 字段，并包含鉴权的用户名和密码，否则报错401。 例如使用 axios 发送请求： axios.post(url,{headers:{'Authorization': 'Basic ' + base64encode(username+&quot;:&quot;+password)}) 至此 HTTP Basic Auth 的配置教程已全部结束。 参考文档： MDN：HTTP身份验证 简书：HTTP Authorization 博客园：Nginx实现Basic Auth ","link":"https://blog.zhawenwen.cn/post/http_basic_auth/"},{"title":"windows中vscode编译运行c++程序","content":" 1. vscode 安装 c++ 扩展 2. 安装C++编译器 3. vscode 中为 C++ 拓展添加 C++ 编译器 4. 运行 C++ 程序 4.1 通过 Code Runner 运行 C++ 4.2 使用原生运行 C++ 1. vscode 安装 c++ 扩展 在vscode中创建一个后缀为 01.cpp 的程序，程序文件如下，vscode会自动提示安装 c++ 扩展，点击进行安装。 // 01.cpp # include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; return 0; } 2. 安装C++编译器 编译器下载地址：https://github.com/skeeto/w64devkit/releases 编译器下载完成后，解压到目录中，并将目录下的 bin 目录添加到环境变量中。 然后在 CMD 中输入 gcc ，显示下面字样则编译器安装成功。 3. vscode 中为 C++ 拓展添加 C++ 编译器 回到 vscode 打开的 01.cpp 界面，选择右下角的 Win32 点击，在顶上弹出的框中选择 编辑配置(UI)，进入 C++ 拓展配置界面。 在 C++ 拓展配置界面中填入编译器路径，编译器路径为 第二步中下载解压的目录中的 bin\\gcc.exe 文件。 4. 运行 C++ 程序 4.1 通过 Code Runner 运行 C++ 安装扩展 Code Runner ，回到 vscode 打开的 01.cpp 界面，之后点击 vscode 右上角的运行按钮，run code，或者右击鼠标 Run Code 运行 C++ 程序. 若此时无法运行或运行报错，可能是环境变量未生效导致，重启 vscode 重试即可。运行结果展示如下： 4.2 使用原生运行 C++ 回到 vscode 打开的 01.cpp 界面，之后点击 vscode 右上角的运行按钮，选择 运行C/C++文件 运行 C++ 程序. 注意：需要命令行输出参数的 C++ 程序暂时只能使用 原生方式运行。 至此，vscode 已能正常运行 C++ 程序。 ","link":"https://blog.zhawenwen.cn/post/vscode_run_cpp/"},{"title":"Nodejs学习——数据库与身份认证","content":" 1. Node 操作 mysql 1.1 配置 mysql 模块 1.2 操作 mysql 数据库 2. Web 开发模式 2.1 服务端渲染的开发模式 2.2 前后端分离 2.3 如何选择？ 3. 身份认证 3.1 身份认证的基础概念 3.2 Session 认证机制 3.3 JWT 认证机制 1. Node 操作 mysql 1.1 配置 mysql 模块 安装 mysql 模块 npm install mysql 建立连接 const mysql = require('mysql') const db = mysql.createPool({ host: '127.0.0.1', user: 'root', password: 'root', database: 'test', }) 测试是否正常工作 db.query('select 1', (err, results) =&gt; { if (err) return console.log(err.message) console.log(results) }) 1.2 操作 mysql 数据库 查询数据 db.query('select * from users', (err, results) =&gt; { ... }) 插入数据 // ? 表示占位符 const sql = 'insert into users values(?, ?)' // 使用数组的形式为占位符指定具体的值 db.query(sql, [username, password], (err, results) =&gt; { if (err) return console.log(err.message) if (results.affectedRows === 1) console.log('插入成功') }) 向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据： const user = {username:'Bruce', password:'55520'} const sql = 'insert into users set ?' db.query(sql, user, (err, results) =&gt; { ... }) 更新数据 const sql = 'update users set username=?, password=? where id=?' db.query(sql, [username, password, id], (err, results) =&gt; { ... }) 快速方式： const user = {id:7,username:'Bruce',password:'55520'} const sql = 'update users set ? where id=?' db.query(sql, [user, user.id], (err, results) =&gt; { ... }) 删除数据 const sql = 'delete from users where id=?' db.query(sql, id, (err, results) =&gt; { ... }) 使用 delete 语句会真正删除数据，保险起见，使用标记删除的形式，模拟删除的动作。即在表中设置状态字段，标记当前的数据是否被删除。 db.query('update users set status=1 where id=?', 7, (err, results) =&gt; { ... }) 2. Web 开发模式 2.1 服务端渲染的开发模式 服务端渲染的概念：服务器发送给客户端的 HTML 界面，是==在服务器通过字符串拼接、动态生成的。==因此，客户端不需要使用 Ajax 这样的技术额外请求页面数据。 app.get('/index.html', (req, res) =&gt; { const user = { name: 'Bruce', age: 29 } const html = `&lt;h1&gt;username:${user.name}, age:${user.age}&lt;/h1&gt;` res.send(html) }) 优点： 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。 有利于 SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易获取信息，更有利于 SEO。 缺点： 占用服务器端的资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目的高效开发。 2.2 前后端分离 前后端分离的开发模式，依赖于 Ajax 技术的广泛应用。后端只负责提供 API 接口，前端使用 Ajax 调用接口。 优点： 开发体验好。前端专业页面开发，后端专注接口开发。 用户体验好。页面局部刷新，无需重新请求页面。 减轻服务器的渲染压力。页面最终在浏览器里生成。 缺点： 不利于 SEO。完整的 HTML 页面在浏览器拼接完成，因此爬虫无法爬取页面的有效信息。Vue、React 等框架的 SSR（server side render）技术能解决 SEO 问题。 2.3 如何选择？ 企业级网站，主要功能是展示，没有复杂交互，且需要良好的 SEO，可考虑服务端渲染 后台管理项目，交互性强，无需考虑 SEO，可使用前后端分离 为同时兼顾首页渲染速度和前后端分离开发效率，可采用首屏服务器端渲染+其他页面前后端分离的开发模式 3. 身份认证 3.1 身份认证的基础概念 身份认证（Authentication）又称”身份验证“、”鉴权“，是指通过一定的手段，完成对用户身份的确认。 对于服务器端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案： 服务器端渲染推荐使用 Session认证机制 前后端分离推荐使用 JWT 认证机制 3.2 Session 认证机制 了解 HTTP 协议的无状态性是进一步学习 Session 认证机制的必要前提。 HTTP 协议的无状态性，指的是客户端的每次 HTTP 请求都是独立的，连续多个请求直接没有直接的关系，服务器不会主动保留每次 HTTP 请求的状态。 什么是 Cookie？ Cookie 是存储在用户浏览器中的一段不超过 4KB 的字符串。它由一个名称（name）、一个值（value）和其他几个用户控制 Cookie 有效期、安全性、使用范围的可选属性组成。 不同域名下的 Cookie 各自独立，每当客户端发送请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器。 Cookie 的几大特性： 自动发送 域名独立 过期时限 4KB 限制 Session 的工作原理： Express中使用Session认证： 安装 express-session 中间件： npm install express-session 使用中间件 // 导入中间件 const session = require('express-session') // 配置 Session 中间件 app.use( session({ secret: 'anquan', // secret 的值为任意字符串 resave: false, saveUninitalized: true, }) ) 向 session 中存数据 中间件配置成功后，可通过 req.session 访问 session 对象，存储用户信息 app.post('/api/login', (req, res) =&gt; { if (req.body.username !== 'admin' || req.body.password !== '123') { return res.send({ status: 1, msg: 'username or password is not correct' }) } req.session.user = req.body req.session.isLogin = true res.send({ status: 0, msg: 'login done' }) }) 从 session 中取数据 app.get('/api/username', (req, res) =&gt; { if (!req.session.isLogin) { return res.send({ status: 1, msg: 'fail' }) } res.send({ status: 0, msg: 'success', username: req.session.user.username }) }) 清空 session app.post('/api/logout', (req, res) =&gt; { // 清空当前客户端的session信息 req.session.destroy() res.send({ status: 0, msg: 'logout done' }) }) 3.3 JWT 认证机制 Session 认证的局限性： Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。 当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制 JWT 工作原理图： 用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。 JWT 组成部分： Header、Payload、Signature Payload 是真正的用户信息，加密后的字符串 Header 和 Signature 是安全性相关部分，保证 Token 安全性 三者使用 . 分隔 Header.Payload.Signature eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTcsInVzZXJuYW1lIjoiQnJ1Y2UiLCJwYXNzd29yZCI6IiIsIm5pY2tuYW1lIjoiaGVsbG8iLCJlbWFpbCI6InNjdXRAcXEuY29tIiwidXNlcl9waWMiOiIiLCJpYXQiOjE2NDE4NjU3MzEsImV4cCI6MTY0MTkwMTczMX0.bmqzAkNSZgD8IZxRGGyVlVwGl7EGMtWitvjGD-a5U5c JWT 使用方式： 客户端会把 JWT 存储在 localStorage 或 sessionStorage 中 此后客户端与服务端通信需要携带 JWT 进行身份认证，将 JWT 存在 HTTP 请求头 Authorization 字段中 加上 Bearer 前缀 Authorization: Bearer &lt;token&gt; 在 Express 中使用 JWT： 安装 JWT 相关的包： jsonwebtoken 用于生成 JWT 字符串 express-jwt 用于将 JWT 字符串解析还原成 JSON 对象 npm install jsonwebtoken express-jwt 定义 secret 密钥 为保证 JWT 字符串的安全性，防止其在网络传输过程中被破解，需定义用于加密和解密的 secret 密钥 生成 JWT 字符串时，使用密钥加密信息，得到加密好的 JWT 字符串 把 JWT 字符串解析还原成 JSON 对象时，使用密钥解密 const jwt = require('jsonwebtoken') const expressJWT = require('express-jwt') // 密钥为任意字符串 const secretKey = 'anquan' 生成 JWT 字符串 app.post('/api/login', (req, res) =&gt; { ... res.send({ status: 200, message: '登录成功', // jwt.sign() 生成 JWT 字符串 // 参数：用户信息对象、加密密钥、配置对象-token有效期 // 尽量不保存敏感信息，因此只有用户名，没有密码 token: jwt.sign({username: userInfo.username}, secretKey, {expiresIn: '10h'}) }) }) JWT 字符串还原为 JSON 对象 客户端访问有权限的接口时，需通过请求头的 Authorization 字段，将 Token 字符串发送到服务器进行身份认证 服务器可以通过 express-jwt 中间件将客户端发送过来的 Token 解析还原成 JSON 对象 // unless({ path: [/^\\/api\\//] }) 指定哪些接口无需访问权限 app.use(expressJWT({ secret: secretKey }).unless({ path: [/^\\/api\\//] })) 获取用户信息 当 express-jwt 中间件配置成功后，即可在那些有权限的接口中，使用 req.user 对象，来访问从 JWT 字符串中解析出来的用户信息 app.get('/admin/getinfo', (req, res) =&gt; { console.log(req.user) res.send({ status: 200, message: '获取信息成功', data: req.user, }) }) 捕获解析 JWT 失败后产生的错误 当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行 通过 Express 的错误中间件，捕获这个错误并进行相关的处理 app.use((err, req, res, next) =&gt; { // token 解析失败导致的错误 if (err.name === 'UnauthorizedError') { return res.send({ status: 401, message: 'Invalid token' }) } // 其他原因导致的错误 res.send({ status: 500, message: 'Unknown error' }) }) ","link":"https://blog.zhawenwen.cn/post/nodejs03/"},{"title":"Nodejs学习——Express","content":" 1. Express 简介 2. Express 的基本使用 2.1 创建基本的 web 服务器： 2.2 监听 GET 与 POST 请求 2.3 Express 静态资源托管 2.4 nodeman 3. Express 路由 3.1 路由的概念 3.2 路由的简单使用 3.3 路由的模块化 3.4 为路由模块添加统一的前缀 4. Express 中间件 4.1 中间件的基本概念 4.2 中间件函数的简单使用 4.2.1 全局中间件 4.2.2 局部中间件 4.2.3 中间件的作用与注意事项 4.3 中间件的分类 4.4 自定义中间件 5. CORS 跨域资源共享 5.1 cors 中间件解决跨域 5.2 什么是 CORS ? 5.3 CORS常见响应头： 5.4 CORS请求分类： 1. Express 简介 基于 Node.js 平台，快速、开放、极简的 Web 开发框架 Express 是用于快速创建服务器的第三方模块。 内置的 http 模块用起来很复杂，开发效率低；Express 是基于内置的 http 模块进一步封装出来的，能够极大程度的提高开发效率。 Express 能做什么？ Web 网站服务器：专门对外提供 Web 网页资源的服务器。 API 接口服务器：专门对外提供 API 接口的服务器。 2. Express 的基本使用 2.1 创建基本的 web 服务器： // 导入 express const express = require('express'); // 创建 express 实例（ web 服务器） const app = express(); // 启动 web 服务器 app.listen(5000, () =&gt; { console.log('服务器启动成功，访问地址：http://127.0.0.1:5000'); }); 2.2 监听 GET 与 POST 请求 监听 get 请求： 通过 app.get() 方法，可以监听客户端的GET请求，具体的语法格式： // 参数1：请求的 url // 参数2：处理函数 // 处理函数：接收两个参数，分别是请求对象和响应对象 app.get(&quot;请求url&quot;, (req, res) =&gt; { /* 处理函数 */}) 监听 post 请求： 通过 app.post() 方法，可以监听客户端的POST请求，具体的语法格式： // 参数1：请求的 url // 参数2：处理函数 // 处理函数：接收两个参数，分别是请求对象和响应对象 app.post(&quot;请求url&quot;, (req, res) =&gt; { /* 处理函数 */}) 把内容响应给客户端： 通过 res.send() 方法，可以把处理好的内容，发送给客户端： app.get('/user', (req, res) =&gt; { res.send({ name: 'zs', age: 20, gender: '男' }) }) app.post('/user', (req, res) =&gt; { res.send('请求成功') }) 获取 URL 中携带的查询参数 通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数： app.get('/', (req, res) =&gt; { // 通过 req.query 可以获取到客户端发送过来的查询参数（?abc=123） console.log(req.query); // { abc: '123' } res.send(req.query) }) 获取 URL 中的动态参数： 通过 req.params 对象，可以访问到 URL 中通过 ：匹配到的动态参数 // 这里的 :id 是一个动态的参数 app.get('/user/:id', (req, res) =&gt; { // req.params 是动态匹配到的 URL 参数，默认是一个空对象 console.log(req.params); res.send(req.params); }) 2.3 Express 静态资源托管 express.static() 通过 express.static() 方法可创建静态资源服务器，向外开放访问静态资源。 app.use(express.static('public')) 注意： Express 在指定静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在 URL 中。 挂载路径前缀 如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式： app.use('/public',express.static('public')) 2.4 nodeman nodeman 能够监听项目文件的变动，当代码被修改后，nodeman 会自动重启项目，极大的方便了开发与调试。 全局安装 nodeman： npm install -g nodeman 使用 nodeman ： nodeman index.js 3. Express 路由 3.1 路由的概念 什么是路由？广义来说，路由就是映射关系。 在 Express 中，路由是指客户端的请求与服务器处理函数之前的映射关系。 Express 中的路由分为 3 个部分组成，分别是请求的类型、请求的URL地址、处理函数，格式如下： // 导入 express const express = require('express'); // 创建 express 实例（ web 服务器） const app = express(); app.get('/user', (req, res) =&gt; { res.send(&quot;hello get user&quot;) }) app.post('/user', (req, res) =&gt; { res.send('hello post user') }) // 启动 web 服务器 app.listen(5000, () =&gt; { console.log('服务器启动成功，访问地址：http://127.0.0.1:5000'); }); 路由匹配的注意点： 按照定义的先后顺序进行匹配 请求类型和请求的URL同时匹配成功，才会调用相对应的处理函数。 3.2 路由的简单使用 Express 中最简单的路由使用方式，就是将路由挂载到 app 上： // 导入 express const express = require('express'); // 创建 express 实例（ web 服务器） const app = express(); app.get('/user', (req, res) =&gt; { res.send(&quot;hello get user&quot;) }) app.post('/user', (req, res) =&gt; { res.send('hello post user') }) // 启动 web 服务器 app.listen(5000, () =&gt; { console.log('服务器启动成功，访问地址：http://127.0.0.1:5000'); }); 3.3 路由的模块化 为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。 抽离步骤： 创建路由模块对应的 js 文件 调用 express.Router() 函数创建路由对象 向路由对象上挂载具体的路由 使用 module.exports 向外共享路由对象 使用 app.use() 函数注册路由模块 // router.js const express = require('express') // 创建路由对象 const router = express.Router() // 挂载具体路由 router.get('/user/list', (req, res) =&gt; { res.send('Get user list.') }) router.post('/user/add', (req, res) =&gt; { res.send('Add new user.') }) // 向外导出路由对象 module.exports = router // index.js const express = require('express'); const app = express(); // 导入路由模块 const router = require('./router.js'); app.use(router); app.listen('5000', () =&gt; { console.log('服务器启动成功，访问地址：http://127.0.0.1:5000'); }); 3.4 为路由模块添加统一的前缀 类似与托管静态资源时，为静态资源统一挂载 访问前缀一样，路由模块添加前缀的方式也非常简单： const express = require('express') const router = require('./router') const app = express() // 注册路由模块，添加访问前缀 app.use('/api', router) app.listen(80, () =&gt; { console.log('http://127.0.0.1') }) 4. Express 中间件 4.1 中间件的基本概念 中间件是指流程的中间处理环节 服务器收到请求后，可先调用中间件进行预处理 中间件是一个 function 处理函数，包含 req, res, next 三个参数，next() 参数把流转关系交给下一个中间件或路由 next 函数的作用： next 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由。 4.2 中间件函数的简单使用 定义一个简单的中间件函数： // 常亮 mw 所指向的，就是一个中间件函数 const mw = function(req,res,next){ console.log(&quot;这是一个最简单的中间件函数&quot;) // 注意：当前中间件的业务处理完毕后，必须调用 next() 函数 // 表示把流转关系转交给下一个中间件或路由 next() } 4.2.1 全局中间件 全局中间件： 通过 app.use() 定义的中间件为全局中间件。 客户端发起的任何请求，到达服务器之后，都会触发的中间件。 const express = require('express') const app = express() // 定义第一个全局中间件 app.use((req, res, next) =&gt; { console.log('调用了第1个全局中间件') next() }) // 定义第二个全局中间件 app.use((req, res, next) =&gt; { console.log('调用了第2个全局中间件') next() }) app.get('/user', (req, res) =&gt; { res.send('User page.') }) app.listen(80, () =&gt; { console.log('http://127.0.0.1') }) 4.2.2 局部中间件 局部中间件： const express = require('express') const app = express() // 定义中间件函数 const mw1 = (req, res, next) =&gt; { console.log('调用了第一个局部生效的中间件') next() } const mw2 = (req, res, next) =&gt; { console.log('调用了第二个局部生效的中间件') next() } // 两种定义局部中间件的方式 app.get('/hello', mw2, mw1, (req, res) =&gt; res.send('hello page.')) app.get('/about', [mw1, mw2], (req, res) =&gt; res.send('about page.')) app.get('/user', (req, res) =&gt; res.send('User page.')) app.listen(80, function () { console.log('Express server running at http://127.0.0.1') }) 4.2.3 中间件的作用与注意事项 中间件的作用： 多个中间件之间，共享一份 req 和 res。基于这样的特性，可以在上游的中间件中，统一为 req 和 res 对象添加自定义的属性和方法，供下游的中间件或路由进行使用。 中间件使用注意事项： 一定要在路由之前定义中间件。 客户端发送来的请求，可以连续调用多个中间件进行处理。 执行完中间件代码后，不要忘了调用 next() 函数。 next() 后不要在写代码。 连续调用多个中间件时，多个中间件共享 req、 res对象。 4.3 中间件的分类 Express 把常见的中间件用法分成两 5 大类： 应用级别的中间件 通过 app.use() 或 app.get() 或 app.post() 绑定到 app 实例上的中间件，叫做应用级别的中间件。 路由级别的中间件 绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上。 const app = express() const router = express.Router() router.use(function (req, res, next) { console.log(1) next() }) app.use('/', router) 错误级别的中间件 用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。 错误级别中间件的处理函数中，必须有 4 个形参，形参顺序从前到后分别是 (err, req, res, next) 。 错误级别的中间件必须注册在所有路由之后 const express = require('express') const app = express() app.get('/', (req, res) =&gt; { throw new Error('服务器内部发生了错误！') res.send('Home page.') }) // 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃 app.use((err, req, res, next) =&gt; { console.log('发生了错误！' + err.message) res.send('Error：' + err.message) }) app.listen(80, function () { console.log('Express server running at http://127.0.0.1') }) Express 内置中间件 自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验： express.static 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性） express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用） express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用） app.use(express.json()) app.use(express.urlencoded({ extended: false })) 第三方中间件 4.4 自定义中间件 自己动手模拟一个类似与 express.urlencoded 这样的中间件，来解析 POST 提交到服务器的表单数据。 实现步骤： 定义中间件 监听 req 的 data 事件 监听 req 的 end 事件 使用 querystring 模块解析请求体数据 将解析出来的数据对象挂载为 req.body 将自定义中间件封装为模块 // 导入 express const express = require('express'); // 创建 express 实例（ web 服务器） const app = express(); // 导入 querystring 模块 const querystring = require('querystring'); // 监听 req 中的 data 事件，获取客户端发送过来的数据 let str = ''; // 定义中间件 app.use((req, res, next) =&gt; { // 定义中间件的具体业务 // 监听 req 中的 data 事件，获取客户端发送过来的数据 let str = ''; req.on('data', (chunk) =&gt; { str += chunk; }) // 监听 req 中的 end 事件 req.on('end', () =&gt; { // 将获取到的数据赋值给 req.body // req.body = str; console.log(str); var obj = querystring.parse(str); console.log(&quot;obj:&quot;,obj); req.body = obj; next(); }) }) app.post('/user', (req, res) =&gt; { res.send(req.body); }) // 启动 web 服务器 app.listen(5000, () =&gt; { console.log('服务器启动成功，访问地址：http://127.0.0.1:5000'); }); 5. CORS 跨域资源共享 5.1 cors 中间件解决跨域 安装中间件：npm install cors 导入中间件：const cors = require('cors') 配置中间件：app.use(cors) 5.2 什么是 CORS ? CORS（Cross-Origin Resource Sharing，跨域资源共享）解决跨域，是通过 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源。 浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可解除浏览器端的跨域访问限制。 CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。 CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。 5.3 CORS常见响应头： Access-Control-Allow-Origin：制定了允许访问资源的外域 URL // 控制只允许来自某些网站的请求 res.setHeader('Access-Control-Allow-Origin', 'http://bruceblog.io') res.setHeader('Access-Control-Allow-Origin', '*') Access-Control-Allow-Headers 默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一） 如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！ res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-Custom-Header') Access-Control-Allow-Methods 默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法 res.setHeader('Access-Control-Allow-Methods', 'POST, GET, DELETE, HEAD') res.setHEader('Access-Control-Allow-Methods', '*') 5.4 CORS请求分类： 简单请求 请求方式：GET、POST、HEAD 三者之一 HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application/x-www-form\u0002urlencoded、multipart/form-data、text/plain） 预检请求 请求方式为 GET、POST、HEAD 之外的请求 Method 类型 请求头中包含自定义头部字段 向服务器发送了 application/json 格式的数据 在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据 ","link":"https://blog.zhawenwen.cn/post/nodejs02/"},{"title":"Nodejs学习——Nodejs基础","content":" 1. 初识 Node.js 1.1 什么是 Node.js ? 1.2 Node.js 中的 JavaScript 运行环境 1.3 Node.js 可以做什么？ 1.4 Node.js 如何学习 2. fs 文件系统模块 2.1 什么是 fs 文件系统模块 2.2 读取指定文件中的内容 2.3 向指定的文件中写入内容 2.5 练习：考试成绩整理 2.6 fs 模块 - 路径动态拼接的问题 3. path 路径模块 3.1 什么是 path 路径模块 3.2 路径拼接 3.3 获取路径中文件名 3.4 获取路径中文件扩展名 4. http 模块 4.1 创建最基本的 web 服务器 4.2 根据不同的 url 响应不同的 html 内容（简易路由） 5. 模块化 5.1 模块化的概念 5.2 Node.js 中的模块化 5.3 Node.js 模块作用域 5.4 模块作用域的成员 5.5 Node.js 中的模块化规范 6. npm 与包 6.1 格式化时间 6.2 包的规范与管理 1. 初识 Node.js 1.1 什么是 Node.js ? Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine Node.js® 是一个基于 Chrome V8 引擎 的 JavaScript 运行时环境 1.2 Node.js 中的 JavaScript 运行环境 注意： 浏览器是 JavaScript 的前端运行环境 Node.js 是 JavaScript 是后端运行环境 Node.js 中无法调用 DOM 与 BOM 等浏览器内置 API 1.3 Node.js 可以做什么？ Node.js 作为一个 JavaScript 的运行环境，仅仅提供了基础的功能与API。然后，基于 Node.js 提供的基础功能，有很多的工具与框架可以使用。 基于 Express 框架，可以快速构建 Web 应用 基于 Electron 框架，可以构建跨平台的桌面应用 基于 restify 框架，可以快速构建 API 接口项目 读写和操作数据库、创建实用的命令行工具辅助前端开发、etc… 1.4 Node.js 如何学习 JavaScript 基础语法 + Node.js 内置 API（fs、path、http等）+ 第三方 模块（express、mysql等） 2. fs 文件系统模块 2.1 什么是 fs 文件系统模块 fs 模块是 node 官方提供的、用来操作文件的模块。它提供了一系列的方法与属性，用来满足用户对文件的操作需求。 fs.readFile() 方法，用来读取指定文件的内容 fs.writeFile() 方法，用来向指定文件写入内容 如果要在 Javascript 代码中使用 fs 模块，则需要使用如下方式导入它： const fs = require('fs') 2.2 读取指定文件中的内容 fs.readFile() 的语法格式： fs.readFile(path[,options],callback) 参数含义： 参数1：必选参数，字符串，表示文件的路径 参数2：可选参数，表示以什么编码格式来读取文件 参数3：必选参数，文件读取完成后，通过回调函数来拿到读取的结果。 fs.readFile() 的示例代码 const fs = require('fs') fs.readFile('./files/11.txt','utf8',function(err,dataStr){ console.log(err) console.log('------') console.log(dataStr) }) 判断文件是否读取成功 可以判断 err 对象是否为 null，从而知晓文件读取的结果。 const fs = require('fs') fs.readFile('./files/11.txt', 'utf8', function (err, dataStr) { if (err != null) { console.log(&quot;读取失败&quot;); console.log(err.message); } else { console.log(dataStr) } }) 2.3 向指定的文件中写入内容 fs.writeFile() 的语法格式 fs.writeFile(file,data[,options],callback) 参数含义： 参数1：必选参数，需要指定一个文件路径，表示文件的存放路径 参数2：必选参数，表示要写入的内容 参数3：可选参数，表示以什么格式写入文件内容，默认为 utf8 参数4：必选参数，文件写入完成后的回调函数 fs.writeFile() 示例代码： const fs = require('fs') fs.writeFile('./files/22.txt','hello world!',function(err){ console.log(err) }) 判断文件是否写入成功 可以判断 err 对象是否为 null，从而知晓文件写入的结果。 const fs = require('fs') fs.writeFile('./files/22.txt','hello world!',function(err){ if(err){ console.log(&quot;写入失败:&quot;+err.message); return; } console.log(&quot;写入成功&quot;); }) 2.5 练习：考试成绩整理 2.6 fs 模块 - 路径动态拼接的问题 在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，容易出现路径动态拼接错误的问题 原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径 解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，从而防止路径动态拼接的问题 __dirname 获取文件所处的绝对路径 const fs = require('fs') fs.writeFile(__dirname+'/files/22.txt','hello world!',function(err){ if(err){ console.log(&quot;写入失败:&quot;+err.message); return; } console.log(&quot;写入成功&quot;); }) 3. path 路径模块 3.1 什么是 path 路径模块 path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。 path.join() 方法，用来将多个路径片段拼接成一个完整的路径字符串。 path.basename() 方法，用来从路径字符串中将文件名解析出来。 3.2 路径拼接 path.join() 的语法格式 const path = require('path') path.join([...paths]) 参数说明： ...paths ：路径片段的序列 返回值：拼接完成的字符串 代码示例： const path = require('path'); const pathStr = path.join('/a','/b/c','../','d'); console.log(pathStr); // \\a\\b\\d const path = require('path'); const fs = require('fs'); fs.readFile(path.join(__dirname,'/files/22.txt'),'utf8',function(err,data){ if(err){ console.log(&quot;读取失败:&quot;+err.message); return; } console.log(data); }) 注意：今后但是涉及到路径拼接的操作，都要使用 path.join() 方法来处理。不要直接用 + 进行字符串的拼接。 3.3 获取路径中文件名 使用 path.basename() 方法，可以获取路径中的最后一部分，常通过该方法获取路径中的文件名。 path.basename() 的语法格式 path.basename(path[,ext]) 参数说明： path：必选参数，表示一个路径的字符串 ext：可选参数，表示文件的拓展名 返回值：表示路径中的最后一部分 代码示例： const path = require('path'); const fPath=&quot;/a/b/c/d/index.html&quot;; const fullName = path.basename(fPath); console.log(fullName); // index.html const nameWithOut = path.basename(fPath,'.html'); console.log(nameWithOut); // index 3.4 获取路径中文件扩展名 path.extname() 语法格式： path.extname(path) 参数说明： path ：必选参数，表示一个路径的字符串 代码示例： const path = require('path'); const fPath=&quot;/a/b/c/d/index.html&quot;; const pathExt = path.extname(fPath); console.log(pathExt); // .html 4. http 模块 什么是 http 模块： http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。 4.1 创建最基本的 web 服务器 创建服务器的基本步骤： 导入 http 模块 创建 web 服务器实例 为服务器绑定 request 事件，监听客户端的请求 启动服务器 const http = require('http'); // 创建 web 服务器实例 const server = http.createServer() // 为 web 服务器实例添加 request 请求事件，监听用户的请求 server.on('request', (req, res) =&gt; { const url = req.url console.log(url); }) // 启动 web 服务器，监听 3000 端口 server.listen(3000, () =&gt; { console.log('server is running at http://127.0.0.1:3000'); }) req 请求对象： 只要服务器接收到了客户端的请求，就会调用通过 server.on() 为服务器绑定的 request 事件处理函数。 如果想在事件处理函数中，访问与客户端相关的数据或属性，可已使用以下的方式： // 为 web 服务器实例添加 request 请求事件，监听用户的请求 server.on('request', (req, res) =&gt; { // req 是请求对象，包含了用户的请求信息 // req.url 是用户请求的路径 // req.method 是用户请求的方法 const url = req.url console.log(url); }) res 响应对象： 在服务器的 request 事件处理函数中，如果想访问与服务器相关的数据或属性，可以使用如下方式： // 为 web 服务器实例添加 request 请求事件，监听用户的请求 server.on('request', (req, res) =&gt; { // req 是请求对象，包含了用户的请求信息 // req.url 是用户请求的路径 // req.method 是用户请求的方法 const url = req.url const method = req.method // res 是响应对象，包含了服务器给用户的响应信息 // 要想给用户发送响应 // res.end() 方法的作用 // 向用户发送指定内容，并结束这次响应 const str = `your request url is ${url}, your request method is ${method}` res.end(str) }) 解决中文乱码问题 当调用 res.end() 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式： server.on('request', (req, res) =&gt; { const url = req.url const method = req.method // 设置响应头，解决中文乱码问题 res.setHeader('Content-Type', 'text/html; charset=utf-8') const str = `你的 ip 是： ${url},你的请求方法是： ${method}` res.end(str) }) 4.2 根据不同的 url 响应不同的 html 内容（简易路由） 核心的实现步骤： 获取请求的 url 地址 设置默认的响应内容为 404 Not Found 判断用户请求是否为 / 或 /index.html 首页 判断用户请求是否为 /about.html 关于页面 设置 Content-Type 响应投，防止中文乱码 使用 res.end() 把内容响应给客户端 const http = require('http') const server = http.createServer() server.on('request', (req, res) =&gt; { const url = req.url // 设置默认的响应内容为 404 Not found let content = '&lt;h1&gt;404 Not found!&lt;/h1&gt;' // 判断用户请求的是否为 / 或 /index.html 首页 // 判断用户请求的是否为 /about.html 关于页面 if (url === '/' || url === '/index.html') { content = '&lt;h1&gt;首页&lt;/h1&gt;' } else if (url === '/about.html') { content = '&lt;h1&gt;关于页面&lt;/h1&gt;' } res.setHeader('Content-Type', 'text/html; charset=utf-8') res.end(content) }) server.listen(80, () =&gt; { console.log('server running at http://127.0.0.1') }) 5. 模块化 5.1 模块化的概念 模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。 模块化可提高代码的复用性和可维护性，实现按需加载。 模块化规范是对代码进行模块化拆分和组合时需要遵守的规则，如使用何种语法格式引用模块和向外暴露成员。 模块化的好处： 提高了代码的复用性 提高了代码的可维护性 可以实现按需加载 5.2 Node.js 中的模块化 Node.js 中模块的分类： 内置模块 自定义模块 第三方模块 模块的加载： 使用 require() 方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。 // 1. 加载内置的 fs 模块 const fs = require('fs') // 2. 加载用户的自定义模块 const custom = require('./custom.js') // 3. 加载第三方模块 const moment = require('moment') 注意：使用 require() 方法加载其他模块时，会执行被加载模块中的代码。 5.3 Node.js 模块作用域 和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域 防止全局变量污染 5.4 模块作用域的成员 自定义模块中都有一个 module 对象，存储了和当前模块有关的信息 在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。导入自定义模块时，得到的就是 module.exports 指向的对象。 默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，以 module.exports 指向的对象为准。 注意：为了防止混乱，建议大家不要在同一个模块中同时使用 exports 和 module.exports 5.5 Node.js 中的模块化规范 Node.js 遵循了 CommonJS 的模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。 CommonJS规定： 每个模块内部，module 变量代表当前模块。 module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。 加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用户加载模块。 6. npm 与包 Node.js 中的第三方模块又叫做包。 6.1 格式化时间 传统做法 高级做法 使用 npm 包管理工具，在项目中安转格式化时间的包 moment 使用 require() 导入格式化时间的包 参考 moment 的官方文档对时间进行格式化 // 导入需要的包 const moment = require('moment'); const dt = new Date(); console.log(dt); // 2023-03-06T07:23:18.761Z console.log(moment(dt).format('YYYY-MM-DD HH:mm:ss')); // 2023-03-06 15:23:18 6.2 包的规范与管理 包的版本号是以 ”点分十进制“ 形式进行定义的，总共有三个数字，例如：2.24.0 第一位数字表示：大版本 第二位数字表示：功能版本 第三位数字功能：Bug 修复版本 版本号提升的规则：只要前面的版本号增长了，后面的版本号就要归零。 ","link":"https://blog.zhawenwen.cn/post/nodejs01/"},{"title":"web内外网判断界面","content":"因日常需要，我们在实验室内网中部署了一个服务，在校园网内都能正常访问，同时配置了内网穿透服务，实现外网也能正常访问。但外网访问毕竟是通过内网穿透实现，稳定性与网速都有限制，且不能实现提供大量下载服务，于是就有了这么一个想法：用户先访问内外网判断界面，如果判断当前用户所在的是校园网内网，则自动跳转到内网界面，否则跳转到外网界面进行访问，从而实现内外网分流，提高访问效率，降低带宽占用等功能。 原理：在内外网判断界面中使用内网ip请求一张图片，然后利用图片 load 后的 error 事件来判断内外网，当判断界面能够加载到内网中的图片时，则当前用户所处的为内网；否则当前用户为外网，然后使用 window.location.href 跳转到不同的界面中。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;内外网判断中转界面&lt;/title&gt; &lt;style&gt; *{ margin: 0; padding: 0; overflow: hidden; box-sizing: border-box; } a{ text-decoration: none; color: #000; } a:hover{ color: blue; text-decoration: underline; font-weight: 600; } h1{ margin: auto; padding: 0; width: 100%; height: 80px; background-color: #f5f5f5; text-align: center; justify-content: center; line-height: 80px; } h3{ margin:20px auto; padding: 0; background-color: yellow; width: 600px; height: 80px; text-align: center; justify-content: center; /* 文字上下居中 */ line-height: 80px; } #footer { position: fixed; bottom: 0; width: 100%; height: 50px; background-color: #f5f5f5; text-align: center; line-height: 50px; } #footer p{ margin: auto; padding: 0; font-size: 16px; line-height: 25px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;XXX网络中转平台&lt;/h1&gt; &lt;h3&gt;正在判断当前网络所处网络类型，请稍等！！！&lt;/h3&gt; &lt;div id=&quot;footer&quot;&gt; &lt;p&gt;有问题请联系邮箱：abc@xxx.com&lt;/p&gt; &lt;p&gt; © 2023 &lt;a href=&quot;www.qiaoyukeji.cn&quot; target=&quot;_blank&quot;&gt;巧遇科技工作室 &lt;/a&gt;All Rights Reserved&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 利用图片 load 后的error事件来判断网络的内外网 var timeStr = setTimeout(function () { var $img = $('&lt;img src=&quot;http://127.0.0.1:5500/2.jpg?' + (new Date()) + '&quot;&gt;') $img.appendTo('body').css(&quot;display&quot;, &quot;none&quot;).load(function () { console.log(&quot;内网！&quot;) window.location.href=&quot;http://www.baidu.com&quot; $(this).remove() }).error(function () { console.log(&quot;外网！！&quot;) window.location.href=&quot;http://www.bilibili.com&quot; $(this).remove() }) }, 2000) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://blog.zhawenwen.cn/post/go_with_net/"},{"title":"使用nps搭建内网穿透并配置泛域名解析","content":" 前言 1. 准备工作 2. 服务器端搭建nps并配置 2.1 配置nps配置文件 2.2 docker安装nps 2.3 web端配置nps并使用 3. 客户端使用nps 4. 配置泛域名解析 5. 参考链接 前言 nps是什么？ nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议，此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端。 1. 准备工作 一台拥有公网IP的云服务器，我这里使用的是腾讯云轻量应用服务器，系统为CentOS。 云服务器中需要安装配置好 Docker。参考地址：菜鸟教程-docker的安装 云服务器中安装好宝塔面板，如不需要域名访问，可以跳过此步骤。参考地址：宝塔面板安装教程 nps 服务器端和客户端的程序。下载地址：https://github.com/ehang-io/nps 一个已完成备案的域名，用来配置内网穿透泛域名访问，如不需要域名访问，可以跳过此步骤。 2. 服务器端搭建nps并配置 2.1 配置nps配置文件 nps安装时需要加载配置文件，所以需要先创建好配置文件。 下载nps服务端配置文件到本地，选择与服务器系统相对应的版本，我这里选择 linux_amd64_server.tar.gz ,下载地址：https://github.com/ehang-io/nps/releases 解压下载好的安装包，进入 conf 目录下，对 npc.conf 配置文件进行修改。 首先修改 http_proxy_port 和 https_proxy_port 的端口号为20080和20443。 配置 bridge_port 为 28024 。 配置修改 web_username 、 web_password 和 web_port ，其中 web_port 修改为 28080 ， web_username 、 web_password 是web管理端的用户名和密码，自行配置即可； web_port 是web管理端的端口号，通过 IP:端口 即可访问web管理端。 其他配置请参照nps服务端配置文档并根据需要自行配置。参考地址：nps服务端配置文件 注：这里为了防止与其他已安装的环境冲突，将所有的端口号全部调整到20000-30000之间。 http_proxy_port：http代理端口号 https_proxy_port：https代理端口号 bridge_port：桥接端口号 web_username：web管理端用户名 web_password：web管理端密码 web_port：web管理端端口号 将修改好的配置文件及其目录 conf 上传到服务器的 /etc/nps 目录下，如果没有此目录，可以自行创建。 2.2 docker安装nps 拉取nps服务端docker镜像 docker pull ffdfgdfg/nps 运行nps容器，并设置开机自启动 docker run -d --restart=always --name nps --net=host -v /etc/nps/conf:/conf ffdfgdfg/nps 此时nps服务端已经安装完成，可以通过 docker ps 查看是否运行成功。 2.3 web端配置nps并使用 注：如无法访问，请到云服务器管理后台开放对应端口的访问权限。 注：如安装了宝塔面板等，也需要去到面板管理界面开放端口的访问权限。 首先通过浏览器访问 http://服务器IP:28080 ，输入配置文件中设置的用户名和密码即可进入web管理端。28080是web_port配置的端口号。 在右侧客户端界面新增一个客户端，然后在客户端界面点击 &quot;+&quot; ，查看其中的客户端命令。 3. 客户端使用nps 下载nps客户端npc到本地，选择与服务器系统相对应的版本，我这里选择 windows_amd64_client.tar.gz ,下载地址：https://github.com/ehang-io/nps/releases 解压下载的文件，并放置到指定位置，如桌面上。 CMD管理员进入该解压后的目录中，并运行服务端提供的客户端命令。 windows 运行命令，需要将其中 ./npc 替换为 npc.exe 。 此时本地npc客户端已成功运行，并且web管理端也显示连接状态为在线。 此时本地服务器已与云服务器连接成功。 在客户端界面点击隧道，新增一条隧道。如果需要在外网访问本地 http://127.0.0.1:8080，则需要在隧道中新增一条 tcp 类型的隧道，如下图所示。 此时通过 服务器ip + 服务端端口号即可访问本地的网站，内网穿透到此结束。 注意： CMD必须已管理员身份运行，否则无法成功。 windows下请将其中的 ./npc 替换为 npc.exe 。 nps服务端和客户端的版本必须一致，否则无法连接。 nps中s表示服务端，npc中c表示客户端。 4. 配置泛域名解析 配置到上面一步已经能正常使用了，但我手头有已备案的域名，就考虑能否使用域名来代替 服务器ip + 端口的形式来进行内网穿透。 准备工作： 已备案域名一个 云服务中需要安装宝塔面板 域名：这里使用 example.cn 代替域名，实际使用时请替换为自己的域名。 进入域名DNS解析页面，添加一条泛域名解析，将 *.nps.example.cn 解析到 服务器ip。 到nps的web端管理界面中添加一条域名解析。 此时便可通过 http://1.nps.example.cn:20080 访问到本地内网网站了。这里的 20080 为 http_proxy_port 中配置的端口号。 这时已成功通过 域名+端口 的形式完成内网穿透，下面将通过配置取消掉域名后面的端口，使用 仅域名 形式的访问。 在云服务器的宝塔面板中创建一个网站，域名就填写 *.nps.example.cn。 网站创建好后，点击设置，选择配置文件，在配置文件最后添加如下内容，将域名代理到域名+端口的形式，从而实现单独的域名访问。 location / { resolver 114.114.114.114; proxy_pass http://$host:20080; } 至此实现域名的内网穿透访问。 2024年08月06日更新： 本教程客户端默认使用的是 windwos 客户端命令行程序，部分小白不太会用，于是本人为 windows 用户提供客户端 GUI 程序，方便用户使用。 windows_nps_gui : https://gitee.com/qiaoyukeji/nps_gui 5. 参考链接 nps官网 nps文档 CSDN-Centos8.2利用Docker实现NPS内网穿透与宝塔共存 宝塔面板安装教程 博客园-nginx的proxy_pass ","link":"https://blog.zhawenwen.cn/post/nps/"},{"title":"2022年年度总结回顾（流水账）","content":"今天是2022年12月31日，2022年的最后一天，研究生生涯已过一半，过去的2022年发生了很多事情，从2022年2月18开学到2022年12月18日回家，我在学校呆了整整10个月，这10个人月里发生了很多事情，有快乐也有悲伤，更多的是无尽的收获，在此回顾我的过去的2022年，特此记录。 博客文章 过去一年我在CSDN与自己个人的博客中撰写了 10 篇原创文章，获得了 84 个收藏和 20+ 条评论，这些文章都是我在学习过程中的一些总结，也是我在学习过程中的一些心得，我也会在接下来的时间里继续努力，为自己的博客撰写更多的文章。 Github&amp;Gitee 过去一年我在Github与Gitee中共提交了 7 次 Issues 与 2 次 Pull Request，开源了 3 个项目，我也会在接下来的时间里继续努力，为自己的Github与Gitee撰写更多的项目。 2022年流水账 2022年1月1日，巢湖边，游览安徽渡江战役纪念馆。 2022年1月5日，上届大师兄来实验室写对联。 2022年1月19日，实验室搬迁，从四楼搬到五楼，一天内所有东西都全部搬完，剩下一地狼藉。 2022年1月23日，启程回家。 2022年1月31日，除夕，万事皆宜。 2022年2月7日，暴雪红色预警，瑞雪兆丰年。 2022年2月16日，独秀山一日游，领略独秀故里。 2022年2月18日，开学，迎来新的一学期。 2022年2月20日，合肥城隍庙一日游。 2022年3月20日，夜。 2022年4月9日，学校精酿啤酒研究室买啤酒，实验室不醉不归。 2022年5月1日，朋友约操场剧本杀，这是第一次玩剧本杀，还是挺有意思的。 2022年5月29日，师兄师姐们答辩结束，顺利毕业了。 2022年6月2日，师兄师姐们的毕业饭，喝了不少酒。 2022年6月8日，夜店蹦迪中一晚上。 2022年6月18日，和实验室小伙伴一起开卡丁车，很有意思。 2022年7月9日，和实验室小伙伴一起去坐摩天轮，这是第一次坐摩天轮，很有意思。 2022年8月7日，和实验室小伙伴一起去学校的游泳馆游泳，这是我第一次游泳，很有意思。 2022年8月17日，和实验室小伙伴一起去融创水世界游玩，我的评价是：融创水世界，狗都不去。 2022年9月12日，和实验室小伙伴以及上届师兄一起去夜爬大蜀山，这是我第三次上大蜀山的，夜爬人很多，也很有趣。 2022年9月19日，评学业奖学金时非常不愉快，我被从一等最后挤到了二等第一，一下子直接少了4000块钱。评奖学金之后一星期我才发现有5分忘记加了，要是加上妥妥的一等，但为时已晚，只能如此了。 2022年9月20日，2022年世界制造业大会一日游。 2022年10月2日，和小伙伴一起打麻将，从晚7点打到早上8点，打了一整个通宵，到最后都打糊涂了，非常快乐。 2022年10月4日，和实验室小伙伴一起去紫蓬山游玩，紫蓬山太远了，打车都要一两个小时，但是紫蓬山的风景还是很不错的。 国庆节结束后，疫情就复发了，后面就封校了，出不去了。 2022年11月13日，实验室小伙伴拿到一等奖学金请全实验室吃饭。 2022年12月11日，本人开题答辩，加上论文的返修，这两周忙的不可开交。 2022年12月12日，实验室另一位小伙伴拿到一等奖学金请全实验室吃饭。 2022年12月18日，学校疫情太严重了，加上实验室也有不少小伙伴发烧发热有感染迹象，遂决定回家。 2022年12月21日，本人体温异常，还是没能逃过发烧感染的厄运，感染了真的是全身疼痛难受，浑身无力，在床上躺四五天才慢慢好转。 我的 2022 年度总结就到这里了，希望 2023 年能够更加顺利，更加快乐，更加幸福。 ","link":"https://blog.zhawenwen.cn/post/2022/"},{"title":"使用 docker 构建镜像文件的方法","content":"使用 docker 构建镜像文件，实现一次构建处处使用，从而减少开发难度。 本文使用 web静态文件 与 vue开发文件 为例，使用 Dockerfile 构建docker镜像。 使用 docker 构建镜像文件的方法 使用 docker 构建镜像文件，实现一次构建处处使用，从而减少开发难度。 使用 docker 构建镜像文件的方法 1. Dockerfile 文件中相关指令 FROM：镜像的基础系统环境 RUN：用于执行后面跟着的命令行命令 COPY ：复制指令，从上下文目录中复制文件或者目录到容器里指定路径。 ADD：ADD 指令和 COPY 的使用格式类似（同样需求下，官方推荐使用 COPY），功能也类似。 CMD：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。 ENV：设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。 EXPOSE： 仅仅只是声明端口 WORKDIR：指定工作目录。 2. 静态网站的 docker 镜像创建 2.1 首先需要在一个文件夹中准备三个文件（夹） 2.2 Dockerfile 文件内容 2.3 default.conf 文件内容 2.4 构建 docker 镜像并运行 docker 容器 3. Nodejs构建的网站的 docker 镜像创建 3.1 准备工作 3.2 Dockerfile 文件内容 3.3 构建 docker 镜像并运行 docker 容器 1. Dockerfile 文件中相关指令 Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。 相关指令含义： FROM：镜像的基础系统环境 格式： FROM nginx 或 FROM node:latest RUN：用于执行后面跟着的命令行命令 有两种格式： RUN &lt;命令&gt; RUN [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;] COPY ：复制指令，从上下文目录中复制文件或者目录到容器里指定路径。 有两种格式： COPY &lt;原路径&gt; &lt;目标路径&gt; COPY [&quot;&lt;原路径&gt;&quot;, &quot;&lt;目标路径&gt;&quot;] &lt;目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。 ADD：ADD 指令和 COPY 的使用格式类似（同样需求下，官方推荐使用 COPY），功能也类似。 CMD：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。 类似于 RUN 指令，用于运行程序，但二者运行的时间点不同： RUN 是在 docker build 时运行的 CMD 是在 docker run 时运行的 注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。 格式： CMD &lt;命令&gt; CMD [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;] ENV：设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。 格式： ENV &lt;key&gt; &lt;value&gt; ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; 若设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用 EXPOSE： 仅仅只是声明端口 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。 运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 WORKDIR：指定工作目录。 用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。 格式： WORKDIR &lt;工作目录路径&gt; 2. 静态网站的 docker 镜像创建 2.1 首先需要在一个文件夹中准备三个文件（夹） 静态网站所在目录 /dist Dockerfile 镜像构建文件 default.conf nginx默认配置文件 2.2 Dockerfile 文件内容 # 拉取 nginx 镜像 FROM nginx:latest # 将静态网站文件夹拷贝到 nginx 镜像中的对应文件夹中 COPY ./dist /usr/share/nginx/html/ # 将 nginx 配置文件拷贝到 nginx 镜像中对应文件夹中 COPY ./default.conf /etc/nginx/conf.d/ # 声明暴露端口号为 9000 EXPOSE 9000 2.3 default.conf 文件内容 server { # nginx 监听的端口号，对外暴露端口 listen 9000; server_name localhost; gzip on; gzip_min_length 1k; gzip_comp_level 9; gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml; gzip_vary on; gzip_disable &quot;MSIE [1-6]\\.&quot;; # 路径匹配 location / { # 静态文件所在文件夹，需与 Dockerfile 中配置一样 root /usr/share/nginx/html; index index.html index.htm; try_files $uri $uri/ /index.html; } } default.conf 中配置了网站对外暴露端口，最好与 Dockerfile 文件中端口一致 2.4 构建 docker 镜像并运行 docker 容器 # 开始构建镜像 -t 构建镜像的名称:镜像版本 . 表示当前目录 docker build -t test:v1 . # 根据构建出的镜像创建运行容器 # -i 以交互模式运行容器，通常与 -t 同时使用 # -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用 # -d 后台运行容器，并返回容器ID # -p docker 容器内外端口映射 # --name 运行容器的名称 # 最后跟上容器镜像的名称 docker run -itd -p 9000:9000 --name test_hello test:v1 # 在浏览器使用 ip:9000 访问网站 3. Nodejs构建的网站的 docker 镜像创建 Nodejs构建的网站：例如 VUE 等 3.1 准备工作 需要提前准备以下两个内容： Dockerfile 文件 vue 开发的网站目录中 将 Dockerfile 文件放到 vue 开发的网站目录中，如下图所示： 3.2 Dockerfile 文件内容 FROM node:12 # 复制代码 # 将当前目录所有文件复制到 docker 中的 /app 目录中 ADD . /app # 设置容器启动后默认运行的目录为 /app WORKDIR /app # 运行命令，安装依赖 # RUN 命令可以有多个，可以使用 &amp;&amp; 连接来减少层级 RUN npm install # CMD 指令只能有一个，是容器启动后默认运行的命令，是程序的入口 CMD [&quot;npm&quot;, &quot;run&quot;, &quot;serve&quot;] # 暴露端口，该端口是 npm run 运行暴露出的端口 EXPOSE 8080 3.3 构建 docker 镜像并运行 docker 容器 # 开始构建镜像 -t 构建镜像的名称:镜像版本 . 表示当前目录 docker build -t vue_test:v1 . # 根据构建出的镜像创建运行容器 # -i 以交互模式运行容器，通常与 -t 同时使用 # -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用 # -d 后台运行容器，并返回容器ID # -p docker 容器内外端口映射 # --name 运行容器的名称 # 最后跟上容器镜像的名称 docker run -itd -p 8080:8080 --name vue_test_001 vue_test:v1 # 在浏览器使用 ip:8080 访问网站 ","link":"https://blog.zhawenwen.cn/post/web2docker/"},{"title":"windows to go 和 linux to go 制作教程","content":" 使用 ventoy 制作 windows to go 和 linux to go 教程，将系统装进U盘中随身携带 1. ventoy 介绍 2. 准备工作 3. windows to go 3.1 将 U盘初始化 3.2 虚拟磁盘安装 windows 操作系统 3.3 U盘启动 VHD 操作系统 4. linux to go 4.1 将 U盘初始化 4.2 虚拟磁盘安装 linux 操作系统 4.3 U盘启动 VHD 操作系统 5. 总结 使用 ventoy 制作 windows to go 和 linux to go 教程，将系统装进U盘中随身携带 1. ventoy 介绍 ventoy 是一个U盘启动盘制作工具。官方网址：https://www.ventoy.net/ 简单来说，Ventoy是一个制作可启动U盘的开源工具。 有了Ventoy你就无需反复地格式化U盘，你只需要把 ISO/WIM/IMG/VHD(x)/EFI 等类型的文件直接拷贝到U盘里面就可以启动了，无需其他操作。 你可以一次性拷贝很多个不同类型的镜像文件，Ventoy 会在启动时显示一个菜单来供你进行选择 (参见 截图)。 你还可以在 Ventoy 的界面中直接浏览并启动本地硬盘中的 ISO/WIM/IMG/VHD(x)/EFI 等类型的文件。 2. 准备工作 本教程并不是教你如何制作安装操作系统的 U盘启动盘，而是制作一个可以在 U盘中实时运行的系统，将 U盘当C盘使用，像随身携带一个自己的操作系统一样，可在其他电脑上直接启动。 首先你需要准备一下内容，提前准备好有助于节省大量时间： 安装有 windows10 以上版本的电脑一台 。 一个大容量 USB3.0 接口的U盘。（安装linux推荐32G+，安装windows推荐64G+） VirtualBox 虚拟机软件 ventoy 安装软件 3. windows to go windows to go 简称 wtg，wtg的教程有很多，目前市面上有很多工具可以直接将 U盘 一键转换成 wtg U盘，例如 萝卜头论坛的 WTGA 工具等等。https://bbs.luobotou.org/forum.php?mod=forumdisplay&amp;fid=88 但这些工具都是使用了整个 U 盘空间，使 U盘只能当系统盘使用，无法使用其内部的剩余空间，造成了资源的浪费。 本教程使用虚拟磁盘技术(VHD)，将 U盘中的一部分用于安装系统，另一部分还可当正常的 U盘使用，且两部分互不干扰。 本教程原理是使用虚拟磁盘技术，从 U盘中分出一部分固定空间，在固定空间中安装操作系统，然后使用 ventoy 软件引导操作系统的启动，从而实现在保留 U盘原始功能的条件下将操作系统运行在 U盘中。 3.1 将 U盘初始化 警告：U盘的文件系统建议使用 NTFS，FAT32会出问题。 使用 ventoy 软件将 U盘转换成 ventoy U盘，然后将U盘主分区格式化为 NTFS 格式。 使用 ventoy 工具将U盘转换成 ventoy U盘后，U盘主分区会变成 exFAT 格式，需要将其主分区格式化成 NTFS 格式，否则 windows to go 无法正常启动 3.2 虚拟磁盘安装 windows 操作系统 警告：本教程使用的是 VirtualBox 软件，其他虚拟机软件可能会出现问题。 打开 VirtualBox 软件新建虚拟电脑，创建固定大小的 VHD，注意只支持静态大小的，不支持动态扩展类型的。大小为40G左右，这个大小可以根据自己的需要进行调整，位置放在本地磁盘中，后期需要拷贝到U盘中。 注意勾选上 EFI，使文件既能在 Legacy BIOS 模式下启动，也能在 UEFI 模式下启动。 然后在 VirtualBox 中创建好的虚拟电脑中安装 windows 操作系统。正常安装即可。 3.3 U盘启动 VHD 操作系统 将上面创建的安装好操作系统的虚拟磁盘VHD 拷贝到 U盘中。 要想在 U盘中启动 VHD 操作系统，还需要在 U盘中放置一个 Windows VHD 文件启动插件：ventoy_vhdboot.img 。 从下面任意一个链接中下载 ventoy_vhdboot.img 文件即可（几个链接中的文件都是一样的）。 https://github.com/ventoy/vhdiso/releases https://ventoy.lanzoub.com/b01dlxuaj (蓝奏云，密码: 7my4) 把下载后的文件放在U盘第1个分区（就是放ISO文件的分区）的 ventoy 目录下（默认没有这个目录，需手动创建，注意大小写），即 /ventoy/ventoy_vhdboot.img 就可以了。 注意是放在容量大的、存放ISO文件的那个分区中，不要放到那个 32MB 的 VTOYEFI 分区里面。 然后重启电脑选择U盘启动，选择 VHD 操作系统启动即可。 4. linux to go linux to go 是一种在 U盘中运行 linux 操作系统的技术，本教程使用的是 ubuntu2004 ，即将 ubuntu2004 操作系统安装到 U盘中，然后使用 ventoy 软件引导操作系统的启动，从而实现在保留 U盘原始功能的条件下将操作系统运行在 U盘中。 4.1 将 U盘初始化 将U盘格式化为NTFS格式，然后使用 ventoy 软件将 U盘转换成 ventoy U盘。 4.2 虚拟磁盘安装 linux 操作系统 警告：本教程使用的是 VirtualBox 软件，其他虚拟机软件可能会出现问题。 打开 VirtualBox 软件新建虚拟电脑，创建固定大小的 vdi，注意只支持静态大小的，不支持动态扩展类型的。大小为20G左右，这个大小可以根据自己的需要进行调整，位置放在本地磁盘中，后期需要拷贝到U盘中。 注意勾选上 EFI，使文件既能在 Legacy BIOS 模式下启动，也能在 UEFI 模式下启动。 然后在 VirtualBox 中创建好的虚拟电脑中安装 ubuntu2004 操作系统。正常安装即可。 安装完成后，启动 VirtualBox中的虚拟电脑，进入 ubuntu2004 操作系统，然后下载 vtoyboot 脚本，这一步是为了在系统中做一些处理，以支持Ventoy启动。 vtoyboot 脚本下载地址：https://github.com/ventoy/vtoyboot/releases 下载的是 vtoyboot.xxx.iso 文件，解压得到 vtoyboot.sh 脚本文件，然后以root权限执行里面的脚本 sudo bash vtoyboot.sh ，执行成功后关机。 4.3 U盘启动 VHD 操作系统 将上面创建的安装好操作系统的虚拟磁盘VHD 拷贝到 U盘中。然后将文件的后缀名改为 .vtoy ,例如：ubuntu2004.vtoy 或者 ubuntu2004.vdi.vtoy。 然后重启电脑选择 U盘启动，选择 buntu2004.vdi.vtoy 操作系统启动即可。 5. 总结 U盘容量不能太小，vhd 与 vdi 大小一旦固定，后期无法更改，且 vhd 与 vdi 的大小就是操作系统里可见的最大空间。 U盘速度不能太慢，建议使用 USB3.0 以上接口的 U盘，否则会影响操作系统的运行速度。 windows to go 和 linux to go 安装完成后可以放在同一个 U盘中，但是启动时需要选择不同的启动项，按需运行。 部分参考链接： 【1】ventoy官网：新一代多系统启动U盘解决方案 【2】ventoy官方文档：Ventoy使用手册 【3】ventoy插件文档 【4】萝卜头IT论坛：Windows To Go优盘系统 【5】傲梅口袋系统(WinToGo)——将Win 10装进U盘 ","link":"https://blog.zhawenwen.cn/post/wtg_ltg/"},{"title":"搭建音频在线实时分类系统","content":"本人基于自我学习目的搭建了生猪音频实时分类系统，使用百度 EasyDL 零门槛AI开发平台训练音频分类模型，然后发布为公有云在线服务；之后使用 javascript + axios + wavesurfer 搭建前端展示界面用来展示实时分类的效果。 1. easydl 训练音频分类模型 1.1 上传数据并训练音频分类模型 1.2 发布训练好的模型 2. 前端部署 1. easydl 训练音频分类模型 1.1 上传数据并训练音频分类模型 打开 easydl 官网：https://ai.baidu.com/easydl，点击立即使用，选择模型类型为声音分类。 进入声音分类界面后，点击模型中心的创建模型，填写需要创建的相关信息。 在 EasyData 数据服务中的数据总览中点击创建数据集，并给定数据集名称。 在数据总览中该数据集中点击导入按钮导入数据集，并按照要求导入有标注信息的压缩包数据。 数据要求：以文件夹命名分类，一个文件夹下就是一类数据，文件夹名就是该类别名，其中单个音频文件时长需要超过1秒。 例如：文件夹1命名为的 pig_eat 其中文件全为猪吃食叫声，文件夹2命名为的 pig_howl 其中文件全为猪嚎叫声。 查看数据是否导入成功并识别出有标记信息，未标记成功的数据可以在线进行重新标注。 点击模型中心的训练模型，选择刚刚创建的模型和数据集，训练方式选择公有云部署。然后点击开始训练进行模型训练。 在模型中心的我的模型中可以看到训练的结果。 1.2 发布训练好的模型 点击公有云在线服务，选择发布新服务，填写api地址，将刚刚训练好的模型进行发布。 进入网址 https://console.bce.baidu.com/ai/#/ai/easydlLiteVoice/app/list 中创建应用。 进入网址 https://console.bce.baidu.com/ai/#/ai/easydlLiteVoice/overview/index 配置公有云部署相关参数。 参考文档 声音分类模型如何发布为API，声音分类API调用文档，token鉴权认证机制 2. 前端部署 下载代码 https://gitee.com/qiaoyukeji/pigAuido_reco_show 替换API Key等后浏览器访问以下链接 注意：将 https://console.bce.baidu.com/ai/#/ai/easydlLiteVoice/app/list 中的 API Key 和 Secret Key填入下面的client_id 和client_secret后面 https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=ABC&amp;client_secret=ABC 将上图 access_token 的一串数字填入替换 index.js 中第52行的access_token处即可。 前端界面展示 本文首发于本人博客：https://blog.gitnote.cn/post/pigAuido_reco_show/ 版权信息: CC BY-NC-SA 4.0 (自由转载-非商用-相同方式共享-保持署名) ","link":"https://blog.zhawenwen.cn/post/pigAuido_reco_show/"},{"title":"北京超级云计算中心操作训练指南","content":"本人在实验室做深度学习图像领域相关研究，前期使用实验室的设备 2080Ti ，运行时间较慢；跑一轮需要6个小时以上；后来开始使用超算，运行速度比实验室快多了，但超算使用前需要相关配置，使用难度相较于本地会难一点，本文以北京超级云计算中心和 yolov5 训练为例，详细介绍超算的环境安装与计算过程。 一、获取账号 二、安装环境 2.1 安装系统软件 2.2 配置 yolov5 深度学习环境 三、训练数据 3.1 创建 sub.sh 文件 3.2 提交训练 3.3 查看提交结果 3.4 查看训练结果 一、获取账号 使用超算首先需要的当然是需要有超算的使用权限以及超算的账号了。本文主要以北京超级云计算中心为例。 首先在百度、知乎等平台搜索北京超级云计算中心试用，找到申请的表单，提交申请即可。学校教师或学生使用教育网邮箱概率更大哦。 申请试用后大约 1~2 天，北超云会依据你留的手机号给你打电话，电话里会沟通一些超算中心试用节点等信息。 电话沟通后大于 1~2 天内会收到超算账号开通的邮件，届此获取账号环节结束。 二、安装环境 根据邮件中的网址 https://cloud.blsc.cn/ 与账号密码登陆超算平台网页版，或下载客户端登陆。登陆后界面如下图所示。 2.1 安装系统软件 在运行前需要安装一些必要软件。打开桌面应用中心，找到 ssh、WinScp 等选择并安装。 ssh 用户链接超算账号，执行超算命令。 WinScp 用于查看、上传、下载超算节点的文件。 其他软件按需求安装。 2.2 配置 yolov5 深度学习环境 使用 SSH 链接超算节点后，需要在节点内配置运行环境。 超算节点安装好了一些默认环境，使用 module avail 可查看节点可用的软件列表。 使用 module load anaconda/2020.11 加载 anaconda 环境。 使用 conda creat -n torch110 Python=3.8 创建一个名为 torch110 的 python3.8 的虚拟环境。 使用 module load cuda/11.3 加载 cuda/11.3 环境。 使用 source activate torch110 激活 python 虚拟环境。 使用 conda install pytorch==1.10.0 torchvision==0.11.0 torchaudio==0.10.0 cudatoolkit=11.3 -c pytorch -c conda-forge 安装 torch 1.10.0 环境，可依据需要自行安装其他 torch 版本环境。 然后使用 WinScp 工具将本地 yolov5 训练文件以及训练数据上传到超算节点的 run 文件夹下。 然后进入 yolov5 文件夹下，执行 pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 安装 yolov5 需要的运行环境。 三、训练数据 3.1 创建 sub.sh 文件 在上传的 run/yolov5 文件夹下新建文件 sub.sh。 在 sub.sh 中填入一下内容: # sub.sh # #!/bin/sh # 加载 anaconda module load anaconda/2020.11 # 加载 cuda 11.3 module load cuda/11.3 # 激活 python 虚拟环境 source activate torch110 export PYTHONUNBUFFERED=1 # yolov5 python 训练的的命令（此处需要自己依据自己训练的需要进行修改） python train.py --img 640 --batch 16 --epoch 100 --data dataset/data/voc2007.yaml --cfg dataset/yolov5s_1.yaml --weights weights/yolov5s.pt 3.2 提交训练 使用 ssh 工具进入 sub.sh 根目录中，执行 sbatch --gpus=GPU数量 程序运行脚本 ,例如 sbatch --gpus=1 ./sub.sh 提交需要训练的数据到超算的计算节点。 3.3 查看提交结果 查看已提交作业 parajobs 其中， 第一列 JOBID 是作业号，作业号是唯一的。 第二列 PARTITION 是作业运行使用的队列名。 第三列 NAME 是作业名。 第四列 USER 是超算账号名。 第五列 ST 是作业状态，R（RUNNING）表示正常运行，PD（PENDING）表示在排队，CG（COMPLETING）表示正在退出，S 是管理员暂时挂起，CD（COMPLETED）已完成，F（FAILED）作业已失败。只有 R 状态会计费。 第六列 TIME 是作业运行时间。 第七列 NODES 是作业使用的节点数。 第八列 NODELIST(REASON)对于运行作业（R 状态）显示作业使用的节点列表；对于排队作业（PD 状态），显示排队的原因。 取消作业 执行 scancel 作业ID 取消作业 scancel 20118812 进入计算节点中 使用 ssh 作业节点数 如 ssh g0012 进入当前提交训练的计算节点中，使用 nvidia-smi 可查看当前计算节点的运行情况。 3.4 查看训练结果 训练的全部日志保留在 run/yolov5 根目录中名为 slurm-XXX.out 文件中。 训练完成的结果与本地训练一样，存放在 run/yolov5/runs/train 中。 ","link":"https://blog.zhawenwen.cn/post/bscc_yolov5/"},{"title":"gitea 从 windows 服务器迁移到 linux  服务器中并使用 docker 部署","content":"gitea 从 windows 服务器迁移到 linux 服务器中并使用 docker 部署 1. 在原来的 gitea 安装位置备份所有目录文件以及导出数据库文件 首先在服务器中创建 docker-compose.yaml 文件 docker-compose.yaml 内容 version: &quot;3&quot; # 创建mysql和gitea专用网络 networks: gitea: external: false services: server: # 指定gitea镜像及版本 image: gitea/gitea:1.15.0 # 指定容器别名 container_name: gitea # 配置容器环境 environment: - USER_UID=1000 - USER_GID=1000 - DB_TYPE=mysql - DB_HOST=db:3306 - DB_NAME=gitea - DB_USER=gitea - DB_PASSWD=gitea # 开机自启 restart: always # 指定容器使用的网络 networks: - gitea # 配置挂载卷 volumes: - ./data:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro # 配置端口映射 ports: - &quot;3000:3000&quot; - &quot;222:22&quot; # 指定依赖(先安装依赖) depends_on: - db db: image: mysql:8.0 restart: always environment: - MYSQL_ROOT_PASSWORD=gitea - MYSQL_USER=gitea - MYSQL_PASSWORD=gitea - MYSQL_DATABASE=gitea networks: - gitea volumes: - ./mysql:/var/lib/mysql 启动 docker-compose up -d 输入网址 ip:3000 配置安装 安装完成后进入 docker 中恢复备份的数据 首先恢复数据库数据 首先将备份的 sql 文件拷贝到 docker-compose.yaml 文件中 mysql 配置的映射文件夹 data 进入 docker 的 mysql 容器中 docker exec -it 容器ID /bin/bash 然后找到 mysql 目录下的 sql 文件 cd /var/lib/mysql &amp;&amp; ls 然后进入 mysql 数据库中导入备份文件mysql -u gitea -p # 输入mysql 密码登陆 show databases; use gitea; source beifen.sql; 至此数据库文件已恢复完成 然后恢复存储仓库 repositories 将备份的 repositories 目录中的全部文件拷贝到 docker-compose.yaml 文件中 gitea 配置的映射文件夹 ./data/git/repositories 即可 最后恢复个人配置文件 Custom 首先在 docker-compose.yaml 文件中的 gitea 中添加以下内容environment: - GITEA_CUSTOM=/data/custom 然后将备份的 custom 文件夹中的全部文件复制到 ./data/custom 中 之后修改 custom&gt;conf&gt;app.ini 中的 RUN_USER = git 然后重启 gitea 即可 至此所有文件恢复完成 ","link":"https://blog.zhawenwen.cn/post/gitea_copy_windows2linux/"},{"title":"根据静态网站文件创建 docker 镜像并运行容器","content":" 静态网站创建 docker 镜像 1. 首先在一个文件夹中准备三个文件（夹） 1.1 静态网站所在目录 /dist 1.2 Dockerfile 镜像构建文件 1.3 default.conf nginx 默认配置文件 2. Dockerfile 文件 # 拉取 nginx 镜像 FROM nginx:latest # 将静态网站文件夹拷贝到 nginx 镜像中的对应文件夹中 COPY ./dist /usr/share/nginx/html/ # 将 nginx 配置文件拷贝到 nginx 镜像中对应文件夹中 COPY ./default.conf /etc/nginx/conf.d/ # 声明暴露端口号为 9000 EXPOSE 9000 3. default.conf nginx 默认配置文件 server { # nginx 监听的端口号 listen 9000; server_name localhost; gzip on; gzip_min_length 1k; gzip_comp_level 9; gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml; gzip_vary on; gzip_disable &quot;MSIE [1-6]\\.&quot;; # 路径匹配 location / { # 静态文件所在文件夹，需与 Dockerfile 中配置一样 root /usr/share/nginx/html; index index.html index.htm; try_files $uri $uri/ /index.html; } } 4. 开始构建镜像并运行容器 # 开始构建镜像 -t 构建镜像的名称：版本 . 表示当前目录 docker build -t qiaoyu/jetlinks_ui_big_screen:v1 . # 根据构建出的镜像创建运行容器 # -i 以交互模式运行容器，通常与 -t 同时使用 # -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用 # -d 后台运行容器，并返回容器ID # -p docker 容器内外端口映射 # --name 运行容器的名称 # 最后跟上容器镜像的名称 docker run -itd -p 9000:9000 --name jetlinks_ui_big_screen qiaoyu/jetlinks_ui_big_screen:v1 5. 将 docker 镜像同步推送保存到阿里云中 首先在阿里云容器镜像服务中创建该镜像仓库 在本地 docker 环境中登陆阿里云 Docker Registrydocker login --username=qiaoyurens****@163.com registry. cn-hangzhou.aliyuncs.com 在本地为需要推送到阿里云的镜像大个标记，将其归入某一仓库docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/qiaoyu/jetlinks_ui_big_screen:[镜像版本号] 将本地镜像推送到阿里云平台中docker push registry.cn-hangzhou.aliyuncs.com/qiaoyu/jetlinks_ui_big_screen:[镜像版本号] ","link":"https://blog.zhawenwen.cn/post/html2docker/"},{"title":"yolov5_web_在线识别图片","content":" 项目介绍： 前期实验室已对生猪脸部进行图像识别训练，效果良好，现需要一个在线程序用来上传图片，识别出猪脸的位置，并将猪脸框出来。于是本文档就是用来实现这个功能的。 准备工作： 本次项目打算使用 web 端的方式来实现，技术栈：python+flask+vue+docker，程序主要使用开源程序 https://github.com/qiaoyukeji/Yolov5-Flask-VUE 修改部署。Yolov5-Flask-VUE 下载后有两个目录，其中 bach-end 为后端程序，front-end 为前端程序。 本次使用 docker 部署识别程序的后端程序。 识别程序前端使用 vue ，本地需要先安装 nodejs 一. Yolov5-Flask-VUE 后端程序部署 Yolov5-Flask-VUE 后端程序部署本人将采用 docker 进行部署，由于后端程序需要调用 CPU/GPU 进行深度处理，并且需要相关深度学习环境，所以本人提供已安装好 torch 1.10.1 和 torchvision 0.11.2 环境的 docker 镜像。 镜像地址：https://registry.cn-hangzhou.aliyuncs.com/qiaoyu/docker_opencv_torch:v2 依据 docker 镜像构建 docker 容器# 1. 拉取 docker 镜像 docker pull registry.cn-hangzhou.aliyuncs.com/qiaoyu/docker_opencv_torch:v2 # 2. 依据镜像构建容器 # 端口为后端程序 app.py 中开放的端口，目录为后端程序将要放的目录 docker run -it -p 15003:15003 -v ./yolov5_reco:/soft/yolov5_reco --name yolov5_web_reco docker_opencv_torch:v2 将后端程序 bach-end 拷贝到上面的./yolov5_reco 目录中 进入 docker 容器，运行后端代码程序# 1. 查看 docker 容器是否运行 docker ps # 2. 进入 docker 容器内部 docker exec -it 容器ID /bin/bash # 3. 进入代码目录 cd /soft/yolov5_reco # 4. 替换 weights 中的自有权重 # 5. 运行 程序 python app.py # 6. 初次运行程序时，会报部分python库未安装，依报错安装即可 修改 app.py 里 3 个 ip 地址 app.run()里 ip 修改为 0.0.0.0 其他两个位置 ip 修改为 docker 对外暴露的 ip 和对应端口, 如 172.17.XXX.99:15003 注意事项： 后端程序默认使用的权重为 yolov5 3.0版本，经本人测试 == yolov5 5.0 == 版本权重在修改 common.py (依据报错添加相关函数)后能正常运行，yolov5 6.0 版本无法运行。 2022.07.27 更新：更新 yolov5 6.0 版本支持 ，代码见 ：https://github.com/qiaoyukeji/Yolov5-Flask-VUE/tree/yolov5_6.0 二. 前端程序部署 在前端程序目录下运行 npm install 安装相关环境 修改ip地址：修改 src&gt;components&gt;Content.vue 中请求的 ip 地址为后端程序暴露的 ip 地址 运行 npm run serve 启动程序即可 ","link":"https://blog.zhawenwen.cn/post/yolov5_web_reco/"},{"title":"Jetson AGX Xavier 安装配置深度学习环境并部署 yolo 进行检测识别","content":"Jetson AGX Xavier 安装配置深度学习环境并部署 yolo 进行检测识别 Jetson AGX Xavier 安装配置深度学习环境并部署 yolo 进行检测识别 一. Jetson 开发板系统相关 1. jetson AGX Xavier 系统烧录 2. jetson AGX Xavier 系统信息查看 二、jetson 安装深度学习环境 1. CUDA 与 opencv 2. pytorch 与 torchvision 三、jetson 运行 yolo 相关程序 1. 下载 yolov5 默认程序 2. 选择下载 yolov5_t5) 第五版程序，因为本实验室的相关权重训练都是在 yolov5 第五版中进行的 四、jetson 运行 yolov5 猪脸相关程序 1. 本地运行yolov5原版并实时展示 2. 本地运行猪脸识别并实时展示 3. 本地运行猪脸识别并使用RTMP协议推流到 jetlinks-big-screen 页面进行实时展示 4. 程序接受 nanopc-T4 开发板采集 RTMP 视频流并调用猪脸识别再使用 RTMP协 议推流到 jetlinks-big-screen 页面进行实时展示 一. Jetson 开发板系统相关 1. jetson AGX Xavier 系统烧录 相关步骤：https://blog.csdn.net/tracy_baker/article/details/113741443 注意事项： 虚拟机必须为 ubuntu16.04 或 ubuntu18.04 虚拟机分配的空间必须大于100G 使用虚拟机安装 jetson SdkManager 时必须按照步骤进行换源，否则会有安装失败可能 Jetson 开发板及后续使用的 python 版本必须为 python3.6 jetson 系统中 python 虚拟环境不能使用 anaconda 进行管理，anaconda 会有无法安装 python3.6 虚拟环境的情况 SdkManager 默认安装的 CUDA 的版本为 10.2 jetson 中 CPU 为 ARMv8 架构，安装软件时必须选择 带有 ARMv8 或 aarch64 的安装包，一般的安装包无法安装 2. jetson AGX Xavier 系统信息查看 使用 jtop 命令查看系统 CPU、GPU、内存等的占用 安装：sudo pip install jetson-stats 使用：jtop 或 sudo jtop jinru 介绍： 使用 jtop 可以图形化查看系统相关资源占用情况，并修改相关系统参数（具体可自行搜索） 二、jetson 安装深度学习环境 1. CUDA 与 opencv CUDA10.2 与 opencv 4.1 在系统刷入中会被自动安装 2. pytorch 与 torchvision pytorch for Jetson 安装教程：Nvidia 官方教程 注意事项： python (虚拟)环境必须为 python3.6，Nvidai 提供的所有安装包都是基于 python3.6 版本的 pytorch 选择 PyTorch v1.10.0 （根据需要执行选择） torchVision 选择与 torch 相对应版本（torch v1.10.0对应 torchVision v0.11.1） Nvidia Jetson 开源插件包与框架合集：https://elinux.org/Jetson_Zoo 三、jetson 运行 yolo 相关程序 1. 下载 yolov5 默认程序 执行 pip install -r requirements.txt 安装 yolov5 需要的环境 默认下载的是 yolov5_t6 版，运行 python detect.py --weights yolov5s.py --source 0 --img 640 调用本地摄像头实时进行检测 2. 选择下载 yolov5_t5 第五版程序，因为本实验室的相关权重训练都是在 yolov5 第五版中进行的 执行 pip install -r requirements.txt 安装 yolov5 需要的环境 运行 python detect.py --weights yolov5s.py --source 0 --img 640 调用本地摄像头实时进行检测时会报错 注意事项； 默认下载的 yolov5 为第六版程序，本实验需要第五版，需要进行调整 yolov5_t5 默认使用 --source 0 调用本地摄像头会出错，解决方法在 Issues 2875 yolov5_t5 使用本地视频进行检测时，默认不会 imshow，需要修改代码 四、jetson 运行 yolov5 猪脸相关程序 1. 本地运行yolov5原版并实时展示 # --weights 相关权重 # --source 0：表示使用本地摄像头 rtmp://xxx 表示使用网络直播源 xxx.mp4 表示使用本地视频 # --img-size 表示识别的图片大小 python detect.py --weights yolov5s.pt --source 0 --img-size 640 2. 本地运行猪脸识别并实时展示 # --weights 相关权重 # --source 0：表示使用本地摄像头 rtmp://xxx 表示使用网络直播源 xxx.mp4 表示使用本地视频 # --img-size 表示识别的图片大小 # 使用一头猪的权重实时检测一头猪的视频 python detect001.py --weights try/pig_1/best.pt --source try/pig_1/pig_1.mp4 --img-size 640 3. 本地运行猪脸识别并使用RTMP协议推流到 jetlinks-big-screen 页面进行实时展示 # --weights 相关权重 # --source 0：表示使用本地摄像头 rtmp://xxx 表示使用网络直播源 xxx.mp4 表示使用本地视频 # --img-size 表示识别的图片大小 # 使用一头猪的权重实时检测一头猪的视频 # detect002.py 中修改增加了RTMP推流的部分代码 python detect002.py --weights try/pig_1/best.pt --source try/pig_1/pig_1.mp4 --img-size 640 4. 程序接受 nanopc-T4 开发板采集 RTMP 视频流并调用猪脸识别再使用 RTMP协 议推流到 jetlinks-big-screen 页面进行实时展示 # --weights 相关权重 # --source 0：表示使用本地摄像头 rtmp://xxx 表示使用网络直播源 xxx.mp4 表示使用本地视频 # --img-size 表示识别的图片大小 # 使用一头猪的权重实时检测一头猪的视频 # detect004_rtmp2rtmp.py 中修改增加了RTMP推流的部分代码 # 运行本代码前需要先在 nanopc-T4 开发板中运行实时视频采集与推流程序，之后本程序才能接收到 RTMP 视频流 # nanopc-T4中程序：https://gitee.com/qiaoyukeji/nanopc2jetlinks4mqtt/blob/master/test_007_rtmp2jetson/rtmp001.py python detect004_rtmp2rtmp.py --weights try/pig_1/best.pt --source rtmp://42.192.123.52/live/jetson --img-size 640 ","link":"https://blog.zhawenwen.cn/post/jetson-yolov5-pig-detect/"},{"title":"静态网站创建 docker 镜像并推送到阿里云","content":"静态网站创建 docker 镜像并推送到阿里云 静态网站创建 docker 镜像并推送到阿里云 1. 首先在一个文件夹中准备三个文件（夹） 2. Dockerfile 文件 3. default.conf nginx 默认配置文件 4. 开始构建镜像并运行容器 5. 将 docker 镜像同步推送保存到阿里云中 1. 首先在一个文件夹中准备三个文件（夹） 1.1 静态网站所在目录 /dist 1.2 Dockerfile 镜像构建文件 1.3 default.conf nginx 默认配置文件 2. Dockerfile 文件 # 拉取 nginx 镜像 FROM nginx:latest # 将静态网站文件夹拷贝到 nginx 镜像中的对应文件夹中 COPY ./dist /usr/share/nginx/html/ # 将 nginx 配置文件拷贝到 nginx 镜像中对应文件夹中 COPY ./default.conf /etc/nginx/conf.d/ # 声明暴露端口号为 9000 EXPOSE 9000 3. default.conf nginx 默认配置文件 server { # nginx 监听的端口号 listen 9000; server_name localhost; # jetlinks 文档中要求 gzip on; gzip_min_length 1k; gzip_comp_level 9; gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml; gzip_vary on; gzip_disable &quot;MSIE [1-6]\\.&quot;; # 路径匹配 location / { # 静态文件所在文件夹，需与 Dockerfile 中配置一样 root /usr/share/nginx/html; index index.html index.htm; try_files $uri $uri/ /index.html; } # jetlinks 文档要求，用以链接 jetlinks 后端 location ^~/jetlinks/ { proxy_pass http://42.192.123.52:8848/; #修改此地址为后台服务地址 proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_connect_timeout 1; proxy_buffering off; chunked_transfer_encoding off; proxy_cache off; proxy_send_timeout 30m; proxy_read_timeout 30m; client_max_body_size 100m; } } 4. 开始构建镜像并运行容器 # 开始构建镜像 -t 构建镜像的名称 . 表示当前目录 docker build -t qiaoyu/jetlinks_ui_big_screen:v1 . # 根据构建出的镜像创建运行容器 # -i 以交互模式运行容器，通常与 -t 同时使用 # -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用 # -d 后台运行容器，并返回容器ID # -p docker 容器内外端口映射 # --name 运行容器的名称 # 最后跟上容器镜像的名称 docker run -itd -p 9000:9000 --name jetlinks_ui_big_screen qiaoyu/jetlinks_ui_big_screen:v1 5. 将 docker 镜像同步推送保存到阿里云中 首先在阿里云容器镜像服务中创建该镜像仓库 在本地 docker 环境中登陆阿里云 Docker Registrydocker login --username=qiaoyurens****@163.com registry. cn-hangzhou.aliyuncs.com 在本地为需要推送到阿里云的镜像大个标记，将其归入某一仓库docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/qiaoyu/jetlinks_ui_big_screen:[镜像版本号] 将本地镜像推送到阿里云平台中docker push registry.cn-hangzhou.aliyuncs.com/qiaoyu/jetlinks_ui_big_screen:[镜像版本号] ","link":"https://blog.zhawenwen.cn/post/web2docker2aliyun/"},{"title":"搭建rtmp推流服务器与视频回看服务器","content":"本次使用 nginx-rtmp 搭建 rtmp 推流服务器，配置相关参数保存视频文件，然后使用 zfile 目录程序进行展示出来 本次使用 nginx-rtmp 搭建 rtmp 推流服务器，配置相关参数保存视频文件，然后使用 zfile 目录程序进行展示出来 1. 搭建 nginx-rtmp 服务端 2. 配置 nginx-rtmp 服务器用以实时保存串流视频 3. 使用 zfile 在线网盘程序搭建视频回看平台 1. 搭建 nginx-rtmp 服务端 首先服务器需要安装 dcoekr 容器服务，建议服务器使用 linux 操作系统。 这里使用 tiangolo/nginx-rtmp 来搭建 让他们怕服务器。 sudo docker pull tiangolo/nginx-rtmp 下载完成后启动该镜像，注意配置目录映射: sudo docker run -d -p 1935:1935 -v /media/docker/rtmp/video:/media/video --name nginx-rtmp tiangolo/nginx-rtmp 将本地目录 /media/docker/rtmp/video 映射到 docker 中目录 /media/video 以便将保存到 docker 容器中数据暴露出来。 之后使用地址 rtmp://ip/live/自行设置的密钥 即可推流到服务器中。 同样使用地址 rtmp://ip/live/自行设置的密钥 可查看播放串流视频。 2. 配置 nginx-rtmp 服务器用以实时保存串流视频 首先使用 docker ps -a 查看当前系统中的 docker 镜像。 使用 docker exec -it 容器ID /bin/bash 进入容器中 使用 apt-get update 更新源，使用 apt-get install vim 安装 vim 工具 使用 vim /etc/nginx/nginx.conf 修改配置文件rtmp { server { listen 1935; application live { live on; # 设置全部记录 record all; # 设置记录值唯一 record_unique on; # 设置视频缓存地址，需要与 docker 启动时配置的地址一致，以便映射到docker容器外 record_path &quot;/media/video&quot;; # 缓存文件后缀 record_suffix -%Y-%m-%d-%H_%M_%S.flv; } } } 之后使用 exit 退出 docker 容器内部，使用 docker restart 容器ID 重新启动该容器即可。 3. 使用 zfile 在线网盘程序搭建视频回看平台 zfile 文档地址为：https://docs.zfile.vip 使用以下 docker 命令一键搭建 zfile 平台 docker run -d --name=zfile --restart=always \\ -p 8080:8080 \\ -v /root/zfile/db:/root/.zfile/db \\ -v /root/zfile/logs:/root/.zfile/logs \\ -v /media/docker/rtmp/video:/media/video zhaojun1998/zfile 将 nginx-rtmp 映射出来保存视频的目录映射到 zfile 中，使 zfile 能访问到该目录。 之后打开网址 http://ip:8080 ，进行账户密码配置等配置，同时创建驱动器，将视频目录暴露出来。 ","link":"https://blog.zhawenwen.cn/post/da-jian-rtmp-tui-liu-fu-wu-qi-yu-shi-pin-hui-kan-fu-wu-qi/"},{"title":"nanopc-T4 开发板通过USB麦克风采集录制音频","content":" 1. 使用 nanopc-T4 开发板采集音频 2. 使用 Tyless 录制声音 3. 使用 ffrmpeg 将实时视频与音频合并并推流到 rtmp 服务器中 4. 成功实现opencv采集图像与音频合并推送到rtmp 1. 使用 nanopc-T4 开发板采集音频 使用开发板采集音频时，总是报错，通过查阅很多资料后，逐渐有了一些头绪。 使用 arecord -l 命令可以查看当前系统的录音设备。 由此可以看出，当前系统有两个 USB Audio 设备，分别为 Tyless 外置录音和 C920 摄像头自带的录音设备。 root@NanoPC-T4:/home/pi/projects/nanopc/nanopc2jetlinks4mqtt# arecord -l **** List of CAPTURE Hardware Devices **** card 0: realtekrt5651co [realtek,rt5651-codec], device 0: ff880000.i2s-rt5651-aif1 rt5651-aif1-0 [] Subdevices: 1/1 Subdevice #0: subdevice #0 card 3: Tyless [Tyless], device 0: USB Audio [USB Audio] Subdevices: 1/1 Subdevice #0: subdevice #0 card 4: C920 [HD Pro Webcam C920], device 0: USB Audio [USB Audio] Subdevices: 1/1 Subdevice #0: subdevice #0 使用指定声卡录音 root@NanoPC-T4:/home/pi/projects/nanopc/nanopc2jetlinks4mqtt# sudo arecord -D hw:4 -d 40 test.wav -r16000 -fS16_LE -c 2 Recording WAVE 'test.wav' : Signed 16 bit Little Endian, Rate 16000 Hz, Mono -D 表示指定设备,hw:x 表示第x个设备（使用命令 arecord -l 查看） -d 表示时间，单位为秒 'test.wav' 为录音保存的文件名 -r 表示设置频率 -f 为设置格式 -c 表示通道数 2. 使用 Tyless 录制声音 使用 arecord -l 查看 tyless 的设备号，input_device_index=3 设置频率 rate 为48000Hz 设置通道数 CHANNELS 为 1 具体代码如下（测试通过）： # name：008.py #录制音频 import wave import pyaudio CHUNK = 1024 FORMAT = pyaudio.paInt16 CHANNELS = 1 # RATE = 44100 RATE = 48000 #RATE = 22050 RECORD_SECONDS =30 p = pyaudio.PyAudio() #i=0 while True: #i=i+1 # 数据流 stream = p.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True,input_device_index=3, frames_per_buffer=CHUNK) print(&quot;开始录音!&quot;) frames = [] for i in range(0, int(RATE / CHUNK * RECORD_SECONDS)): data = stream.read(CHUNK,exception_on_overflow = False) frames.append(data) print(&quot;录音完毕！&quot;) # 停止数据流 stream.stop_stream() stream.close() # 关闭PyAudio #p.terminate()#不能这样操作，否则会出现不能循环的现 # 写入录音文件 wf = wave.open('011.wav', 'wb') wf.setnchannels(CHANNELS) wf.setsampwidth(p.get_sample_size(FORMAT)) wf.setframerate(RATE) wf.writeframes(b''.join(frames)) wf.close() print('音频数据写入完成') break; 具体代码 :https://gitee.com/qiaoyukeji/nanopc2jetlinks4mqtt/blob/master/test_005_audio/008.py 3. 使用 ffrmpeg 将实时视频与音频合并并推流到 rtmp 服务器中 ffmpeg \\ -f alsa -ac 2 -i hw:4,0 -r 48000 \\ -f v4l2 -r 10 -i /dev/video0 \\ -c:v libx264 -s 640x480 -pix_fmt yuv420p -preset ultrafast -g 20 -b:v 2500k \\ -c:a aac -ar 44100 \\ -threads 0 -bufsize 512k \\ -f flv rtmp://iot.gitnote.cn/live/test &amp;&gt; stream.log -f fmt 指定格式(音频或视频格式) -ac channels 设置声道数 -i filename 指定输入文件名，在linux下当然也能指定:0.0(屏幕录制)或摄像头 -r rate 桢速率(fps) -vcodec codec 强制使用codec编解码方式(copy to copy stream) -acodec codec 指定音频编码(copy to copy stream) -pix_fmt format 设置像素格式，“列表”作为参数显示所有支持的像素格式 -g int 设置图像组大小 -b 指定比特率(bits/s)，似乎ffmpeg是自动VBR的，指定了就大概是平均比特率 -ar rate 设置音频采样率 (单位：Hz) 具体参数含义见：https://www.scivision.dev/youtube-live-ffmpeg-livestream/ 4. 成功实现opencv采集图像与音频合并推送到rtmp 图像使用opencv调用摄像头采集并处理 音频使用 alsa 在 ffmpeg 命令行中采集 然后合并推送远程rtmp服务器中 相关代码见：https://gitee.com/qiaoyukeji/nanopc2jetlinks4mqtt/blob/master/test_005_audio/rtmp_001.py # 本代码实现 opencv 采集视频并使用ffmpeg与音频audio合并推送到远程 rtmp 服务器中 # rtmp_001.py # 需先自行安装FFmpeg，并添加环境变量 import cv2 import subprocess import datetime import numpy as np from PIL import Image, ImageDraw, ImageFont # RTMP服务器地址 # rtmp = r'rtmp://156756.livepush.myqcloud.com/live/test' # rtmp = r'rtmp://172.17.14.191/live/test' rtmp = r'rtmp://iot.gitnote.cn/live/test' # 读取视频并获取属性 cap = cv2.VideoCapture(0) cap.set(3, 640) # set video widht cap.set(4, 480) # set video height size = (int(640), int(480)) sizeStr = str(size[0]) + 'x' + str(size[1]) command = ['ffmpeg', '-y', # -y 覆盖已有文件 &quot;-thread_queue_size&quot;,&quot;102400&quot;, # 封装队列大小 ########### 音频采集相关参数 '-f', 'alsa', # -f fmt 指定格式(音频或视频格式) '-ac', '2', # -ac channels 设置声道数 '-i', 'hw:3,0', # -i filename 指定输入文件名，在linux下当然也能指定:0.0(屏幕录制)或摄像头 ############ 视频处理相关参数 # '-f', 'v4l2', '-f', 'rawvideo', # -f fmt 指定格式(音频或视频格式) '-vcodec','rawvideo', # -vcodec codec 强制使用codec编解码方式 '-pix_fmt', 'bgr24', # -pix_fmt format 设置像素格式，“列表”作为参数显示所有支持的像素格式 '-s', sizeStr, # -s size 分辨率 '-r', '25', # -r rate 桢速率(fps) '-i', '-', '-c:v', 'libx264', '-pix_fmt', 'yuv420p', '-preset', 'ultrafast', '-b:v','2000k', '-c:a', 'aac', # 设置音频格式 '-ar', '44100', # -ar rate 设置音频采样率 (单位：Hz) &quot;-threads&quot;,&quot;2&quot;, &quot;-bufsize&quot;,&quot;1024k&quot;, '-f', 'flv', rtmp] pipe = subprocess.Popen(command, shell=False, stdin=subprocess.PIPE) font = cv2.FONT_ITALIC # 字体 fourcc = cv2.VideoWriter_fourcc(*'XVID') #定义编解码器并创建VideoWriter对象，即输入四个字符代码即可得到对应的视频编码器（XVID编码器） out = cv2.VideoWriter('video1.avi', fourcc, 20.0, (640,480)) #参数：保存文件名，编码器，帧率，视频宽高 # 图片帧添加文字函数 def cv2ImgAddText(img, text, left, top, textColor=(0, 255, 0), textSize=20): if (isinstance(img, np.ndarray)): # 判断是否OpenCV图片类型 img = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)) # 创建一个可以在给定图像上绘图的对象 draw = ImageDraw.Draw(img) # 字体的格式 fontStyle = ImageFont.truetype( &quot;simsun.ttc&quot;, textSize, encoding=&quot;utf-8&quot;) # 绘制文本 draw.text((left, top), text, textColor, font=fontStyle) # 转换回OpenCV格式 return cv2.cvtColor(np.asarray(img), cv2.COLOR_RGB2BGR) while cap.isOpened(): success, frame = cap.read() cv2.putText(frame,(datetime.datetime.utcnow() + datetime.timedelta(hours=8)).strftime('%Y-%m-%d %H:%M:%S'), (15,40),font , 1, (255,255,255), 2) # cv2.putText(frame,'安徽农业大学智慧养殖平台：HF-001 ', (15,400),font , 1, (255,255,255), 2) # frame=cv2ImgAddText(frame,&quot;安徽农业大学智慧养殖平台：HF-XX-001&quot;,15,50,(255,255,255),24) if success: if cv2.waitKey(1) &amp; 0xFF == ord('q'): break pipe.stdin.write(frame.tostring()) out.write(frame) cap.release() pipe.terminate() cv2.destroyAllWindows() ","link":"https://blog.zhawenwen.cn/post/nanopc-t4-kai-fa-ban-tong-guo-usb-mai-ke-feng-cai-ji-lu-zhi-yin-pin/"},{"title":"nanopc-T4 通过 mqtt 协议与 jetlinks 平台互通基础功能 ","content":"nanopc-T4 通过 mqtt 协议与 jetlinks 平台互通基础功能 本目录代码实现了一个从 ARM_Linux 开发板采集传感器数据与视频数据并实时传输到 jetlinks 平台，并能实时从 jetlinks 平台获取控制信息的功能。 其中 come2go.py 实现了本地开发板通过 mqtt 协议实时发送传感器采集到的数据到 jetlinks 物联网平台，同时实时获取 jetlinks 下发的控制信息，根据控制信息调用 duoji.c 实时控制舵机云台的转动。 rtmp.py 实现了通过 opencv 实时采集摄像头的数据并使用 rtmp 协议通过自建 nginx-rtmp 服务器或腾讯云直播 将视频数据传输到 jetlinks 物联网平台中。 jetlinks 物联网平台部署在实验室工作站中，内网ip为：172.17.14.191 ，展示页面端口号为：9000，mqtt服务器端口号为：1883。 jetlinks 展示页面内网访问地址为：172.17.14.191:9000,通过natfrp内网穿透服务暴露到公网中，公网地址：iot2.gitnote.cn 。 jetlinks mqtt 服务器内网地址为：172.17.14.191:1883，通过 https://lanp.nioee.com 内网穿透服务暴露到公网中，公网访问地址为：139.155.180.XXX:10070。 nginx-rtmp 服务器使用 docker 部署在腾讯云（1.15.120.XXX）服务器中，并能实时保存视频文件到服务器中（修改文件支持），其访问地址为 iot.gitnote.cn:1935 或 1.15.120.XXX:1935. nginx-rtmp 服务器试试保存的视频通过 Zdir 搭建的目录展示程序通过 video.gitnote.cn 访问获取。 具体代码在 https://gitee.com/qiaoyukeji/nanopc2jetlinks4mqtt/tree/master/test_004_basicFountion ","link":"https://blog.zhawenwen.cn/post/nanopc-t4-tong-guo-mqtt-xie-yi-yu-jetlinks-ping-tai-hu-tong-ji-chu-gong-neng/"},{"title":"通过 mqtt 协议上报传感器数据到 jetlinks 平台","content":"由于本人在做物联网方面的数据采集与展示工作，需要用到 jetlinks 平台，之前的数据采集与传输一直使用的是 http 协议与 websocket 协议，而 jetlinks 社区版不支持 http 与 websocket 协议，于是将之前的 nanopc 数据发送协议修改为 mqtt 协议。通过修改与调试，现已能成功通过程序自动上报相关数据，特此记录。同时使用 jetlinks 平台自带的通知模板实现了超阈值自动报警等功能。但 mqtt 协议与 jetlinks 平台使用尚不熟练，部分功能暂无实现，希望后期能进一步了解其原理。 使用 javascript 和 python 将属性值发送到 jetlinks 物联网平台 1. 使用javascript实现与平台通信 var mqtt = require('mqtt') var md5 = require('md5-node') // 用户设置的账号与密码 var secureId= 'ahau' var secureKey='ahau' var now = new Date().getTime(); //当前时间戳 // 转换账号与密码 var username_1 = secureId+&quot;|&quot;+now; // 拼接用户密码 var password_1 = md5(username_1+&quot;|&quot;+secureKey); //使用md5生成摘要 const options = { clean: true, // 保留回话 connectTimeout: 4000, // 超时时间 // 认证信息 clientId: 'ZN_001_001', username: username_1, password: password_1, } } // http://doc.jetlinks.cn/basics-guide/mqtt-auth-generator.html // 设置链接的mqtt服务器地址 // const connectUrl = 'mqtt://1.15.120.107:1883'; const connectUrl = 'mqtt://172.17.14.191:1883'; const client = mqtt.connect(connectUrl, options); wendu=30 shidu=40 client.on('connect', function () { console.log(111); setInterval(function(){ // publish(topic,msg) 上报属性数据 msg为str格式 client.publish(&quot;/ZN_001/ ZN_001_001/properties/read/reply&quot;,' {&quot;properties&quot;: {&quot;wendu&quot;:'+ wendu+', &quot;shidu&quot;:'+shidu+'}, &quot;deviceId&quot;: &quot;ZN_001_001&quot;,&quot;success&quot;: &quot;true&quot;}'); wendu+=1 shidu+=1 },3000) console.log(222); }) client.on('message', (topic, payload, packet) =&gt; { console.log('packet:', packet) console.log('Received Message:', topic, payload.toString()) }) 2. 使用python实现与平台通信 # python 3.6 import random import time import hashlib from paho.mqtt import client as mqtt_client import time t = time.time() def str2md5(str): m = hashlib.md5() # 创建md5对象 str_en = str.encode(encoding='utf-8') # str必须先encode m.update(str_en) # 传入字符串并加密 str_md5 = m.hexdigest() # 将MD5 hash值转换为16进制数字字符串 return str_md5 # 13位 时间戳 (毫秒) int(round(t * 1000)) # 设置用户名密码 secureId= 'ahau' secureKey='ahau' now = int(round(t * 1000)); #//当前时间戳 username_1 = secureId+&quot;|&quot;+str(now); #// 拼接用户密码 password_1 = str2md5(username_1+&quot;|&quot;+secureKey); #//使用md5生成摘要 print(&quot;username_1=&quot;+username_1) print(&quot;password_1=&quot;+password_1) # 设置mqtt服务器地址与端口 broker = 'iot.gitnote.cn' port = 1883 topic = &quot;/ZN_001/ZN_001_001/properties/report&quot; # generate client ID with pub prefix randomly client_id = &quot;ZN_001_001&quot; rc=0 def connect_mqtt(): def on_connect(client, userdata, flags, rc): if rc == 0: print(&quot;Connected to MQTT Broker!&quot;) else: print(&quot;Failed to connect, return code %d\\n&quot;, rc) client = mqtt_client.Client(client_id) client.username_pw_set(username_1,password_1) client.on_connect = on_connect client.connect(broker, port,60) return client # 模拟假数据 wendu=33.3 shidu=50 guangzhao=300 co2=150 NH3=14 # 发送的属性数据需要以字符串格式发送 msg=str({&quot;properties&quot;: {&quot;wendu&quot;: wendu,&quot;shidu&quot;:shidu,&quot;guangzhao&quot;:guangzhao,&quot;co2&quot;:co2,&quot;NH3&quot;:NH3},&quot;deviceId&quot;: &quot;ZN_001_001&quot;,&quot;success&quot;: 'true'}) def publish(client): msg_count = 0 while True: time.sleep(3) result = client.publish(topic, msg) global wendu global shidu wendu+=1.0 shidu+=1 print(&quot;wendu=&quot;,wendu,&quot;shidu=&quot;,shidu) # result: [0, 1] status = result[0] if status == 0: print(f&quot;Send `{msg}` to topic `{topic}`&quot;) else: print(f&quot;Failed to send message to topic {topic}&quot;) msg_count += 1 def run(): client = connect_mqtt() client.loop_start() publish(client) if __name__ == '__main__': run() 3. 在nanopc开发板上运行传感器采集与发送程序 import serial import time # 打开串口COM4，进行通信，四合一传感器,光照、湿度、二氧化碳、温度 ser = serial.Serial(&quot;/dev/ttyUSB1&quot;, 9600) # 打开串口COM5，进行通信,氨气参数 serN = serial.Serial(&quot;/dev/ttyUSB0&quot;, 9600) i=1 # python 3.6 import random import time import hashlib from paho.mqtt import client as mqtt_client import time t = time.time() def str2md5(str): '''使用MD5对字符串进行加密 Args: str (str): 需要加密的字符串 Returns: [str]: 32位字符串 ''' m = hashlib.md5() # 创建md5对象 str_en = str.encode(encoding='utf-8') # str必须先encode m.update(str_en) # 传入字符串并加密 str_md5 = m.hexdigest() # 将MD5 hash值转换为16进制数字字符串 return str_md5 # 13位 时间戳 (毫秒) int(round(t * 1000)) secureId= 'ahau' secureKey='ahau' now = int(round(t * 1000)); #//当前时间戳 username_1 = secureId+&quot;|&quot;+str(now); #// 拼接用户密码 password_1 = str2md5(username_1+&quot;|&quot;+secureKey); #//使用md5生成摘要 print(&quot;username_1=&quot;+username_1) print(&quot;password_1=&quot;+password_1) # broker = 'iot.gitnote.cn' broker = '172.17.14.191' port = 1883 topic = &quot;/ZN_001/ZN_001_001/properties/report&quot; # generate client ID with pub prefix randomly client_id = &quot;ZN_001_001&quot; rc=0 def connect_mqtt(): def on_connect(client, userdata, flags, rc): if rc == 0: print(&quot;Connected to MQTT Broker!&quot;) else: print(&quot;Failed to connect, return code %d\\n&quot;, rc) client = mqtt_client.Client(client_id) client.username_pw_set(username_1,password_1) client.on_connect = on_connect client.connect(broker, port,60) return client # wendu=33.3 # shidu=50 # guangzhao=300 # co2=150 # NH3=14 # 传感器数据采集函数 def getData(): if ser.is_open and serN.is_open: # 四合一传感器的控制命令 send_data = bytes.fromhex('01 03 00 00 00 04 44 09') # 氨气传感器的控制命令 send_dataN = bytes.fromhex('01 03 00 00 00 01 84 0A') # 向四合一传感器发送命令 ser.write(send_data) # 向氨气传感器发送命令 serN.write(send_dataN) # sleep中的单位为秒,传感器在300ms内响应 time.sleep(1) # 四合一传感器读到的长度 len_return_data = ser.inWaiting() print(len_return_data) # 氨气传感器读到的长度 len_return_dataN = serN.inWaiting() print(len_return_dataN) if len_return_data and len_return_dataN: # 四合一传感器读到的数据 return_data = ser.read(len_return_data) # 氨气传感器读到的数据 return_dataN = serN.read(len_return_dataN) # 四合一传感器转为十六进制 str_return_data = str(return_data.hex()) # 氨气传感器转为十六进制 str_return_dataN = str(return_dataN.hex()) serData={} # 数据转化部分 # CO2data global i print(i) i+=1 CO2data = (int(str_return_data[6:8], 16)) * 256 + int(str_return_data[8:10], 16) serData['co2']=CO2data # print('二氧化碳：%s ppm' % CO2data) # a1.value=CO2data #a1[0]=CO2data # wendata if int(str_return_data[10:12], 16) &lt; 127: wendata = (int(str_return_data[10:12], 16) * 256 + int(str_return_data[12:14], 16)) / 100 # print('温度：%s 度' % wendata) else: wendata = (((int(str_return_data[10:12], 16) &amp; 0x7F)) * 256 + int(str_return_data[12:14], 16)) / 100 # print('温度：%s' % wendata) serData['wendu']=wendata #a1[1]=wendata # a2.value=wendata # 湿度 shidudata = ((int(str_return_data[14:16], 16)) * 256 + int(str_return_data[16:18], 16)) / 100 # print('湿度：%s' % shidudata + '%RH') serData['shidu']=shidudata # a3.value=shidudata # 光照 guangzhaodata = ((int(str_return_data[18:20], 16)) * 256 + int(str_return_data[20:22], 16)) * 4 # print('光照：%s lx' % guangzhaodata) serData['guangzhao']=guangzhaodata # a4.value=guangzhaodata # 氨气 NH3data = int(str_return_dataN[6:8], 16) + int(str_return_dataN[8:10], 16) # print('氨气：%s ppm' % NH3data) serData['NH3']=NH3data # a5.value=NH3data return serData # msg=str({&quot;properties&quot;: {&quot;wendu&quot;: wendu,&quot;shidu&quot;:shidu,&quot;guangzhao&quot;:guangzhao,&quot;co2&quot;:co2,&quot;NH3&quot;:NH3},&quot;deviceId&quot;: &quot;ZN_001_001&quot;,&quot;success&quot;: 'true'}) # 将采集到的数据转换为字符串格式 msg=str({&quot;properties&quot;: getData()}); def publish(client): msg_count = 0 while True: time.sleep(3) # mqtt 发布 result = client.publish(topic, str({&quot;properties&quot;: getData()})) # global wendu # global shidu # wendu+=1.0 # shidu+=1 # print(&quot;wendu=&quot;,wendu,&quot;shidu=&quot;,shidu) print(msg) # result: [0, 1] status = result[0] if status == 0: print(f&quot;Send `{msg}` to topic `{topic}`&quot;) else: print(f&quot;Failed to send message to topic {topic}&quot;) msg_count += 1 def run(): client = connect_mqtt() client.loop_start() publish(client) if __name__ == '__main__': run() ","link":"https://blog.zhawenwen.cn/post/nanopc2jetlinks4mqtt/"},{"title":"2021年年度回顾（流水账）","content":"今天是2022年1月7日，2022年的第一个星期五，读研也已近半年时光，过去的2021年发生了很多事情，有快乐也有悲伤，更多的是无尽的收获，在此回顾我的过去的2021年，特此记录。 2021年年度回顾（流水账） 2020年12月26号研究生考试结束往后，有马不停蹄的回到合肥，整理东西撰写简历并投递，乘着年前还有一个多月，想找份工作干干，挣点钱减轻家里的压力，毕竟大学也都毕业了。 2021年1月1日，开始有公司发面试通知，面试了普联科技、新华三、江苏机器人等公司。 2021年1月3号，先后也有几家公司发了offer，但工资都不高，最高的也就新华三的测试，6k。 2021年1月4日，和新华三沟通的入职的相关事项，并推掉了其他公司offer。 2021年1月6日，体检结果出来了，血压过高，与企业沟通后，要求复检，再检血压依旧超过标准值。 2021年1月9日，与新华三沟通无果，加之年前的疫情加重，房子到期等多重事宜，遂选择回家。 2021年2月26日，考研的分数公布，本人分数过去年线，但排名不高，多方面考虑后，决定先外出闯闯。 2021年3月1日，从安庆出发到苏州。 2021年3月2日，从苏州出发去上海，到上海准备先住宾馆，边投递简历边找工作。说来也巧，朋友也在上海，于是在其盛情邀请下，先落脚他处。 2021年3月4、5日，投递简历，外出面试。 2021年3月7号，收到用友汽车的offer，通过华为上海机房运维二面，预约三面。 2021年3月10日，正式入职用友汽车数据库运维岗位。 2021年3月14日，租了一个小单间，离朋友不远，正式搬离朋友住处。 2021年3月18日，首发线下购入一台RedmiK40手机。 2021年3月23日，同时参加 燕山大学电子信息（085400）、华北理工大学网络空间安全（083900）和安徽农业大学计算机科学与技术（081200）的研究生调剂复试。 2021年3月25日，收到安徽农业大学计算机科学与技术专业拟录取通知，因是二战考研，心理压力较大，不敢继续等待，随即接受了该拟录取。 2021年3月26日，知道自己的成绩可以上华北理工大学，但因为已接受其他学校拟录取，只能被迫放弃。 2021年3月27日，和朋友们上海顾村公园一日游。 2021年3月30日，朋友到上海找工作，暂住我处。 2021年4月3日，上海东方明珠一日游。 2021年4月7日，第一次加班，加班到晚上8点多。 2021年4月17日，上海东方绿洲一日游。 2021年5月1日，上海动物园一日游。 2021年5月15日，上海当代艺术博物馆一日游。 2021年6月1日，公司发了端午礼盒，就是一盒粽子。 2021年6月4日，淘宝首发抢购的联想小新pro16（5600H+1650）到货拆箱。 2021年6月6日，和在上海几个大学室友约了上海科技馆一日游。 2021年6月14日，端午节，我过生日，却被安排值班，还好有三倍加班工资，还算可以。 2021年7月16日，公司部门聚餐，海鲜自助，但本人对海鲜不耐受，吃完就拉肚子了。 2021年7月18日，研究生录取通知书拿到。 2021年7月26日，开始上学校的网课了，机器学习和计算机视觉两门课。 2021年7月29日，回老家，办理助学等其他相关事宜。 2021年8月28日，两针新冠疫苗接种完毕。 2021年8月29日，世博会博物馆与中华艺术宫一日游。 2021年8月31日，因去合肥读研需要，从工作近6个月的公司离职了，3月10日到8月31日，几百个日日夜夜，就此道别了。 2021年9月10日，准备好各种材料正式去学校报道了。 2021年10月18日，假期两门网课的线下考试结束了，也标志着前一段时间学习就此结束了，可以好好放松下了。 2021年11月3日，学院的学术会议去帮忙，见识了不少正真的大佬，就是中午的盒饭不咋的，哈哈哈哈。 2021年11月14日，和实验室研一小伙伴大蜀山一日游，这是我第二次上大蜀山了，两次下山都走错了路，多绕了近两个小时。 2021年12月6日，实验室的机器人到了，下楼遛机器人去了。 2021年12月31日，学校农耕节，我们机器人也要被展览，哈哈哈哈。 2022年1月1日，共享租车出去玩，先是周边的共享汽车都被租完了，好不容易找到一车，刚起步就发现车胎爆了，只能重新去找，好一会儿才找到一辆提示发动机故障的车，但好在还能正常行驶，于是和小伙伴驾车去往巢湖边，游览了安徽渡江战役纪念馆。 ","link":"https://blog.zhawenwen.cn/post/2021/"},{"title":"vue-router中 query 传参和 params 传参的使用和区别","content":"vue-router中 query传参和params传参的使用和区别 1. 用法上 query 可以用 name 或 path 来引入 params 必需要用 name 来引入 接收参数都是类似的，分别是:this.$route.query.name和this.$route.params.name 2. 地址栏上 query ： /login?id=10&amp;name=zs params : /login/10/zs (提前在路由文件中定义过 id 与 name) 3. query 传参 3.1 路由 var router = new VueRouter({ routes: [ { path: '/login', component: login }, { name:'register',path: '/register', component: register } ] }) 3.2 导航 // 注意：这是 query 两种传参方式 一种是直接跳转把字符串传过去 一种是传描述目标位置的对象 &lt;router-link to=&quot;/login?id=10&amp;name=zs&quot;&gt;登录&lt;/router-link&gt; &lt;router-link :to=&quot;{path:'/register',query:{id:5,name:'lili'}}&quot;&gt;注册&lt;/router-link&gt; // 或 &lt;router-link :to=&quot;{name:'register',query:{id:5,name:'lili'}}&quot;&gt;注册&lt;/router-link&gt; // 等同于： this.$router.push('/login?id=10&amp;name=zs') this.$router.push({path:'/register',query:{id:5,name:'lili'}}) 或 this.$router.push({name:'register',query:{id:5,name:'lili'}}) query 可通过 name 和 path 引入路由 4. params 传参 4.1 路由 var router = new VueRouter({ routes: [ { path: '/login/:id/:name', component: login },// 这里不传入对应的参数（:/id/:name） 刷新页面 参数会消失,页面中就丢失了数据 { name:'register', path: '/register/:id/:name', component: register } ] }) 4.2 导航 // 注意：这是 params 两种传参方式 一种是直接跳转把字符串传过去 一种是传描述目标位置的对象 &lt;router-link to=&quot;/login/12/ls&quot;&gt;登录&lt;/router-link&gt; &lt;router-link :to=&quot;{name:'register',params:{id:10,name:'lili'}}&quot;&gt;注册&lt;/router-link&gt; // 等同于： this.$router.push('/login/12/ls') this.$router.push({name:'register',params:{id:10,name:'lili'}}) params 只能通过 name 来引入路由， path 会 undefined ","link":"https://blog.zhawenwen.cn/post/vue-router-query-params/"},{"title":"多个py文件同时执行（多进程与多线程实现）","content":"本人在编写python程序时，需要多个py文件在不同终端内同时运行，从而配合实现某种功能，经过多方查找与实验，排除了很多无法使用的方案，最终确定了以下两个方案，现将其记录下来，以免后期忘记，同时也给他人以参考！ 1.多进程执行程序 创建文件 run.py 并将以下文件修改后填入，之后运行 python run.py 即可。 #coding=utf-8 import time # from selenium import webdriver import threading import os # 根据需要填写需要运行的命令 def frpc(): os.system('/usr/local/bin/frpc') def httpServer(): os.system('python ./httpServer.py 8888 ') def face2rmtp(): os.system('python ./face2rmtp.py') threads = [] # threads.append(threading.Thread(target=frpc)) threads.append(threading.Thread(target=httpServer)) #args为函数接受的参数，多个 threads.append(threading.Thread(target=face2rmtp)) print(threads) if __name__ == '__main__': os.system('/usr/local/bin/frpc') for t in threads: t.setDaemon(True) #我拿来做selenium自动化模拟多个用户使用浏览器的时候，加了这个就启动不了，要去掉，原因找到了 : 加了这个是说明 主线程 执行完了 子线程也停止(无论是否执行完毕) t.start() t.join() # print(&quot;all over %s&quot; %ctime()) 2.多线程执行程序 创建文件 run.py 并将以下文件修改后填入，之后运行 python run.py 即可。 import time import multiprocessing import os # 根据需要填写需要运行的命令 def frpc(): os.system('/usr/local/bin/frpc') def httpServer(): os.system('python ./httpServer.py 8888 ') def face2rmtp(): os.system('python ./face2rmtp.py') if __name__ == '__main__': start = time.time() p1 = multiprocessing.Process(target=frpc,) p2 = multiprocessing.Process(target=httpServer,) p3 = multiprocessing.Process(target=face2rmtp,) # 启动子进程 p1.start() p2.start() p3.start() # 等待fork的子进程终止再继续往下执行，可选填一个timeout参数 p1.join() p2.join() p3.join() end = time.time() ","link":"https://blog.zhawenwen.cn/post/somePyRunTogether/"},{"title":"内网图像传输 opencv+socket","content":"前期实验需要图像远程传输，一直使用rtmp推流传输，但由于 rtmp 推流延迟过高，需要降低延时，本程序通过内网 opencv采集socket发送实现内网图像传输，延时较低，大约1s左右，初步能实现相关功能。 内网图像传输 opencv+socket 发送端（板子）程序 发送端（板子）程序，通过opencv采集图像，然后通过socket发送出去 import cv2 import socket import numpy as np cap = cv2.VideoCapture(10) # 设置图像宽高 v_width=640 v_height=480 # ip 与端口 port = 12346 ip=&quot;192.168.1.106&quot; cap.set(3,v_width) # set Width cap.set(4,v_height) # set Height s = socket.socket() img_param = [int(cv2.IMWRITE_JPEG_QUALITY), 95]#opencv 图像清晰度，帧数 #绑定ip地址和端口 s.bind((ip,port)) s.listen(5) #等待客户机连接 c,addr = s.accept() #接受客户机连接 while True: ret,frame = cap.read() frame = cv2.resize(frame, (v_width,v_height)) print(&quot;连接地址：&quot;+addr[0]) _, img_encode = cv2.imencode('.jpg', frame, img_param)#opencv图像编码 img_code = np.array(img_encode) img_data = img_code.tostring()#将数组格式转为字符串格式 # print(img_data) c.send(bytes(str(len(img_data)).ljust(16),encoding=&quot;utf8&quot;))# 先发送数据的长度 c.send(img_data)#再发送数据内容 cv2.imshow(&quot;主机&quot;,frame) if cv2.waitKey(1)==27: c.close() break cap.release() cv2.destroyAllWindows() 接受端程序 接受发送端采集的图像信息，并在接收端展示出来 import socket import cv2 import numpy as np import gzip port = 12346 ip=&quot;192.168.1.106&quot; def recv_all(s,count): buf=bytes() while count: newbuf = s.recv(count) if not newbuf:return None buf+=newbuf count-=len(newbuf) return buf s = socket.socket() host = socket.gethostname() while True: try: s.connect((&quot;192.168.1.106&quot;,port)) except: print(&quot;有错误&quot;) else: break while True: data_len = recv_all(s,16) if len(data_len) == 16: stringData = recv_all(s, int(data_len)) data = np.fromstring(stringData, dtype='uint8') tmp = cv2.imdecode(data, 1) # 解码处理，返回mat图片 img = cv2.resize(tmp, (1344, 768)) cv2.imshow('客户机', img) if cv2.waitKey(1) == 27: break s.close() 注意事项： 发送端设备与接收端设备需要在同一局域网下 发送端和接收端的 ip地址 需要一致且都为发送端的ip 发送端和接收端的 port端口号需一致且未被占用即可 发送端与接受端的延迟在 1s左右 运行时，先启动发送端程序，之后启动接受端程序 ","link":"https://blog.zhawenwen.cn/post/send_video_in_lan_opencv_socket/"},{"title":"opencv 形态学操作——腐蚀、膨胀、开运算、闭运算等","content":"1. opencv 形态学操作 腐蚀、膨胀、开运算、闭运算等 膨胀和腐蚀是图像形态学的两个基本操作. 典型应用是在二值图像中的使用，是很多识别技术中重要的中间处理步骤. 在灰度图像中根据阈值同样可以完成膨胀与腐蚀操作. 1.1 原理 二值图像fx,y 的膨胀操作，类似于对图像的卷积操作. 需要有个 kernel 操作矩阵，类似于卷积核filters,kernel，常见的是 3X3 的矩阵. 这是形态学处理的核心. 但与卷积不同的是，如果矩阵中的像素点有任意一个点的值是前景色，则设置中心像素点为前景色；否则不变. 1.2 图像形态学运算中腐蚀，膨胀，开运算和闭运算 1.2.1 腐蚀 腐蚀是一种消除边界点，使边界向内部收缩的过程可以用来消除小且无意义的物体. 腐蚀算法： 用 3x3 的 kernel，扫描图像的每一个像素； 用 kernel 与其覆盖的二值图像做 “与” 操作； 如果都为1，结果图像的该像素为1；否则为0. 结果：使二值图像减小一圈. 1.2.2 膨胀 膨胀是将与物体接触的所有背景点合并到该物体中，使边界向外部扩张的过程可以用来填补物体中的空洞. 膨胀算法： 用 3x3 的 kernel，扫描图像的每一个像素； 用 kernel 与其覆盖的二值图像做 “与” 操作； 如果都为0，结果图像的该像素为0；否则为1. 结果：使二值图像扩大一圈. 1.2.3 开运算 先腐蚀后膨胀的过程称为开运算 用来消除小物体、在纤细点处分离物体、平滑较大物体的边界的同时并不明显改变其面积. 1.2.4 闭运算 先膨胀后腐蚀的过程称为闭运算 用来填充物体内细小空洞、连接邻近物体、平滑其边界的同时并不明显改变其面积 1.3 opencv 代码实现 1.3.1 定义kernel 矩阵 kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3)) # 椭圆结构 kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (3, 3)) # 十字结构 kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3)) # 矩形结构 或使用 kernel = np.ones((3,3),np.uint8) # 同矩阵结构 1.3.2 腐蚀与膨胀 cv2.erode 和 cv2.dilate 函数 import cv2 import numpy as np img = cv2.imread('dige.png') kernel = np.ones((3,3),np.uint8) erosion = cv2.erode(img,kernel,iterations = 1) # 迭代次数 dilate = cv2.dilate(img,kernel,iterations = 1) res = np.hstack((img,erosion,dilate)) cv_show('dige and erode and dilate',res) 1.3.3 开运算和闭运算 cv2.morphologyEx 函数 # 开闭运算 import cv2 import numpy as np img = cv2.imread('dige.png') kernel = np.ones((5,5),np.uint8) opening = cv2.morphologyEx(img,cv2.MORPH_OPEN,kernel) closing = cv2.morphologyEx(img,cv2.MORPH_CLOSE,kernel) result = np.hstack((img,opening,closing)) cv2.imshow('open and close',result) cv2.waitKey(0) cv2.destroyAllWindows() ","link":"https://blog.zhawenwen.cn/post/opencv-xing-tai-xue-cao-zuo-fu-shi-peng-zhang-kai-yun-suan-bi-yun-suan-deng/"},{"title":"nanopc-T4_RK3399 舵机与人脸检测跟踪相关程序","content":"本人最近在 nanopc T4 开发板上做了一些小功能（完成导师安排的任务），初步实现了以下几个功能： 键盘控制 舵机上下左右旋转（两台舵机） nanopc-T4 开发板实现的人脸检测 根据人脸的位置控制舵机跟随人脸左右运动（人脸识别+人脸跟踪） nanopc-T4 开发板实现人脸识别 远程（http_get）控制舵机上下左右转动 舵机使用软件 PWM 驱动 解决舵机软件 PWM 驱动造成的抖动的一种方法 1. 键盘控制 舵机上下左右旋转（两台舵机） 2. nanopc-T4 开发板实现的人脸检测 3. 根据人脸的位置控制舵机跟随人脸左右运动（人脸检测+人脸跟踪） 4. nanopc-T4 开发板实现人脸识别 5. 远程（http_get）控制舵机上下左右转动 6. 舵机使用软件 PWM 驱动 7. 解决舵机软件 PWM 驱动造成的抖动的一种方法 1. 键盘控制 舵机上下左右旋转（两台舵机） #include &lt;wiringPi.h&gt; # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; void foo(int pinN,int moveAngle); // 接收一个输入度数 int main(void) { // pinN 为nanopc-T4 开发板上的引脚（以 Wpi脚 计数，通过 gpio readall 命令查看 wpi 引脚标号） // 物理引脚为 7、11 int pinN_1=7; int pinN_2=0; int num; wiringPiSetup() ; //设置舵机控制引脚 pinMode (pinN_1, OUTPUT) ; pinMode (pinN_2, OUTPUT) ; //设置初始旋转到90度 // 330-2400 (10~170度) int moveAngle_1=1365; int moveAngle_2=1365; foo(pinN_1,moveAngle_1); foo(pinN_2,moveAngle_2); for(;;){ printf(&quot;请输入移动方向，0表示左，1表示右,2表示上，3表示下\\n&quot;); scanf(&quot;%d&quot;,&amp;num); if(num==0||num==1){ if(num==0){ moveAngle_1=moveAngle_1-100; } if(num==1){ moveAngle_1=moveAngle_1+100; } foo(pinN_1,moveAngle_1); } if(num==2||num==3){ if(num==2){ moveAngle_2=moveAngle_2-100; } if(num==3){ moveAngle_2=moveAngle_2+100; } foo(pinN_2,moveAngle_2); } if(moveAngle_1&gt;2400||moveAngle_1&lt;320||moveAngle_2&gt;2400||moveAngle_2&lt;320){ printf(&quot;已到头！&quot;); break; } } printf(&quot;%d\\n&quot;, num); printf(&quot;%d\\n&quot;, moveAngle_1); printf(&quot;%d\\n&quot;, moveAngle_2); return 0; } void foo(int pinN,int moveAngle){ // 给舵机一段时间的反应，持续输出控制值 for (int i = 0; i &lt; 200; i++) { digitalWrite(pinN,HIGH); delayMicroseconds(moveAngle); digitalWrite(pinN,LOW); delayMicroseconds(2500-moveAngle); } printf(&quot;1&quot;); } 2. nanopc-T4 开发板实现的人脸检测 import numpy as np import cv2 # 获取opencv自带的用于人脸识别的级联分类器 faceCascade = cv2.CascadeClassifier('/media/pi/userdata/root/usr/local/share/OpenCV/haarcascades/haarcascade_frontalcatface.xml') eye_cascade = cv2.CascadeClassifier('/media/pi/userdata/root/usr/local/share/OpenCV/haarcascades/haarcascade_eye.xml') # 打开摄像头，本地自带的摄像头默认为0 cap = cv2.VideoCapture(10) cap.set(3,640) # set Width cap.set(4,480) # set Height i=0 range1=80 range2=60 # 设置舵机旋转90度时对应值 moveAngle_1=1435 while True: ret, img = cap.read() # 控制图像翻转给，1，左右翻转，-1，上下翻转 img = cv2.flip(img, 1) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = faceCascade.detectMultiScale( gray, # 表示每次图像检测的比例 scaleFactor=1.1, # 表示每一个目标至少要被检测到3次才算是真的目标 minNeighbors=3, minSize=(20, 20) ) for (x,y,w,h) in faces: cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2) print(&quot;%d,x = %d,x+w = %d,y = %d,y+h = %d&quot; %(i,x,x+w,y,y+h)) i+=1 # 框选出人脸区域，在人脸区域而不是全图中进行人眼检测，节省计算资源 face_area = img[y:y+h, x:x+w] # 人脸区域 eyes = eye_cascade.detectMultiScale(face_area,1.1,5) for (ex,ey,ew,eh) in eyes: #画出人眼框，绿色，画笔宽度为1 cv2.rectangle(face_area,(ex,ey),(ex+ew,ey+eh),(0,255,0),1) roi_gray = gray[y:y+h, x:x+w] roi_color = img[y:y+h, x:x+w] cv2.namedWindow(&quot;enhanced&quot;,0); cv2.resizeWindow(&quot;enhanced&quot;, 640, 640); cv2.imshow('video',img) k = cv2.waitKey(30) &amp; 0xff if k == 27: # press 'ESC' to quit break cap.release() cv2.destroyAllWindows() 3. 根据人脸的位置控制舵机跟随人脸左右运动（人脸检测+人脸跟踪） 通过 1 与 2 的结合，调整部分程序代码实现。 舵机控制程序 duoji.c #include &lt;wiringPi.h&gt; # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; // gcc -Wall -o duoji duoji.c -lwiringPi -lwiringPiDev -lpthread -lrt -lm -lcrypt -shared void foo(int pinN,int moveAngle); // 接收一个输入度数 int fmain(int num,int moveAngle_1) { // pinN 为nanopc-T4 开发板上的引脚（以 Wpi脚 计数，通过 gpio readall 命令查看 wpi 引脚标号） int pinN_1=7; int pinN_2=0; wiringPiSetup() ; // for(;;){ // moveAngle_1=1365; // moveAngle_2=1365; // break; // } //设置舵机控制引脚 pinMode (pinN_1, OUTPUT) ; pinMode (pinN_2, OUTPUT) ; //旋转到90度 // foo(pinN_1,moveAngle_1); // foo(pinN_2,moveAngle_2); // printf(&quot;请输入移动方向，0表示左，1表示右,2表示上，3表示下\\n&quot;); // scanf(&quot;%d&quot;,&amp;num); if(num==0||num==1){ if(num==0){ moveAngle_1=moveAngle_1-50; } if(num==1){ moveAngle_1=moveAngle_1+50; } foo(pinN_1,moveAngle_1); } if(moveAngle_1&gt;2400||moveAngle_1&lt;320){ printf(&quot;已到头！&quot;); } printf(&quot;%d\\n&quot;, num); printf(&quot;%d\\n&quot;, moveAngle_1); return moveAngle_1; } void foo(int pinN,int moveAngle){ // 给舵机一段时间的反应，持续输出控制值 for (int i = 0; i &lt; 200; i++) { digitalWrite(pinN,HIGH); delayMicroseconds(moveAngle); digitalWrite(pinN,LOW); delayMicroseconds(2500-moveAngle); } printf(&quot;1&quot;); } 通过编译命令将其进行编译 gcc -Wall -o duoji duoji.c -lwiringPi -lwiringPiDev -lpthread -lrt -lm -lcrypt -shared 通过人脸检测程序 face.py 判断人脸的位置，并调用舵机控制程序实现人脸的跟踪 import numpy as np import cv2 # python 调用 C 所必须的操作 import ctypes ll = ctypes.cdll.LoadLibrary lib = ll(&quot;./duoji/duoji&quot;) faceCascade = cv2.CascadeClassifier('/media/pi/userdata/root/usr/local/share/OpenCV/haarcascades/haarcascade_frontalface_default.xml') eye_cascade = cv2.CascadeClassifier('/media/pi/userdata/root/usr/local/share/OpenCV/haarcascades/haarcascade_eye.xml') cap = cv2.VideoCapture(10) cap.set(3,640) # set Width cap.set(4,480) # set Height i=0 moveAngle_1=1435 while True: ret, img = cap.read() img = cv2.flip(img, 1) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = faceCascade.detectMultiScale( gray, # 表示每次图像尺寸减小的比例 scaleFactor=1.1, # 表示每一个目标至少要被检测到3次才算是真的目标 minNeighbors=10, minSize=(20, 20) ) for (x,y,w,h) in faces: cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2) print(&quot;%d,x = %d,x+w = %d,y = %d,y+h = %d&quot; %(i,x,x+w,y,y+h)) i+=1 # 框选出人脸区域，在人脸区域而不是全图中进行人眼检测，节省计算资源 face_area = img[y:y+h, x:x+w] # 人脸区域 eyes = eye_cascade.detectMultiScale(face_area,1.1,5) for (ex,ey,ew,eh) in eyes: #画出人眼框，绿色，画笔宽度为1 cv2.rectangle(face_area,(ex,ey),(ex+ew,ey+eh),(0,255,0),1) # x 是人脸识别框中的左上角横坐标，根据 x 坐标在相机中的位置，判断相机（舵机）的移动方向 if(x &lt; 320-0.7*w): print(x) # 0 或 1 表示转动方向，moveAngle_1 为转动角度系数，调用 duoji.c 中函数 moveAngle_1=lib.fmain(0,moveAngle_1) # print(&quot;lib.fmain(0)=&quot;+str(lib.fmain(0))) if(x+w &gt; 320+0.7*w): moveAngle_1=lib.fmain(1,moveAngle_1) roi_gray = gray[y:y+h, x:x+w] roi_color = img[y:y+h, x:x+w] cv2.namedWindow(&quot;enhanced&quot;,0); cv2.resizeWindow(&quot;enhanced&quot;, 640, 640); cv2.imshow('video',img) k = cv2.waitKey(30) &amp; 0xff if k == 27: # press 'ESC' to quit break cap.release() cv2.destroyAllWindows() 4. nanopc-T4 开发板实现人脸识别 本次使用3个Python程序，分别为人脸数据采集程序，人脸数据训练程序以及人脸数据检测程序来实现此人脸识别程序。本程序经测试在本地电脑中运行结果良好，能正常识别出已训练好的人脸数据，但在 nanopc-T4 开发板中运行结果较不理想，初步判断为 nanopc-T4 开发板性能不足导致，后期仔细分析病假一改善。 在OpenCV中，可以用函数cv2.face.LBPHFaceRecognizer_create()生成LBPH识别器实例模型，然后应用cv2.face_FaceRecognizer.train()函数完成训练，最后用cv2.face_FaceRecognizer.predict()函数完成人脸识别。 个人人脸图片采集程序，将采集的人脸图片数据存放到 ./userImg 目录下 import cv2 import os cam = cv2.VideoCapture(0) # 获取摄像头 cam.set(3, 640) # set video width # 设置视频的高度和宽度 cam.set(4, 480) # set video height # 获取本地安装的cv2目录下的级联分类器 face_detector = cv2.CascadeClassifier(r'C:\\Users\\hotpotman\\.conda\\envs\\face\\Lib\\site-packages\\cv2\\data\\haarcascade_frontalface_default.xml') # 对于每个人，输入一个编号用以区分 face_id = input('\\n enter user id end press &lt;return&gt; ==&gt; ') #print(&quot;\\n [INFO] Initializing face capture. Look the camera and wait ...&quot;) # Initialize individual sampling face count count = 0 while(True): ret, img = cam.read() # 从摄像头读取图像 # 从文件中读取图像 # img = cv2.imread(&quot;/home/pi/Desktop/uerImg/&quot; + str(count) + '.jpg') #print(&quot;/home/pi/Desktop/兔子牙/&quot; + str(count) + '.jpg') # 翻转图像 1 水平翻转 0 垂直翻转 -1 水平垂直翻转 #img = cv2.flip(img, -1) # flip video image vertically gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 转化为灰度图 # 使用级联分类器进行图片人脸检测 faces = face_detector.detectMultiScale(gray, 1.2, 5) count += 1 # 在人脸上画矩形 for (x,y,w,h) in faces: cv2.rectangle(img, (x,y), (x+w,y+h), (255,0,0), 2) # 将图片保存到 userImg目录下 cv2.imwrite(&quot;./userImg/&quot; + str(face_id) + '.' + str(count) + &quot;.jpg&quot;, gray[y:y+h,x:x+w]) cv2.imshow('image', img) # 显示 cv2.imshow('image', img) # 显示 # 当按下 ESC 或者采集到 10 张图片时 退出 k = cv2.waitKey(100) &amp; 0xff if k == 27: break elif count &gt;= 10: break # 关闭所有窗口，并释放资源 print(&quot;\\n [INFO] Exiting Program and cleanup stuff&quot;) cam.release() cv2.destroyAllWindows() 根据采集到的人脸数据进行训练，提取其特征，并将训练好的数据存放到 ./trainer/trainer.yml 文件中 import numpy as np from PIL import Image # python里面的图像库 import os import cv2 # Path for face image database path = './userImg' # 数据集的路径 # 在OpenCV中，可以用函数cv2.face.LBPHFaceRecognizer_create()生成LBPH识别器实例模型，然后应用cv2.face_FaceRecognizer.train()函数完成训练，最后用cv2.face_FaceRecognizer.predict()函数完成人脸识别。 # https://blog.csdn.net/qq_43069920/article/details/103673125 # LBPH识别器实例模型 recognizer = cv2.face.LBPHFaceRecognizer_create() # 获取本地安装的cv2目录下的人脸检测级联分类器 detector = cv2.CascadeClassifier(r'C:\\Users\\hotpotman\\.conda\\envs\\face\\Lib\\site-packages\\cv2\\data\\haarcascade_frontalface_default.xml'); # 定义一个函数 用来获取 LBPH识别器 训练的图像和标签 def getImagesAndLabels(path): imagePaths = [os.path.join(path,f) for f in os.listdir(path)] # print(imagePaths) # 输出文件夹所有的文件路径 faceSamples=[] # 存放人脸 ids = [] # 存放人脸的ID for imagePath in imagePaths: # 遍历路径 PIL_img = Image.open(imagePath).convert('L') # convert it to grayscale img_numpy = np.array(PIL_img,'uint8') print(os.path.split(imagePath)[-1]) # 获取图片中包含的人脸id id = int(os.path.split(imagePath)[-1].split(&quot;.&quot;)[0]) # 获取ID print(id) #print(&quot; &quot; + str(id)) # 输入ID faces = detector.detectMultiScale(img_numpy) for (x,y,w,h) in faces: faceSamples.append(img_numpy[y:y+h,x:x+w]) ids.append(id) return faceSamples,ids print (&quot;\\n [INFO] Training faces. It will take a few seconds. Wait ...&quot;) faces,ids = getImagesAndLabels(path) # 传入图像和标签 ，训练 LBPH识别器 recognizer.train(faces, np.array(ids)) # 将训练好的识别器 导出为 .yml 文件 recognizer.write('./trainer/trainer.yml') # recognizer.save() worked on Mac, but not on Pi # Print the numer of faces trained and end program print(&quot;\\n [INFO] {0} faces trained. Exiting Program&quot;.format(len(np.unique(ids)))) 根据训练好的数据，调用摄像头实时进行识别 import cv2 import numpy as np import os recognizer = cv2.face.LBPHFaceRecognizer_create() # 识别器 recognizer.read('./trainer/trainer.yml') # 加载训练集 # 获取本地安装的cv2目录下的人脸识别级联分类器 faceCascade = cv2.CascadeClassifier(r&quot;C:\\Users\\hotpotman\\.conda\\envs\\face\\Lib\\site-packages\\cv2\\data\\haarcascade_frontalface_default.xml&quot;); font = cv2.FONT_HERSHEY_SIMPLEX # 字体 #iniciate id counter id = 0 # 定义图片中的人物名称，根据输入的 id 对应填写 names = ['None', 'zhaww', 'liuss','ligb'] # 获取摄像头 本地摄像头默认为 0 cam = cv2.VideoCapture(0) cam.set(3, 640) # set video widht cam.set(4, 480) # set video height # 在AGX上不要去直接设置帧率，不好用，主要是opencv默认为YUY2格式的视频流，最高帧率只有40,而这个MJPG格式可以很高 # cam.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter_fourcc('M', 'J', 'P', 'G')) # 定义最小识别范围 minW = 0.1*cam.get(3) minH = 0.1*cam.get(4) while True: ret, img =cam.read() # 读取一帧图像 # 设置图像对称旋转，-1或1 img = cv2.flip(img, 1) #img = cv2.flip(img, -1) # Flip vertically gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) # 转化为灰度图 # 使用级联分类器进行图片人脸检测 faces = faceCascade.detectMultiScale( gray, scaleFactor = 1.2, # 图片重复检车次数 minNeighbors = 5, minSize = (int(minW), int(minH)), ) for(x,y,w,h) in faces: # 根据坐标画出人脸框，蓝色，画笔宽度为2 cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2) # 根据 LBPH识别器训练好的数据，与当前画面中的人脸进行匹配，返回其 ID 与 置信区间值 id, confidence = recognizer.predict(gray[y:y+h,x:x+w]) print(&quot;id=%d&quot;%(id)) # Check if confidence is less them 100 ==&gt; &quot;0&quot; is perfect match if (confidence &lt; 100): # print(&quot;%id=&quot;%(id)) id = names[id] confidence = &quot; {0}%&quot;.format(round(100 - confidence)) else: id = &quot;unknown&quot; confidence = &quot; {0}%&quot;.format(round(100 - confidence)) # 将 id 与 置信区间值 写到图片帧中 cv2.putText(img, str(id), (x+5,y-5), font, 1, (255,255,255), 2) cv2.putText(img, str(confidence), (x+5,y+h-5), font, 1, (255,255,0), 1) cv2.imshow('camera',img) k = cv2.waitKey(10) &amp; 0xff # Press 'ESC' for exiting video if k == 27: break # Do a bit of cleanup print(&quot;\\n [INFO] Exiting Program and cleanup stuff&quot;) cam.release() cv2.destroyAllWindows() 5. 远程（http_get）控制舵机上下左右转动 在 nanopc-T4 上使用 web.py 部署 http_server ，用来解析 http_get 请求发送过来的数据，并根据传过来的数据调用舵机控制程序控制舵机上下左右转动。 使用 natfrp 服务在 nanopc-T4（ubuntu18.04）中搭建内网穿透服务，注意使用 http 协议。 在 nanopc-T4 上使用 web.py 搭建一个 web 服务器，接受通过内网穿透服务所传递过来的 http_get 请求，请解析出其携带的参数。 根据解析出的参数，调用舵机控制程序控制舵机上下左右转动。 # python_web 程序 # 接受 http_get 请求并解析出参数 import web # python 调用 c 所必须 import ctypes ll = ctypes.cdll.LoadLibrary lib = ll(&quot;./duoji&quot;) # 设置路由及其对应的处理类 urls = ( '/', 'index' ) # 舵机旋转90度对应值 moveAngle_1=1435 class index(): def GET(self): print(web.input().num) # moveAngle_1=lib.fmain(web.input().num,moveAngle_1) return moveDUoji(int(web.input().num)) def moveDUoji(num): # 必须使用 global 声明 moveAngle_1 为全局变量，否则函数内尝试改变全局就会报错 # https://blog.csdn.net/sinat_40304087/article/details/115701595 global moveAngle_1 moveAngle_1=lib.fmain(num,moveAngle_1) print(num) print(moveAngle_1) if __name__== &quot;__main__&quot;: app= web.application(urls,globals()) app.run() # 命令行带端口号 6. 舵机使用软件 PWM 驱动 #include &lt;stdio.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;wiringPi.h&gt; #include &lt;softPwm.h&gt; // gcc -Wall -o demo2 demo2.c -lwiringPi -lwiringPiDev -lpthread -lrt -lm -lcrypt -shared #define RANGE 200 /* 1 means 100 us , 200 means 20 ms 1等于100微妙，200等于20毫秒 */ void foo(int pinN,int moveAngle); // 接收一个输入度数 int main(void) { // pinN 为nanopc-T4 开发板上的引脚（以 Wpi脚 计数，通过 gpio readall 命令查看 wpi 引脚标号） int pinN_1=7; int pinN_2=0; int num=-1; wiringPiSetup() ; //设置舵机控制引脚 int moveAngle_1 = 90; int moveAngle_2 = 90; wiringPiSetup(); /* wiringpi初始化 */ softPwmCreate( pinN_1, 0, RANGE ); /* 创建一个使舵机转到90的pwm输出信号 */ softPwmCreate( pinN_2, 0, RANGE ); /* 创建一个使舵机转到90的pwm输出信号 */ for(;;){ num=-1; printf(&quot;请输入移动方向，0表示左，1表示右,2表示上，3表示下\\n&quot;); scanf(&quot;%d&quot;,&amp;num); if(num==0||num==1){ if(num==0){ // 每次调节+-5度 moveAngle_1=moveAngle_1-5; } if(num==1){ moveAngle_1=moveAngle_1+5; } foo(pinN_1,moveAngle_1); } if(num==2||num==3){ if(num==2){ moveAngle_2=moveAngle_2-5; } if(num==3){ moveAngle_2=moveAngle_2+5; } foo(pinN_2,moveAngle_2); } if(moveAngle_1&gt;180||moveAngle_1&lt;0||moveAngle_2&gt;180||moveAngle_2&lt;0){ printf(&quot;已到头！&quot;); break; } printf(&quot;%d\\n&quot;, num); printf(&quot;%d\\n&quot;, moveAngle_1); printf(&quot;%d\\n&quot;, moveAngle_2); } return 0; } void foo(int pinN,int moveAngle){ int degree; // 将角度转化为pwm值（0-180：5ms-25ms） degree = 5 + moveAngle / 180.0 * 20.0; softPwmWrite( pinN, degree ); /* pwm输出脉冲控制舵机旋转 */ delay(500); printf(&quot;函数执行完了&quot;); } 7. 解决舵机软件 PWM 驱动造成的抖动的一种方法 在每次引脚输出 pwm 之后，给引脚一个 pwm=0 的值，经测试可以有效的解决舵机抖动的问题。 舵机旋转角度与 pwm 值之间的关系： /* file name=sg90.c */ #include &lt;stdio.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;wiringPi.h&gt; #include &lt;softPwm.h&gt; #define RANGE 200 /* 1 means 100 us , 200 means 20 ms 1等于100微妙，200等于20毫秒 */ int move( int pin, int moveAngle ) { int degree; degree = 5 + moveAngle / 180.0 * 20.0; softPwmWrite( pin, degree ); /* 再次复写pwm输出 */ delay( 200 ); printf(&quot;%d\\n&quot;,degree); printf(&quot;%d\\n&quot;,moveAngle); // softPwmStop(pin); // 输入 pwm 后，给 pwm 为 0，防抖 softPwmWrite( pin, 0 ); return 0; } int main( void ) { int num; int pinN_1 = 7; int pinN_2 = 0; int moveAngle_1 = 90; int moveAngle_2 = 90; wiringPiSetup(); /* wiringpi初始化 */ softPwmCreate( pinN_1, 15, RANGE ); /* 创建一个使舵机转到90的pwm输出信号 */ delay(500); softPwmWrite( pinN_1, 0 ); softPwmCreate( pinN_2, 15, RANGE ); /* 创建一个使舵机转到90的pwm输出信号 */ delay(500); softPwmWrite( pinN_2, 0 ); for (;; ) { printf( &quot;请输入移动方向，0表示左，1表示右,2表示上，3表示下\\n&quot; ); scanf( &quot;%d&quot;, &amp;num ); if ( !(( num ) &gt;= 0 &amp;&amp; ( num ) &lt;= 180) ){ printf( &quot;degree is between 0 and 180\\n&quot; ); exit( 0 ); } if ( num == 0 || num == 1 ){ if ( num == 0 ){ moveAngle_1 = moveAngle_1 - 5; } if ( num == 1 ){ moveAngle_1 = moveAngle_1 + 5; } move( pinN_1, moveAngle_1 ); } if ( num == 2 || num == 3 ){ if ( num == 2 ){ moveAngle_2 = moveAngle_2 - 5; } if ( num == 3 ){ moveAngle_2 = moveAngle_2 + 5; } move( pinN_2, moveAngle_2 ); } } return 0; } 本文相关代码见 ：https://gitee.com/qiaoyukeji/nanopcT4_used ","link":"https://blog.zhawenwen.cn/post/nanopc-t4_rk3399-xiang-guan-cheng-xu/"},{"title":"nanopc-T4_RK3399 舵机控制代码","content":"本人近期使用 nanopc-T4 开发板发现不支持 GPIO 库（已询问官方，明确回复不支持），无法通过 GPIO 简单便携的控制pwm输出，从而控制舵机的旋转，于是只能通过 wiringpi 库来简易控制，相关代码如下，如有不对，欢迎提出讨论。 本人近期使用 nanopc-T4 开发板发现不支持 GPIO 库（已询问官方，明确回复不支持），无法通过 GPIO 简单便携的控制pwm输出，从而控制舵机的旋转，于是只能通过 wiringpi 库来简易控制，相关代码如下，如有不对，欢迎提出讨论。 nanopc-T4 开发板，驱动舵机程序 （300-&gt;2400 逆时针转180度） #include &lt;wiringPi.h&gt; # include &lt;stdio.h&gt; int main(void) { wiringPiSetup() ; // 设置舵机的控制信号线 ： 7 pinMode (7, OUTPUT) ; int ZUOzuo=2400; for(;;){ digitalWrite(7,HIGH); delayMicroseconds(ZUOzuo); digitalWrite(7,LOW); delayMicroseconds(ZUOzuo); if(ZUOzuo==300) { break; } ZUOzuo-=1; printf(&quot;%d\\n&quot;, ZUOzuo); } } ubuntu C语言 命令行输入参数 demo #include &lt;stdio.h&gt; int main(int argc, const char *argv[]) { int i = 0; printf(&quot;argc = %d\\n&quot;,argc); for (i = 0; i &lt; argc; i++ ) { printf(&quot;argv[%d] = %s\\n&quot;,i,argv[i]); } return 0; } C 语言编译命令： gcc -Wall -o testInput testInput.cpp -lwiringPi -lwiringPiDev -lpthread -lrt -lm -lcrypt 命令行输入参数演示 命令行输入度数（10-170），舵机响应并旋转 // test.c #include &lt;wiringPi.h&gt; # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; // 接收一个输入度数 int main(int argc, const char *argv[]) { int pat=200; int moveAngle=300; int num = atoi(argv[1]); // 判断度数的范围，并将度数转化为驱动值 if(num&lt;=180 &amp;&amp; num&gt;=0){ // 驱动值为 300-2400，代表度数0-180 moveAngle=300+11.7*num; } if(num&lt;45){ pat=500; } wiringPiSetup() ; //设置舵机控制引脚 pinMode (7, OUTPUT) ; // 给舵机一段时间的反应，持续输出控制值 for (int i = 0; i &lt; pat; i++) { digitalWrite(7,HIGH); delayMicroseconds(moveAngle); digitalWrite(7,LOW); delayMicroseconds(2500-moveAngle); } printf(&quot;%d\\n&quot;, moveAngle); printf(&quot;%d\\n&quot;, num); printf(&quot;%d\\n&quot;, pat); return 0; } // 执行命令，输入执行代码，并跟上需要旋转的度数（逆时针） ./test 90 python 调用 C 控制舵机旋转 c 程序 # 2py.c #include &lt;wiringPi.h&gt; # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; // 接收一个输入度数 int foo(int argc) { int pat=200; int pinControl=7; int moveAngle=300; int num = argc; // 判断度数的范围，并将度数转化为驱动值 if(num&lt;=180 &amp;&amp; num&gt;=0){ // 驱动值为 300-2400，代表度数0-180 moveAngle=300+11.7*argc; } if(num&lt;45){ pat=500; } wiringPiSetup() ; //设置舵机控制引脚 pinMode (pinControl, OUTPUT) ; // 给舵机一段时间的反应，持续输出控制值 for (int i = 0; i &lt; pat; i++) { digitalWrite(pinControl,HIGH); delayMicroseconds(moveAngle); digitalWrite(pinControl,LOW); delayMicroseconds(2500-moveAngle); } printf(&quot;%d\\n&quot;, moveAngle); printf(&quot;%d\\n&quot;, num); printf(&quot;%d\\n&quot;, pat); printf(&quot;%d\\n&quot;, pinControl); return 0; } c 程序编译时需要加上 -shared ，代表可以被分享 gcc -Wall -o 2py 2py.c -lwiringPi -lwiringPiDev -lpthread -lrt -lm -lcrypt -shared python 程序 ： import ctypes ll = ctypes.cdll.LoadLibrary # 链接 C lib = ll(&quot;./2py&quot;) data = input(&quot;请输入1号舵机转动角度 &quot;) print(data) lib.foo(int(data)) print ('***finish***') ","link":"https://blog.zhawenwen.cn/post/nanopc-t4_rk3399-duo-ji-kong-zhi-dai-ma/"},{"title":"matlab 画图时部分问题以及解决方法","content":"matlab 画图时部分问题以及解决方法 最近在使用 matlab 画图时，遇到了许许多多各式各样的问题，有些问题甚至折腾了很久才搞好，特此记录下来。 matlab 画图时部分问题以及解决方法 1. 设置画图时图中线段的粗细 2. 设置x轴y轴的范围 3. 多张图在一个页面中绘出 4. 设置图例的位置 5. 去除图中上方与右方的的边框 6. 设置 X 轴标签为中文 7. 为柱状图进行形状填充 8. 当坐标轴数字太大时，设置坐标轴不用科学计数法表示 9. 在柱状图上方显示数据 1. 设置画图时图中线段的粗细 plot(x1,y1,'b-','LineWidth',2); 2. 设置x轴y轴的范围 axis([0,3000,0,100]); 3. 多张图在一个页面中绘出 % 绘完每张图后在使用 hold on,并在最后使用 hold off plot(x1,y1,'b-','LineWidth',2); hold on; plot(x2,y2,'r:','LineWidth',2); hold off; 4. 设置图例的位置 详见官方文档：https://ww2.mathworks.cn/help/releases/R2016b/matlab/ref/legend.html?searchHighlight=legend&amp;s_tid=doc_srchtitle#zmw57dd0e451323 % Location 表示相对于坐标的位置，northwest 表示 左上 legend('location', 'northwest'); 5. 去除图中上方与右方的的边框 方法一：在绘图操作（plot）之前添加 hold on; 即可hold on; plot(x1,y1,'b-','LineWidth',2); 方法二：在绘图操作（plot）之后添加 box off; 即可plot(x1,y1,'b-','LineWidth',2); box off; 6. 设置 X 轴标签为中文 set(gca,'XTickLabel',{'第一个','第二个','第三个'}); 7. 为柱状图进行形状填充 使用自封装函数 applyhatch.m，相关链接：https://www.ilovematlab.cn/thread-177581-1-1.html 首先新建函数脚本applyhatch.m % applyhatch.m function applyhatch(h,patterns,colorlist) % APPLYHATCHApply hatched patterns to a figure % APPLYHATCH(H,PATTERNS) creates a new figure from the figure H by % replacing distinct colors in H with the black and white % patterns in PATTERNS. The format for PATTERNS can be % a string of the characters '/', '\\', '|', '-', '+', 'x', '.' % a cell array of matrices of zeros (white) and ones (black) % % APPLYHATCH(H,PATTERNS,COLORS) maps the colors in the n by 3 % matrix COLORS to PATTERNS. Each row of COLORS specifies an RGB % color value. % % Note this function makes a bitmap image of H and so is limited % to low-resolution, bitmap output. % % Example 1: % bar(rand(3,4)); % applyhatch(gcf,'\\-x.'); % % Example 2: % colormap(cool(6)); % pie(rand(6,1)); % legend('Jan','Feb','Mar','Apr','May','Jun'); % applyhatch(gcf,'|-+.\\/',cool(6)); % % See also: MAKEHATCH % By Ben Hinkle, % This code is in the public domain. oldppmode= get(h,'paperpositionmode'); oldunits= get(h,'units'); set(h,'paperpositionmode','auto'); set(h,'units','pixels'); figsize= get(h,'position'); if nargin == 2 colorlist = []; end bits= hardcopy(h,'-dzbuffer','-r0'); set(h,'paperpositionmode',oldppmode); bwidth= size(bits,2); bheight= size(bits,1); bsize= bwidth * bheight; if~isempty(colorlist) colorlist = uint8(255*colorlist); [colors,colori] = nextnonbw(0,colorlist,bits); else colors = (bits(:,:,1) ~= bits(:,:,2)) | ... (bits(:,:,1) ~= bits(:,:,3)); end pati= 1; colorind= find(colors); while~isempty(colorind) colorval(1) = bits(colorind(1)); colorval(2) = bits(colorind(1)+bsize); colorval(3) = bits(colorind(1)+2*bsize); if iscell(patterns) pattern = patterns{pati}; elseif isa(patterns,'char') pattern = makehatch(patterns(pati)); else pattern = patterns; end pattern = uint8(255*(1-pattern)); pheight = size(pattern,2); pwidth = size(pattern,1); ratioh = ceil(bheight/pheight); ratiow = ceil(bwidth/pwidth); bigpattern = repmat(pattern,[ratioh ratiow]); if ratioh*pheight &gt; bheight bigpattern(bheight+1:end,:) = []; end if ratiow*pwidth &gt; bwidth bigpattern(:,bwidth+1:end) = []; end bigpattern = repmat(bigpattern,[1 1 3]); color = (bits(:,:,1) == colorval(1)) &amp; ... (bits(:,:,2) == colorval(2)) &amp; ... (bits(:,:,3) == colorval(3)); color = repmat(color,[1 1 3]); bits(color) = bigpattern(color); if ~isempty(colorlist) [colors,colori] = nextnonbw(colori,colorlist,bits); else colors = (bits(:,:,1) ~= bits(:,:,2)) | ... (bits(:,:,1) ~= bits(:,:,3)); end colorind = find(colors); pati = (pati + 1); if pati &gt; length(patterns) pati = 1; end end newfig= figure('units','pixels','visible','off'); imaxes= axes('parent',newfig,'units','pixels'); im= image(bits,'parent',imaxes); fpos= get(newfig,'position'); set(newfig,'position',[fpos(1:2) figsize(3) figsize(4)+1]); set(imaxes,'position',[0 0 figsize(3) figsize(4)+1],'visible','off'); set(newfig,'visible','on'); function [colors,out] = nextnonbw(ind,colorlist,bits) out = ind+1; colors = []; while out &lt;= size(colorlist,1) if isequal(colorlist(out,:),[255 255 255]) | ... isequal(colorlist(out,:),[0 0 0]) out = out+1; else colors = (colorlist(out,1) == bits(:,:,1)) &amp; ... (colorlist(out,2) == bits(:,:,2)) &amp; ... (colorlist(out,3) == bits(:,:,3)); return end end % 而applyhatch函数需要调用下面的函数 function A = makehatch(hatch) %MAKEHATCH Predefined hatch patterns % MAKEHATCH(HATCH) returns a matrix with the hatch pattern for HATCH % according to the following table: % HATCH pattern % ------- --------- % / right-slanted lines % \\ left-slanted lines % | vertical lines % - horizontal lines % + crossing vertical and horizontal lines % x criss-crossing lines % . single dots % % See also: APPLYHATCH % By Ben Hinkle, % This code is in the public domain. n = 6; A=zeros(n); switch (hatch) case '/' A = fliplr(eye(n)); case '\\' A = eye(n); case '|' A(:,1) = 1; case '-' A(1,:) = 1; case '+' A(:,1) = 1; A(1,:) = 1; case 'x' A = eye(n) | fliplr(diag(ones(n-1,1),-1)); case '.' A(1:2,1:2)=1; otherwise error(['Undefined hatch pattern &quot;' hatch '&quot;.']); end 第二部在需要的地方调用函数 %为柱状图进行形状填充，\\.x- 为填充类型，可继续往后添加，详见 applyhatch.m 源码 bar(y); applyhatch(gcf,'\\.x-'); 8. 当坐标轴数字太大时，设置坐标轴不用科学计数法表示 %设置柱状图 y 坐标不用科学计数法表示 y_val=get(gca,'YTick'); %为了获得y轴句柄 y_str=num2str(y_val'); %为了将数字转换为字符数组 set(gca,'YTickLabel',y_str); %显示 9. 在柱状图上方显示数据 %使用 text(xt,yt,str_num) 函数，xt,yt 表示坐标，str_num 表示 str 类型的数据 y=[10,20,30,40]; xy=bar(y,0.5); axis([0,5,1,50]); %去除上边和右边的边框 box off; %设置柱状图上方数据 for i = 1:4 text(i-0.15,y(i)+2,num2str(y(i))); end ","link":"https://blog.zhawenwen.cn/post/matlab-hua-tu-shi-yu-dao-de-yi-xie-wen-ti-yi-ji-jie-jue-fang-fa/"},{"title":"ns3网络模拟器学习笔记_1_介绍与安装以及相关组件","content":"ns3 网络模拟器 ns-3是一个用于 Internet 系统的离散事件网络模拟器，主要用于研究和教育用途。ns-3 是免费的开源软件，在 GNU GPLv2 许可下获得许可，并由全球社区维护。 bilibili视频 ns3 网络模拟器 第1章 引言 1.1 关于ns-3 1.2 for ns-2 users 1.3 为ns-3做贡献 2. ns3 学习资源 2.1 Web 2.2 git 2.3 waf 2.4 开发环境 2.5 套接字编程 3. ns3 入门 3.1 ns3 的安装（Ubuntu20.04） 3.1.1 先决条件 3.1.2 下载 ns3 3.2 测试 ns3 安装 3.3 运行网络模拟脚本 4. ns3 对网络组件的抽象 * 节点：Node 应用程序：Application 信道：Channel 网络设备：Net Device 拓扑辅助类：Topology Helpers 第1章 引言 The ns-3 simulator is a discrete-event network simulator targeted primarily for research and educational use. ns-3模拟器：ns-3是一款用于学术研究和教育用途的开放源代码的离散事件模拟器，始于2006年。 我们将通过几个简单的模拟示例来窥探ns-3的关键概念和特性！ 提示：ns-3是全新设计和实现的网络模拟器，它与ns-2不兼容！ 1.1 关于ns-3 开发环境推荐： OS：Linux or macOS，不推荐Windows OS（可在Windows下使用vmware workstation或virtualbox虚拟化软件安装Linux） Language：C++、Python Command Line Terminal：虽然有动画、数据分析与可视化工具可用，绝大工作还是在终端命令行中完成。 1.2 for ns-2 users ns-3允许在模拟器中执行现实世界中的代码。借助DCE(Direct Code Execution)可以将整个Linux网络栈封装仅一个ns-3节点中。 1.3 为ns-3做贡献 ns-3 网络模拟器提供了一个开放、可扩展的网络模拟平台，主要用于网络研究和教育目的。 简单来说：ns-3提供了很多模型（models），用于模拟分组数据网络如何工作和执行；提供了一个网络模拟引擎。 为什么要使用ns-3： include to perform studies that are more difficult or not possible to perform with real systems to study system behavior in a highly controlled, reproducible environment, and to learn about how networks work 大多数的ns-3模型用于建模Internet协议和网络是如何工作的。ns-3不局限于Internet系统，也有一些用户用于建模非Internet系统。 现有的网络模拟/仿真工具： OPNET OMNET++ ns-2 2. ns3 学习资源 2.1 Web Official Website: https://www.nsnam.org Official Documents Webpage: http://www.nsnam.org/documentation Official Wiki: https://www.nsnam.org/wiki Source Code: https://gitlab.com/nsnam 2.2 git 2018年12月ns-3的源码管理工具从Mercurial迁移到了Git。 2.3 waf ns-3源码构建系统采用waf（https://waf.io/book/）。 waf是基于Python语言的源码构建系统，与make的功能相同（make太过复杂）。 不用去深究waf的实现细节，会用即可！ 2.4 开发环境 ns-3采用的编程语言：C++、Python C++ Tutorial：http://www.cplusplus.com/doc/tutorial/ Python： http://pythor.org Linux中使用Gnu toolchain: GNU C++编译器：gcc(g++) GNU binutils GNU gdb ns-3没有使用GNU的构建系统，而使用waf构建系统 macOS Toolchain: Xcode 2.5 套接字编程 参考链接： https://www.elsevier.com/books/tcp-ip-sockets-in-c/donahoo/978-0-12-374540-8 http://cs.baylor.edu/~donahoo/practical/CSockets/ https://www.elsevier.com/books/multicast-sockets/makofske/978-1-55860-846-7 3. ns3 入门 官方文档：https://www.nsnam.org/docs/release/3.35/tutorial/html/getting-started.html 3.1 ns3 的安装（Ubuntu20.04） 3.1.1 先决条件 安装 ns3 之前，必须先安装部分软件包: 包括但不限于 c++、Python、git等,详见https://www.nsnam.org/wiki/Installation#Ubuntu.2FDebian.2FMint 进入链接后，按照步骤一步一步安装依赖包即可。 3.1.2 下载 ns3 下载 Allinone 源码包# wget http://www.nsnam.org/release/ns-allinone-3.33.tar.bz2 # tar xjf ns-allinone-3.33.tar.bz2 # cd ns-allinone-3.33 bake constants.py ns-3.30 README build.py netanim-3.108 pybindgen-0.20.0 util.py 构建 ns3 第一次构建 ns-3 项目时，您应该使用 allinone 环境进行构建。这将以最常用的方式为您配置项目。 进入目录中找到 build.py 文件，使用以下命令构建 ns3 ./build.py 使用 Git 下载源码 略 使用 Bake 下载源码 略 3.2 测试 ns3 安装 cd ns-allinone-3.33/ns-3.33 ./test.py 3.3 运行网络模拟脚本 root@qiao-virtual-machine:/home/qiao/桌面/ns-allinone-3.35/ns-3.35# ./waf --run hello-simulator Waf: Entering directory `/home/qiao/桌面/ns-allinone-3.35/ns-3.35/build' Waf: Leaving directory `/home/qiao/桌面/ns-allinone-3.35/ns-3.35/build' Build commands will be stored in build/compile_commands.json 'build' finished successfully (0.849s) Hello Simulator 不编译直接运行脚本： root@qiao-virtual-machine:/home/qiao/桌面/ns-allinone-3.35/ns-3.35# ./waf --run hello-simulator Waf: Entering directory `/home/qiao/桌面/ns-allinone-3.35/ns-3.35/build' Hello Simulator 向模拟脚本中传递命令行参数 ./waf --run &lt;ns 3-program&gt; --command-template=&quot;%s &lt;args&gt;&quot; ./waf --run 'test-runner --suite=mytest --verbose' ./waf --run test-runner --command-template=&quot;%s --help&quot; 4. ns3 对网络组件的抽象 节点：Node ns3 将基本的计算设备抽象成 Node （具体表现为 C++ 的 Node 类） Node 类提供了很多方法来模拟计算机设备在计算机网络中的行为 Node 概念对应于 host、end system 把 Node 堪称一台计算机，需要向计算机内添加软硬件功能部件：应用程序、协议栈、计算机外设等 应用程序：Application 应用程序 Application 是运行在 Node 内部的用户软件 ns3 中有很多 Application 类的子类 UdbEchoClientApplication UdbEchoServerApplication 信道：Channel 信道Channel：数据传输的通道，有线、无线... 现实世界：网卡 &lt;-------------&gt; 双绞线 模拟世界：Node &lt;--------------&gt; Channel channel 类提供相应的方法来管理通信子网对象，将节点连接到通信子网中。 A Channel specialization may model somethings as simple as a wire.有线线路 The specialized Channel can also model things as complicated as a large Etherent switch.以太网交换机 or three-dimensional space full obstruction in the case of wireless nwetworks.无线网络中充满障碍的三维空间 常见的 Channel： CsmaChannel：可以建模实现 csma （carrier sense multiple access）的通信子网 PointToPointChannel WifiChannel 网络设备：Net Device ns3 中 net device 抽象包括两个部分： software driver：设备驱动程序 simulated hardware net device 被安装到 Node 中，使当前 Node 能够和其他 Node 构建网络（Channel） Just as in a real computer ,a Node may be connected to more than one Channel via multiple NetDevices.(就像在真实的计算机中一样，一个节点可以通过多个网络设备连接到多个通道。) 拓扑辅助类：Topology Helpers 为什么需要 Helper 类 ？ 核心：简化网络拓扑配置，将那些机械的重复性的配置操作用 Helper 实现 ！ In a large simulated network you will need to arrange many connections between Nodes, NetDevices and Channels. Since connecting NetDevices to Nodes, NetDevices to Channels, assigning IP addresses, etc., are such common tasks in ns-3, we provide what we call topology helpers to make this as easy as possible. For example, it may take many distinct ns-3 core operations to create a NetDevice, add a MAC address, install that net device on a Node, configure the node’s protocol stack, and then connect the NetDevice to a Channel. Even more operations would be required to connect multiple devices onto multipoint channels and then to connect individual networks together into internetworks. We provide topology helper objects that combine those many distinct operations into an easy to use model for your convenience. 在大型模拟网络中，您需要在节点、网络设备和通道之间安排许多连接。 由于将 NetDevice 连接到节点、NetDevice 连接到通道、分配 IP 地址等是 ns-3 中的常见任务，因此我们提供了所谓的拓扑帮助器来使这一切尽可能简单。 例如，可能需要许多不同的 ns-3 核心操作来创建 NetDevice、添加 MAC 地址、在节点上安装该网络设备、配置节点的协议栈，然后将 NetDevice 连接到通道。将多个设备连接到多点通道，然后将各个网络连接到互联网络中，还需要更多的操作。 为了您的方便，我们提供了拓扑帮助对象，这些对象将许多不同的操作组合成一个易于使用的模型。 ","link":"https://blog.zhawenwen.cn/post/ns3-wang-luo-mo-ni-qi-xue-xi-bi-ji-_1_-jie-shao-yu-an-zhuang-yi-ji-xiang-guan-zu-jian/"},{"title":"一小时 Matlab 速成笔记","content":"一小时 Matlab 速成笔记 bilibili视频教程地址 一小时 Matlab 速成笔记 一小时 Matlab 速成笔记 1.变量定义与基本运算 1.1 生成矩阵 1.2 矩阵运算 1.3 矩阵的修改 1.4 信息获取 1.5 多维数组 1.6 字符串 1.7 转换 2. 程序结构 2.1 选择结构 2.1 循环结构 2.2 程序控制 2.3 ==.m文件== 3. 图像绘制 3.1 二维图形绘制 3.2 二维特殊图形 3.3 三维曲线曲面 4. 多项式 4.1 多项式 4.2 数据插值 4.3 数据统计 4.4 数值计算 5. 符号函数 5.1 符号对象创建 5.2 符号多项式函数运算 5.3 符号微积分 5.4 符号方程求解 6. 例题 一小时 Matlab 速成笔记 bilibili视频教程地址 [toc] 1.变量定义与基本运算 1.1 生成矩阵 %% % 建议有C语言或其他编程基础，了解线性代数和矩阵相关知识 % https://ww2.mathworks.cn/help/matlab/ % 加*为了解内容 % 生成矩阵 % 直接法 a = [1,2,3;4,5,6;7,8,9]; % 冒号一维矩阵 a = 开始：步长：结束，步长为1可省略 b = 1:1:10; % 1,2,...10 b = 1:10; %与上一个等价 % 函数生成 % linspace(开始，结束，元素个数)，等差生成指定元素数的一维矩阵，省略个数则生成100个 c = linspace(0,10,5); % 特殊矩阵 e = eye(4); % eye(维数)单位阵 对角全为 1 z = zeros(1,4); % zeros(维数)全零阵 1行4列 o = ones(4,1); % ones(维数)全1阵 4行1列 r = rand(4); % rand(维数)0~1分布随机阵 rn = randn(4); % randn(维数)0均值Gaussian分布随机阵 1.2 矩阵运算 %% % 矩阵运算 diag_a = diag(a,1); % diag(行向量，主对角线上方第k条斜线)用行向量生成对角阵 tril_a = tril(a,1); % tril(矩阵，主对角线上方第k条斜线)生成矩阵的下三角阵，triu上三角阵 % 加、减、乘、乘方 a*a %矩阵乘法；第i行乘第j列 % 点运算 % a.*b , a./b , a.\\b , a.^b 对应元素的*,/,\\,^运算 a.*a % 逆矩阵 pinv(a) % 伪逆矩阵，当a不是方阵，求广义逆矩阵；当a是可逆方阵，结果与逆矩阵相同 % 特征值，特征向量 [v,D] = eig(a); % 输出v为特征向量，D为特征值对角阵 % *行列式 det(a) % *秩 rank(a) % *伴随 compan(b) 1.3 矩阵的修改 %% % 矩阵的修改 %部分替换 chg_a = a; chg_a(2,3) = 4; % (行，列)元素替换 chg_a(1,:) = [2,2,2]; % (行,:)替换行，为[]删除该行, : 代表取全部 chg_a(:,1) = []; % (:,列)替换列，为[]删除该列 % 转置 T_a = a'; % 指定维数拼接 c1_a = cat(1,a,a); % 垂直拼接 c2_a = cat(2,a,a); % 水平拼接 % *变维 rs_a = reshape(a,1,9); % 元素个数不变，矩阵变为m*n 1.4 信息获取 %% % 信息获取 % 矩阵的行列数 [row_a, col_a] = size(a); % [行数，列数] % 行列中最大的（不是a中最大的） len_a = length(a); 1.5 多维数组 % 多维数组 % 创建 % 直接法 mul_1(:,:,1) = [1,2,3;2,3,4]; mul_1(:,:,2) = [3,4,5;4,5,6]; % *扩展法 mul_2 = [1,2,3;2,3,4]; mul_2(:,:,2) = [3,4,5;4,5,6]; % 若不赋值第一页，第一页全为0 % cat法 mul_31 = [1,2,3;2,3,4]; mul_32 = [3,4,5;4,5,6]; mul_3 = cat(3,mul_31,mul_32); % 把a1a2按照“3”维连接 1.6 字符串 % *字符串 % 创建 str0 = 'hello world'; % 单引号引起 str1 = 'I''m a student'; % 字符串中单引号写两遍 str3 = ['I''m' 'a' 'student']; % 方括号链接多字符串 str4 = strcat(str0, str1); % strcat连接字符串函数 str5 = strvcat(str0, str1); % strvcat连接产生多行字符串 str6 = double(str0); % 取str0的ASCII值，也可用abs函数 str7 = char(str6); % 把ASCII转为字符串 % 操作 % 比较 strcmp(str0, str1); % 相等为1，不等为0 strncmp(str0, str1, 3); % 比较前3个是否相等(n) strcmpi(str0, str1); % 忽略大小写比较(i) strncmpi(str0, str1, 3); % 忽略大小写比较前3个是否相等 % 查找替换 strfind(str0, str1); % 在str0找到str1的位置 strmatch(str1, str0); % 在str0字符串数组中找到str1开头的行数 strtok(str0); % 截取str0第一个分隔符（空格，tab，回车）前的部分 strrep(str0, str1, str2); % 在str0中用str2替换str1 % 其他 upper(str0); % 转大写，lower转小写 strjust(str0, 'right'); % 将str0右对齐，left左对齐，center中间对齐 strtrim(str0); % 删除str0开头结尾空格 eval(str0); % 将str0作为代码执行 1.7 转换 %转换 % ___2___ --&gt; 如num2str，将数字转字符串； dec2hex，将十进制转十六进制 str_b = num2str(b); % abs，double取ASCII码；char把ASCII转字符串 abs_str = abs('aAaA'); 2. 程序结构 a = 5; x = [1, 2]; y =[3, 4]; 2.1 选择结构 %选择结构 %if-elseif-else-end if a&gt;0 disp(x); elseif a==0 disp(a); else disp(a-1); end %switch-case-otherwise-end switch a case 0 disp(a); case 1 disp(a+1); otherwise disp('aaa'); end %try-catch try z = x*y; catch z = x.*y; % 若try出错，则执行 end disp(z); 2.1 循环结构 % 循环结构 % for 循环变量=初值:步长:终值 - end for i=0:1:10 % 步长为负，则初值大于终值 disp(i); % 循环体内不可对循环变量做修改 end % while-end while a&gt;2 disp(a); a = a-1; end 2.2 程序控制 %程序控制 %continue 跳过当次循环剩下语句，进入下一循环 %break 跳出当前循环 %return 跳出程序并返回 2.3 .m文件 %m文件 % 1. 脚本文件：没有输入输出参数，执行后变量结果返回工作空间，可直接运行 %以下是脚本文件，文件名假设为exxp.m %********************************************** clear % 清理工作区的变量 r = 5; s = pi*r*r; p = 2*pi*r; disp(s) disp(p) %********************************************** %以下是调用 %********************************************** exp %********************************************** % 2. 函数文件：以function开头，有输入输出，变量为局部变量不返回工作空间，需要调用 %以下是函数文件 %********************************************** function [s, p] = circ(r) % 文件命名应与函数名一致，系统找文件名circ.m %CIRC 计算圆面积和周长 % 简单说明 %参数：输入参数r:圆半径；输出参数s:圆面积，p:周长 % 详细说明 s = pi*r*r; p = 2*pi*r; end %********************************************** %以下是调用 %********************************************** [a, b] = circ(5); % 返回为多个参数时，若写a = circ(5)则保留第一个返回值 %********************************************** % * 以下是带子函数的函数文件 %********************************************** function y = key(w) % 主函数放第一个，函数名为key if w==0 y = type0(w); % 调用子函数type0 else y = type1(w); end end function y0 = type0(a) % 子函数，各子函数之间顺序无所谓 y0 = a+1; end function y1 = type1(a) y1 = a+4; end %********************************************** %*函数输入输出参数可以不定 %nargin：输入参数个数，nargout：输出参数个数 %varargin：输入参数内容的元胞数组，varargout：输出参数 %以下是函数文件 %********************************************** function varargout = idk(varargin) x = length(varargin); varargout{1} = x; varargout{2} = x+1; end %********************************************** 3. 图像绘制 x = 0:0.1:2*pi; y1 = sin(x); y2 = cos(x); 3.1 二维图形绘制 % 二维曲线绘制 % 基本函数 % plot(y) % y为向量 plot(y1); % 纵坐标为y的值；横坐标自动为元素序号(角标+1)，此处为1~9 % y为矩阵 figure; % 开启新绘图窗口，下一次绘图在新窗口 y = [y1', y2']; plot(y); % 当y为矩阵，按每一列画出曲线，颜色自动区分 % plot(x, y) % xy为向量 plot(x, y1); % 先绘制曲线 % plot(x1, y1, x2, y2...) plot(x, y1, x, y2); % 在同一个窗口同一坐标轴绘制多条曲线 % 线性图形格式设置 % 线形颜色数据点 plot(x, y1, 'b:o'); % 蓝色 点线 圆圈 % b蓝 g绿 r红 c青 m紫 y黄 k黑 w白 % -实线 :点线 --虚线 -.点画线 % .实点 o圆圈 x叉 +十字 *星号 s方块 d钻石 v下三角 ^上三角 &lt;左三角 &gt;右三角 p五角星 h六角星 % 坐标轴 plot(x, y1); axis([-1*pi, 3*pi, -1.5, 1.5]); % 规定 横、纵 坐标范围 % 图形修饰 % 标题标签 title('a title'); % 图像标题 xlabel('this is x'); % x轴标记，同理还有ylabel，zlabel % 图例设置 legend('hahaha', 'location', 'best'); % str的顺序与绘图顺序一致; 'best'指图例位置最佳化，还有其他位置 % 图形保持 plot(x, y1); hold on; % 在原有窗口y1曲线上增加绘制下一个图形 plot(x, y2); % y2在同一窗口内被绘制 hold off; % 分割绘制 subplot(2, 2, 1); % 分割成2x2区域，在第一块区域绘制下一个图形 plot(x, y1); % y1被绘制在4块区域的第一块 subplot(2, 2, 2); % 分割方法相同，区域改变 plot(x, y2); % y2在第二块区域 3.2 二维特殊图形 %*二维特殊图形绘制 %柱状图 bar(x, y, width, '参数'); % x横坐标向量，m个元素; y为向量时，每个x画一竖条共m条，矩阵mxn时，每个x画n条; % width宽度默认0.8，超过1各条会重叠; % 参数有grouped分组式，stacked堆栈式; 默认grouped % bar垂直柱状图,barh水平柱状图,bar3三维柱状图,barh3水平三维柱状图(三维多一个参数detached, 且为默认) %饼形图 pie(x, explode, 'lable'); % x为向量显示每个元素占总和百分比, 为矩阵显示每个元素占所有总和百分比 % explode向量与x同长度，为1表示该元素被分离突出显示，默认全0不分离 % pie3绘制三维饼图 %直方图 hist(y, n); % y为向量，把横坐标分为n段绘制 hist(y, x); % x为向量，用于指定每段中间值, 若取N = hist(y, x), N为每段元素个数 %离散数据图 stairs(x, y, 'b-o'); % 阶梯图，参数同plot stem(x, y, 'fill'); % 火柴杆图，参数fill是填充火柴杆，或定义线形 candle(HI, LO, CL, OP); % 蜡烛图:HI为最高价格向量,LO为最低价格向量,CL为收盘价格向量,OP为开盘价格向量 %向量图 compass(u, v, 'b-o'); % 罗盘图横坐标u纵坐标v compass(Z, 'b-o'); % 罗盘图复向量Z feather(u, v, 'b-o'); % 羽毛图横坐标u纵坐标v feather(Z, 'b-o'); % 羽毛图复向量Z quiver(x, y, u, v); % 以(x, y)为起点(u, v)为终点向量场图 %极坐标图 % polar(theta, rho, 'b-o'); % 极角theta, 半径rho theta = -pi:0.01:pi; rho = sin(theta); polar(theta, rho, 'b') %对数坐标图 semilogx(x1, y1, 'b-o'); % 把x轴对数刻度表示, semilogy是y轴对数刻度表示，loglog是两个坐标都用对数表示 %双纵坐标 plotyy(x1, y1, x2, y2, 'fun1', 'fun2'); % fun规定了两条条线的绘制方式，如plot,semilogx,semilogy,loglog,stem等 %函数绘图 f = 'sin(2*x)'; ezplot(f, [0, 2*pi]); % 绘制f并规定横坐标范围，也有[xmin, xmax, ymin, ymax] x = '2*cos(t)'; y = '4*sin(t)'; ezplot(x, y); % 绘制x(t),y(t)在[0, 2*pi]图像, 也可以在最后用[tmin, tmax]规定t的范围 3.3 三维曲线曲面 %三维曲线曲面绘制 %三维曲线 x = 0:0.1:2*pi; y = sin(x); z = cos(x); plot3(x, y, z, 'b-*'); %三维曲面 %三维网格 x = -5:0.1:5; % 规定了x轴采样点，也规定了x轴范围 y = -4:0.1:4; % 规定了y轴采样点，也规定了y轴范围 [X, Y] = meshgrid(x, y); % 得到了xoy面网格点 Z = X.^2+Y.^2; mesh(X, Y, Z) % XY是meshgrid得到的网格点，Z是网格顶点，c是用色矩阵可省略 %三维表面图 x = -5:0.1:5; y = -4:0.1:4; [X, Y] = meshgrid(x, y); Z = X.^2+Y.^2; % 以上部分同上 surf(X, Y, Z) % 与上一个类似 4. 多项式 4.1 多项式 %多项式 %创建 p = [1, 2, 3, 4]; % 系数向量，按x降幂排列，最右边是常数 f1 = poly2str(p, 'x'); % 生成好看的字符串 f1 = x^3 + 2 x^2 + 3 x + 4，不被认可的运算式 f2 = poly2sym(p); % 生成可用的符号函数 f2 = x^3 + 2*x^2 + 3*x + 4 %求值 x = 4; y1 = polyval(p, x); % 代入求值；若x1为矩阵，则对每个值单独求值 %求根 r = roots(p); % p同上，由系数求根，结果为根植矩阵 p0 = poly(r); % 由根求系数，结果为系数矩阵 4.2 数据插值 %数据插值 %一维插值 %yi = interp1(X, Y, xi, 'method') X = [-3, -1, 0, 1, 3]; Y = [9, 1, 0, 1, 9]; % XY为已知点横纵坐标向量 y2 = interp1(X, Y, 2); % 差值预估在x=2的y的值，x不能超过已知范围(此处x&lt;3) y2m = interp1(X, Y, 2, 'spline'); % 用spline方法(三次样条)差值预估在x=2的y的值 %二维插值 %zi = interp1(X, Y, Z, xi, yi, 'method') 4.3 数据统计 X = [2, 3, 9, 15, 6, 7, 4]; A = [1, 7, 2; 9, 5, 3; 8, 4 ,6]; B = [1, 7, 3; 9, 5, 3; 8, 4 ,6]; 注意：matlab矩阵默认按列存储，下列求均值、中值的默认是求一列的均值中值，需要加上加上参数2 后变成求一行的均值与中值 %数据统计 %矩阵最大最小值 y = max(X); % 求矩阵X的最大值，min最小值 [y, k] = max(X); % 求最大值，k为该值的角标 [y, k] = max(A, [], 2); % A是矩阵，'2'时返回y每一行最大元素构成的列向量，k元素所在列；'1'时与上述相同 %均值和中值 y = mean(X); % 均值 y = median(X); % 中值 第二个参数为空或者为 '1' 时，默认按列求，参数为 '2' 时 为按行求 y = mean(A, 2); % j'2'时返回y每一行均值构成的列向量；'1'时与上述相同 y = median(A, 2); % '2'时返回y每一行中值构成的列向量；'1'时与上述相同 %排序 Y = sort(A, 1, 'ascend'); % sort(矩阵, dim, 'method')dim为1按列排序，2按行排序；ascend升序，descend降序 [Y, I] = sort(A, 1, 'ascend'); % I保留了元素之前在A的位置 %求和求积累加累乘 y = sum(X); % 求和 y = prod(X); % 求积 y = cumsum(X); % 累加 y = cumprod(X); % 累乘 4.4 数值计算 %*数值计算 %最(极)值 %多元函数在给定初值附近找最小值点 x = fminsearch(fun, x0); %函数零点 x = fzero(fun, x0); % 在给定初值x0附近找零点 5. 符号函数 5.1 符号对象创建 %符号对象创建 %sym函数 p = sin(pi/3); P = sym(p, 'r'); % 用数值p创建符号常量P；'d'浮点数'f'有理分式的浮点数'e'有理数和误差'r'有理数 %syms函数 syms x; % 声明符号变量 f = 7*x^2 + 2*x+9; % 创建符号函数 %符号运算 % 加减乘除外 % '转置 ； ==相等 ； ~=不等 % sin, cos, tan; asin, acos, atan 三角反三角 % sinh, cosh, tanh; asinh, acosh, atanh 双曲反双曲 % conj复数共轭；real复数实部；imag复数虚部；abs复数模；angle复数幅角 % diag矩阵对角；triu矩阵上三角；tril矩阵下三角；inv逆矩阵；det行列式；rank秩；poly特征多项式； % |----expm矩阵指数函数；eig矩阵特征值和特征向量；svd奇异值分解； %符号对象精度转换 digits; % 显示当前用于计算的精度 digits(16); % 将计算精度改为16位，降低精度有时可以加快程序运算速度或减少空间占用 a16 = vpa(sqrt(2)); % vpa括起的运算使sqrt(2) 开更号运算按照规定的精度执行 a8 = vpa(sqrt(2), 8); % 在vpa内控制精度，离开这一步精度恢复 5.2 符号多项式函数运算 %符号多项式函数运算 %*符号表达形式与相互转化 %多项式展开整理 g = expand(f); % 展开 h = collect(g); % 整理(默认按x整理) h1 = collect(f, x); % 按x整理（降幂排列） %因式分解展开质因数 fac = factor(h); % 因式分解 factor(12); % 对12分解质因数 %符号多项式向量形式与计算 syms a b c; n = [a, b, c]; roots(n); % 求符号多项式ax^2+bx+c的根 n = [1, 2, 3]; roots(n); % 求符号多项式带入a=1, b=2, c=3的根 %*反函数 fi = finverse(f, x); % 对f中的变量x求反函数 5.3 符号微积分 %符号微积分 %函数的极限和级数运算 % 常量a，b %极限 limit(f, x, 4); % 求f(x), x-&gt;4 limit(f, 4); % 默认变量-&gt;4 limit(f); % 默认变量-&gt;0 limit(f, x, 4, 'right'); % 求f(x), x-&gt;4+, 'left' x-&gt;4- %*基本级数运算 %求和 symsum(s, x, 3, 5); % 计算表达式s变量x从3到5的级数和，或symsum(s, x, [a b])或symsum(s, x, [a;b]) symsum(s, 3, 5); % 计算s默认变量从3到5的级数和 symsum(s); % 计算s默认变量从0到n-1的级数和 %一维泰勒展开 taylor(f, x, 4); % f在x=4处展开为五阶泰勒级数 taylor(f, x); % f在x=0处展开为五阶泰勒级数 taylor(f); % f在默认变量=0处展开为五阶泰勒级数 %符号微分 %单变量求导（单变量偏导） n = 1; % 常量n fn = diff(f, x, n); % f对x的n阶导 f1 = diff(f, x); % f对x的1阶导 diff(f, n); % f对默认变量的n阶导 diff(f); % 默认变量1阶导 %多元偏导 fxy = diff(f, x, y); % 先求x偏导，再求y偏导 fxyz = diff(f, x, y, z); % 先求x偏导，再求y偏导,再求z偏导 %符号积分 %积分命令 int(f, x, 1, 2); % 函数f变量x在1~2区间定积分 int(f, 1, 2); % 函数f默认变量在ab区间定积分 int(f, x); % 函数f变量x不定积分 int(f); % 函数f默认变量不定积分 % 傅里叶，拉普拉斯，Z变换 5.4 符号方程求解 %*符号方程求解 %符号代数方程 %一元方程 eqn1 = a*x==b; S = solve(eqn1); % 返回eqn符号解 %多元方程组 eqn21 = x-y==a; eqn22 = 2*x+y==b; [Sx, Sy] = solve(eqn21, eqn22, x, y); % [Svar1,...SvarN]=solve(eqn1,...eqnM, var1,...varN),MN不一定相等 [Sxn, Syn] = solve(eqn21, eqn22, x, y, 'ReturnCondition', true); % 加上参数ReturnCondition可返回通解及解的条件 % 其他参数(参数加上true生效) % IgnoreProperty，忽略变量定义时一些假设 % IgnoreAnalyticConstraints，忽略分析限制； % MaxDegree，大于3解显性解； % PrincipleValue，仅主值 % Real，仅实数解 %非线性fsolve X = fsolve(fun, X0, optimset(option)); % fun函数.m文件名；X0求根初值；option选项如('Display','off')不显示中间结果等 6. 例题 在 matlab 中按给定分布率产生随机信号分析它们的特征。 在matlab 新建脚本英语便携高斯分布下随机信号产生代码 设置采样率为 5MHz ，采样点数为 50K 按均值为1，方差为1 的高斯分布产生随机信号，打印出它的波形，分析他的概率密度，自相关函数。 ","link":"https://blog.zhawenwen.cn/post/yi-xiao-shi-matlab-su-cheng-bi-ji/"},{"title":"Qt学习笔记_第二阶段","content":"1. QMainWindow QMainWindow是一个为用户提供主窗口程序的类，包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个锚接部件(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础，如文本编辑器，图片编辑器等。 1.1 菜单栏 一个主窗口最多只有一个菜单栏。位于主窗口顶部、主窗口标题栏下面。 #include &quot;mainwindow.h&quot; #include &quot;QMenuBar&quot; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { //重置窗口 resize(600,400); //菜单栏创建 QMenuBar *bar= menuBar(); //将菜单栏放入窗口中 setMenuBar(bar); //创建菜单(注意头文件) QMenu * fileMenu=bar-&gt;addMenu(&quot;文件&quot;); QMenu * editMenu=bar-&gt;addMenu(&quot;编辑&quot;); //创建菜单项 fileMenu-&gt;addAction(&quot;新建&quot;); //添加分割符 fileMenu-&gt;addSeparator(); fileMenu-&gt;addAction(&quot;打开&quot;); } MainWindow::~MainWindow() { } 1.2 工具栏 主窗口的工具栏上可以有多个工具条，通常采用一个菜单对应一个工具条的的方式，也可根据需要进行工具条的划分。 //工具栏 可以有多个 QToolBar * toolBar = new QToolBar(this); //将工具栏放入窗口中(注意头文件) addToolBar(Qt::LeftToolBarArea,toolBar); 工具条是一个可移动的窗口，它的停靠区域由QToolBar的allowAreas决定，包括： //工具栏 可以有多个 QToolBar * toolBar = new QToolBar(this); //将工具栏放入窗口中(注意头文件) addToolBar(Qt::LeftToolBarArea,toolBar); //后期设置，只允许左右停靠 toolBar-&gt;setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea); //设置不要浮动到中间 toolBar-&gt;setFloatable(false); //设置移动（总开关） toolBar-&gt;setMovable(false); //工具栏中可以设置内容 toolBar-&gt;addAction(newAction); //添加分割线 toolBar-&gt;addSeparator(); toolBar-&gt;addAction(openAction); //工具栏中添加控件 QPushButton *btn=new QPushButton(&quot;aa&quot;,this); toolBar-&gt;addWidget(btn); 1.3 状态栏、铆接部件（浮动窗口）、中心部件（核心部件） 状态栏最多有一个 //状态栏 最多有一个 QStatusBar *stBar = statusBar(); //设置到窗口中 setStatusBar(stBar); //放标签控件 QLabel *label=new QLabel(&quot;提示信息&quot;,this); stBar-&gt;addWidget(label); QLabel *label2=new QLabel(&quot;右侧提示信息&quot;,this); stBar-&gt;addPermanentWidget(label2); //铆接部件（浮动窗口）可以多个 QDockWidget * dockWidget = new QDockWidget(&quot;浮动&quot;,this); //将铆接部件放入窗口底部 addDockWidget(Qt::BottomDockWidgetArea,dockWidget); //设置后期停靠区域，只允许上下 dockWidget-&gt;setAllowedAreas(Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea); //设置中心部件(只能有一个) QTextEdit *edit=new QTextEdit(this); setCentralWidget(edit); 技巧：用 set 的只能创建一个，用 add 的可以创建多个 2. QtSource 2.1 ui 界面拖拽 可以直接在 ui 界面输入导航栏和状态栏，默认输入为英文，可在左下角中将其 text 改为中文。 2.2 导航栏状态栏等添加图片资源 首先将图片资源复制到项目文件夹下 右键项目创建新文件，qt-&gt;qtresources， 给项目起一个名字，例 res，系统自动生成 res.qrc 先添加前缀，后添加文件 使用：&quot;: + 前缀名 + 文件名&quot; // ui-&gt;actionnew-&gt;setIcon(QIcon(&quot;C:/Users/Administrator/Desktop/1.jpg&quot;)); // 使用添加Qt资源 &quot;: + 前缀名 + 文件名&quot; ui-&gt;actionnew-&gt;setIcon(QIcon(&quot;:/Image/Luffy.png&quot;)); ui-&gt;actionopen-&gt;setIcon(QIcon(&quot;:/Image/LuffyQ.png&quot;)); 3. 对话框 对话框分为模态对话框和非模态对话框。 模态对话框：不可以对其他窗口进行操作 非模态对话框：可以对其他窗口进行操作 //点击新建按钮，弹出一个对话框 connect(ui-&gt;actionnew,&amp;QAction::triggered,this,[=](){ //对话框 分类 //模态对话框（不可以对其他窗口进行操作） 非模态对话框（可以对其他窗口进行操作） // 模态对话框创建 阻塞功能 // QDialog dlg(this); // dlg.resize(200,100); // dlg.exec(); // 非模态对话框创建 //防止一闪而过，创建到堆区 QDialog *dlg2=new QDialog(this); dlg2-&gt;resize(200,100); //防止内存泄露 dlg2-&gt;setAttribute(Qt::WA_DeleteOnClose); dlg2-&gt;show(); }); 消息对话框：返回值为 standardButton 类型 //消息对话框: // 错误对话框 // QMessageBox::critical(this,&quot;critical&quot;,&quot;错误&quot;); //信息对话框 // QMessageBox::information(this,&quot;info&quot;,&quot;信息&quot;); //问题对话框 // QMessageBox::question(this,&quot;question&quot;,&quot;问题&quot;); //参数1：父亲，参数2：标题，参数3：内容，参数4：按键的类型，参数5：默认关联回车的类型 // QMessageBox::question(this,&quot;question&quot;,&quot;问题&quot;,QMessageBox::Save|QMessageBox::Cancel,QMessageBox::Cancel); if(QMessageBox::Save == QMessageBox::question(this,&quot;question&quot;,&quot;问题&quot;,QMessageBox::Save|QMessageBox::Cancel,“QMessageBox::Cancel)) { qDebug()&lt;&lt;&quot;save&quot;; }else{ qDebug()&lt;&lt;&quot;Cancel&quot;; } 可以根据对话框的返回值判断用户的输入。 //其他标准对话框 //颜色对话框（注意头文件） // QColorDialog::getColor(QColor(255,0,0)); //文件对话框 参数1：父亲，参数2：标题，参数3：默认打开的地址，参数4：过滤的文件格式 //返回值是选取的路径 // QString str= QFileDialog::getOpenFileName(this,&quot;打开文件&quot;,&quot;C:\\\\Users\\\\Administrator\\\\Desktop&quot;,&quot;*.txt&quot;); // qDebug()&lt;&lt;str; //字体对话框 bool flag; QFont font= QFontDialog::getFont(&amp;flag,QFont(&quot;宋体&quot;,36)); qDebug()&lt;&lt;font; 4. 界面布局 实现一个登录界面布局，利用 qt 中 ui 设计的方式进行窗口的设计与美化。 选择 label 进行登录框文字填写，使用 line Edit 当作输入框，使用 push Button 做点击按钮使用。 对于输入框与文字等不容易对其的，可以新建一个 Widget ,将输入框和文字拖入 Widget 中，然后根据需要选择 水平布局，垂直布局，栅格布局。 登录框与文字之间默认是两端对齐，可以通过添加弹簧 horizontal Spacer 的方式向中间挤，同时弹簧也可以手动调节宽度。 默认窗口与控件之间有9px的间距，可以通过参数进行调整。选中窗口，在左侧向下翻，找到 layout ,下面有 layoutLeftMargin 等参数，调整其即可。 默认的窗口特别大，可以选中窗口，在右下角sizePolicy垂直策略里进行调整。 总窗口也可以固定大小，在右下角 minimunSize , maximunSize 中进行调整。 6. 控件 6.1 按钮组 tool Buttom 工具按钮，常用于显示图片，若还想显示文字，修改风格：toolButtomStyle，设置凸起风格：autoRaise Radio Buttom 单选钮 桌面上的 Radio Buttom 默认只能选择一个，若有多个不同场合要使用该控件，需要使用 Group Box 进行分组操作。 //设置单选钮 默认选中男 ui-&gt;rBtnMan-&gt;setChecked(true); //当选中女后，打印信息 connect(ui-&gt;rBtnWoman,&amp;QRadioButton::clicked,this,[](){ qDebug()&lt;&lt;&quot;Woman&quot;; }); Check Box 多选按钮，一般使用一个 Group Box 将其包裹起来。多选按钮有一个 stateChanged(int state) 状态，其中选中时 state 返回2，未选中时 state 返回0。 //多选按钮，选中打印信息 state 值 2为选中，0为未选中 connect(ui-&gt;checkBox_4,&amp;QCheckBox::stateChanged,this,[=](int state){ qDebug()&lt;&lt;state; }); 6.2 List Widget 列表容器 利用 QListWidgetItem 创建一行内容，使用 ui-&gt;listWidget-&gt;addItem(item) 将其添加到 ui 的容器中，使用 item-&gt;setTextAlignment(int) 可以设置其居中形式。，可利用帮助文档查看。 也可以用 addItems 一次性添加一首诗。 //利用 listWidget 写诗 QListWidgetItem * item =new QListWidgetItem(&quot;锄禾日当午&quot;); //将一行诗放入 listWidget 控件中 ui-&gt;listWidget-&gt;addItem(item); //设置文本居中 item-&gt;setTextAlignment(Qt::AlignHCenter); 6.3 treeWidget 树控件 设置表头 ui-&gt;treeWidget-&gt;setHeaderLabels(QStringList()&lt;&lt;&quot;英雄&quot;&lt;&lt;&quot;英雄介绍&quot;); 创建并加载顶层结点：addTopLevelItem QTreeWidgetItem *item1=new QTreeWidgetItem(QStringList()&lt;&lt;&quot;力量&quot;); ui-&gt;treeWidget-&gt;addTopLevelItem(item1); 创建并添加子节点 ：addChild QStringList heroL1; heroL1&lt;&lt;&quot;刚被猪&quot;&lt;&lt;&quot;前排坦克，能在吸收伤害的同时造成客观的范围输出&quot;; QTreeWidgetItem *li =new QTreeWidgetItem(heroL1); item1-&gt;addChild(li); //treeWidget 树控件的使用 //设置表头 ui-&gt;treeWidget-&gt;setHeaderLabels(QStringList()&lt;&lt;&quot;英雄&quot;&lt;&lt;&quot;英雄介绍&quot;); QTreeWidgetItem *item1=new QTreeWidgetItem(QStringList()&lt;&lt;&quot;力量&quot;); QTreeWidgetItem *item2=new QTreeWidgetItem(QStringList()&lt;&lt;&quot;敏捷&quot;); QTreeWidgetItem *item3=new QTreeWidgetItem(QStringList()&lt;&lt;&quot;智力&quot;); //加载顶层节点 ui-&gt;treeWidget-&gt;addTopLevelItem(item1); ui-&gt;treeWidget-&gt;addTopLevelItem(item2); ui-&gt;treeWidget-&gt;addTopLevelItem(item3); //追加子节点 QStringList heroL1; heroL1&lt;&lt;&quot;刚被猪&quot;&lt;&lt;&quot;前排坦克，能在吸收伤害的同时造成客观的范围输出&quot;; QTreeWidgetItem *li =new QTreeWidgetItem(heroL1); //添加子节点 item1-&gt;addChild(li); 6.4 TableWidget 表格控件 设置列数 ui-&gt;tableWidget-&gt;setColumnCount(3) 设置水平表头，使用了 QSrtringList ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;&quot;姓名&quot;&lt;&lt;&quot;性别&quot;&lt;&lt;&quot;年龄&quot;) 设置行数 ui-&gt;tableWidget-&gt;setRowCount(5) 设置正文 首先创建一个 QStringList ，将数据放到 QStringList 中 QStringList nameList; nameList&lt;&lt;&quot;亚瑟&quot;&lt;&lt;&quot;赵云&quot;&lt;&lt;&quot;张飞&quot;&lt;&lt;&quot;关羽&quot;&lt;&lt;&quot;花木兰&quot;; 通过循环的方式将 QStringList 数组中的数据放到表格正文中 int 转 QString ：通过 QString::number(int) //TableWidget 表格控件 //设置列数 ui-&gt;tableWidget-&gt;setColumnCount(3); //设置水平表头 ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;&quot;姓名&quot;&lt;&lt;&quot;性别&quot;&lt;&lt;&quot;年龄&quot;); //设置行数 ui-&gt;tableWidget-&gt;setRowCount(5); //设置正文 // ui-&gt;tableWidget-&gt;setItem(0,0,new QTableWidgetItem(&quot;亚瑟&quot;)); QStringList nameList; nameList&lt;&lt;&quot;亚瑟&quot;&lt;&lt;&quot;赵云&quot;&lt;&lt;&quot;张飞&quot;&lt;&lt;&quot;关羽&quot;&lt;&lt;&quot;花木兰&quot;; QList&lt;QString&gt; sexList; sexList&lt;&lt;&quot;男&quot;&lt;&lt;&quot;男&quot;&lt;&lt;&quot;男&quot;&lt;&lt;&quot;男&quot;&lt;&lt;&quot;女&quot;; for(int i=0;i&lt;5;i++){ int col =0; ui-&gt;tableWidget-&gt;setItem(i,col++,new QTableWidgetItem(nameList[i])); ui-&gt;tableWidget-&gt;setItem(i,col++,new QTableWidgetItem(sexList.at(i))); // int 转 QString ui-&gt;tableWidget-&gt;setItem(i,col++,new QTableWidgetItem(QString::number((i+18)))); } ","link":"https://blog.zhawenwen.cn/post/qt-xue-xi-bi-ji-_-di-er-jie-duan/"},{"title":"关于最近数据丢失的一些说明（2021.10.29）","content":"由于近期给电脑跟换系统硬盘，数据备份时未备份完整，导致部分数据丢失。初期判断，本博客有4篇文章丢失，如图所示的4篇。 本博客是使用 Gridea 搭建的，数据暂时无法找回，所以只能忍痛放弃。 经过此事之后，我已给本博客相关配置参数等数据进行了多重备份，保证以后不会在丢失数据了。 特写本文，以示警告！ ","link":"https://blog.zhawenwen.cn/post/guan-yu-zui-jin-shu-ju-diu-shi-de-yi-xie-shuo-ming-20211029/"},{"title":"Qt学习笔记_第一阶段","content":"1.QT简介 1.1 跨平台图形界面引擎 1.2 优点 跨平台 接口简单，容易上手 一定程度上简化了内存回收 1.3 版本问题 商业版 开源版（Qt 5.9） 1.4 成功案例 linux 桌面环境 KDE 谷歌地图 VLC 多媒体播放器 2.创建第一个 Qt 程序 2.1 点击创建项目后，选择项目的路径和名称 2.2 名称不能有中文和空格 2.3 路径不能有中文名称 2.4 默认创建窗口类：myWidget，基类有三种选择：QWidget，QMainWidget，QDialog 2.5 main 函数 QApplication a 应用程序对象，有且仅有一个 myWidget w; 实例化窗口对象 w.show(); 调用show函数，显示函数 return a.exec(); 让应用程序对象进入消息循环机制中，代码阻塞到当前行 // main.cpp #include &quot;mywidget.h&quot; #include &lt;QApplication&gt; //包含一个应用程序类的头文件 // mian 函数入口 argc命令行变量的数量 argv命令行变量的数组 int main(int argc, char *argv[]) { // a 应用程序对象，在qt中，应用程序对象有且仅有一个 QApplication a(argc, argv); //窗口对象 myWidget父类 -&gt; QWidget myWidget w; //窗口对象默认不会显示，必须调用show方法展示窗口 w.show(); //让应用程序对象进入消息循环 //让代码阻塞到这行 return a.exec(); } 2.6 pro工程文件解释 // Qt 包含的模块 QT += core gui // 大于 4 版本以上，包含 widget 模块 greaterThan(QT_MAJOR_VERSION, 4): QT += widgets //目标 生成的.exe程序的名称 TARGET = 01firstProject // 模板 应用程序模板 TEMPLATE = app DEFINES += QT_DEPRECATED_WARNINGS // 源文件 SOURCES += \\ main.cpp \\ mywidget.cpp // 头文件 HEADERS += \\ mywidget.h 2.7 .h 文件解释 #ifndef MYWIDGET_H #define MYWIDGET_H // 包含头文件 Qwidget 窗口类 #include &lt;QWidget&gt; // 类 myWidget 继承父类 QWidget class myWidget : public QWidget { // Q_OBJECT宏，允许类中使用信号和槽的机制 Q_OBJECT public: // 构造函数（有参构造） myWidget(QWidget *parent = 0); // 析构函数 ~myWidget(); }; #endif // MYWIDGET_H 3. 按钮控件常见API 3.1 创建 QPushButton * btn=new QPushButton; 3.2 设置父亲 btn-&gt;setParent(this); 3.3 设置文本 btn-&gt;setText(&quot;第一个按钮&quot;); 3.4 设置位置 btn2-&gt;move(宽,高); 3.5 重新指定窗口大小 resize(600,400); 3.6 设置窗口标题 setWindowTitle(&quot;第一个窗口&quot;); 3.7 设置窗口固定大小 setFixedSize(600,400); // mywidget.cpp #include &quot;mywidget.h&quot; #include &lt;QPushButton&gt; // 按钮控件的头文件 // 命名规范 // 类名 首字母大写 ，单词与单词之间首字母大写 // 函数名 变量名称 首字母小写 // 快捷键 // 注释：ctrl + / // 运行：ctrl + r // 编译：ctrl + b // 字体缩放 ctrl + 鼠标滚轮 // 查找 ctrl + f // 整行移动 ctrl + shift + ↑ 或者 ↓ // 帮助文档 F1 // 自动对齐 ctrl + i // 同名之间的 .h 和 .cpp 切换 // 帮助文档 第一种方式 F1 第二种方式 左侧按钮 myWidget::myWidget(QWidget *parent) : QWidget(parent) { // 创建一个按钮 QPushButton * btn=new QPushButton; // btn-&gt;show();// show 以顶层方式弹出控件 // 让btn对象 依赖在 myWidget 窗口中 btn-&gt;setParent(this); // 显示文本 btn-&gt;setText(&quot;第一个按钮&quot;); //创建第二个按钮 QPushButton * btn2=new QPushButton(&quot;第二个按钮&quot;,this); // 移动btn2窗口 btn2-&gt;move(100,100); //重置窗口大小 resize(600,400); //设置固定的窗口大小 setFixedSize(600,400); //设置窗口标题 setWindowTitle(&quot;第一个窗口&quot;); } myWidget::~myWidget() { } 4. 对象数 4.1 当创建的对象在堆区时候，如果指定的父亲是 QObject 派生下来的类或者 QObject 的子类派生下来的类，可以不用管理释放的操作，将对象会放入对象树中。 QWidget是能够在屏幕上显示的一切组件的父类 QWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。 4.2 一定程度上简化了内存回收机制。 当一个QObject对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。 任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有QObject会被 delete 两次，这是由析构顺序决定的。 5. qt 中的坐标系 以左上角为原点（0,0），X向右增加，Y向下增加。 6. 信号与槽 6.1 连接函数 connect 6.2 参数 6.2.1 参数1 信号发送者 6.2.2 参数2 发送的信号 6.2.3 参数3 信号接受着 6.2.4 参数4 处理的槽函数 6.3 松散耦合 6.4 实现 ：点击按钮，关闭窗口的案例 //创建第二个按钮 QPushButton * btn2=new QPushButton(&quot;第二个按钮&quot;,this); // 移动btn2窗口 btn2-&gt;move(100,100); // 需求： 点击myBtn 关闭窗口 //参数1 信号的发送者 参数2 发送的信号(函数的地址) 参数3 函数的接受者 参数4 处理的槽 connect(btn2,&amp;QPushButton::clicked,this,&amp;QWidget::close);``` 7. 自定义的信号与槽 7.1 自定义信号 7.1.1 写到 signals 下 7.1.2 返回值为void 7.1.3 需要声明，不需要实现 7.1.4 可以有参数，可以重载 7.2 自定义槽函数 7.2.1 写到 public slot 或者 public 或者全局函数 7.2.2 返回为void 7.2.3 需要声明，需要实现 7.2.4 可以有参数，可以重载 7.3 触发自定义信号 7.3.1 emit 自定义信号 7.3 案例：下课后，老师发出饿了信号，学生响应，并请老师吃饭 8. 自定义信号和槽出现重载 需要利用函数指针明确指向函数的地址// 链接带参数的槽 // 指针 -》 地址 // 函数指针 -》 函数地址 void(Teacher:: *teacherSign)(QString)=&amp;Teacher::hungry; void(Student:: *studentSlot)(QString)=&amp;Student::treat; connect(zt,teacherSign,st,studentSlot); QString 类型转换为 char * 类型：解决打印出的值带有双引号 通过 toUtf8() 转换成 QByteArray 类型 然后通过 .data() 装换成 char * 类型 void Student::treat(QString foodName){ qDebug()&lt;&lt;&quot;eat:&quot;&lt;&lt;foodName; // QString 转 char *:先转成 QByteArray（.toUtf8()）再转成char *（.data()） qDebug()&lt;&lt;&quot;eat:&quot;&lt;&lt;foodName.toUtf8().data(); } 信号可以链接信号 //无参信号与槽链接 void(Teacher:: *teacherSign2)(void)=&amp;Teacher::hungry; void(Student:: *studentSlot2)(void)=&amp;Student::treat; connect(zt,teacherSign2,st,studentSlot2); //信号链接信号 按钮信号链接老师饿了的信号，直接触发 connect(btn,&amp;QPushButton::clicked,zt,teacherSign2); 断开信号 disconnect 8. 拓展: 1.信号可以链接信号 当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。 2.一个信号可以链接多个槽函数 如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。 3.多个信号可以同时链接同一个槽函数 只要任意一个信号发出，这个槽就会被调用。 4.信号与槽函数的参数 必须类型一一对应 5.信号与槽的参数的个数：信号的个数可以多于槽函数，但类型需要一一对应 9. qt4版本的信号与槽 connect(zt,SIGNAL(hungry(),st,SLOT(treat()); connect(信号的发送者,发送的信号SIGNAL(信号),信号的接受者,槽函数SLOT(槽函数)) 优点：参数直观 缺点：类型不做检测 qt5以上版本支持QT4版本的写法 这里使用了SIGNAL和SLOT这两个宏，将两个函数名转换成了字符串。注意到connect()函数的 signal 和 slot 都是接受字符串，一旦出现连接不成功的情况，Qt4是没有编译错误的（因为一切都是字符串，编译期是不检查字符串是否匹配），而是在运行时给出错误。这无疑会增加程序的不稳定性。 10. lambda 表达式函数、 函数：[](){}; 函数调用：[](){}(); [函数对象参数](操作符重载函数参数){函数体} [函数对象参数](操作符重载函数参数)mutable -&gt;返回值{函数体} 函数对象参数 [],标识一个 Lambda 的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。函数对象参数有以下形式： 空。没有使用任何函数对象参数。 =。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。 &amp;。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。 this。函数体内可以使用Lambda所在类中的成员变量。 a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。 &amp;a。将a按引用进行传递。 操作符重载函数参数 标识重载的 () 操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。 可修改标识符 mutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。 函数返回值 -&gt;返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。 函数体 {}，标识函数的实现，这部分不能省略，但函数体可以为空。 //利用lambda表达式 实现点击按钮关闭窗口 QPushButton * btn2 = new QPushButton; btn2-&gt;setParent(this); btn2-&gt;setText(&quot;关闭&quot;); btn2-&gt;move(100,0); // connect(btn2,&amp;QPushButton::clicked,this,&amp;Widget::close); //当第三个参数是 this 时，可以省略不写 connect(btn2,&amp;QPushButton::clicked,this,[=](){ this-&gt;close(); }); ","link":"https://blog.zhawenwen.cn/post/qt-xue-xi-bi-ji-_-di-yi-jie-duan/"},{"title":"javascript学习笔记——webapi_3_BOM","content":"这是本人最近学习 JavaScript_BOM 的一些记录，用来提醒和复习等使用！ BOM 浏览器对象模型 1. BOM 概述 1.1 什么是BOM 1.2 BOM 的构成 2. window 对象的常见事件 2.1 窗口加载事件 2.2 调整窗口大小事件 3. 定时器 3.1 两种定时器 3.2 setTimeout() 定时器 3.3 停止 setTimeout() 定时器 3.4 setInterval() 定时器 3.5 停止 setInterval() 定时器 3.6 this 4. JS 执行机制 4.1 JS 是单线程 4.2 同步和异步 4.3 同步执行与异步执行 4.4 JS 执行机制 5. location 对象 5.1 什么是 localtion 对象 5.2 URL 5.3 location 对象的属性 5.4 location 对象的方法 6. navigator 对象 7. history 对象 BOM 浏览器对象模型 1. BOM 概述 1.1 什么是BOM BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。 BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。 BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。 DOM: 文档对象模型 DOM 就是把「文档」当做一个「对象」来看待 DOM 的顶级对象是 document DOM 主要学习的是操作页面元素 DOM 是 W3C 标准规范 BOM: 浏览器对象模型 把「浏览器」当做一个「对象」来看待 BOM 的顶级对象是 window BOM 学习的是浏览器窗口交互的一些对象 BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差 1.2 BOM 的构成 BOM 比 DOM 更大，它包含 DOM 。 window 对象是浏览器的顶级对象，它具有双重角色。 它是 JS 访问浏览器窗口的一个接口。 它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法。 在调用的时候可以省略 window，前面学习的对话框都属于 window 对象方法，如 alert()、prompt() 等。 注意：window下的一个特殊属性 window.name 2. window 对象的常见事件 2.1 窗口加载事件 window.onload=function(){} 或者 window.addEvenListener('load',function(){}) window.onload 是窗口 (页面) 加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等), 才调用的处理函数。 注意： 有了 window.onload 就可以把 JS 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕， 再去执行处理函数。 window.onload 传统注册事件方式 只能写一次，如果有多个，会以最后一个 window.onload 为准。 如果使用 addEventListener 则没有限制 document.addEventListener('DOMContentLoaded',function(){}) DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。 如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。 2.2 调整窗口大小事件 window.onresize=function(){} 或者 window.addEventListener('resize',function(){}) window.onresize 是调整窗口大小加载事件, 当触发时就调用的处理函数。 注意： 只要窗口大小发生像素变化，就会触发这个事件。 我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度 &lt;style&gt; div { width: 200px; height: 200px; background-color: pink; } &lt;/style&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; var div = document.querySelector('div'); window.addEventListener('resize', function() { // window.innerWidth 当前屏幕的宽度 console.log(window.innerWidth); if (window.innerWidth &lt;= 800) { // 宽度 &lt; 800 时，隐藏 div div.style.display = 'none'; }else{ div.style.display = 'block'; } }) &lt;/script&gt; &lt;/body&gt; 3. 定时器 3.1 两种定时器 window 对象给我们提供了 2 个非常好用的方法-定时器。 setTimeout() setInterval() 3.2 setTimeout() 定时器 window.setTimeout(调用函数,[延迟的毫秒数]) setTimeout() 方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。 注意： window 可以省略。 这个调用函数可以直接写函数，或者写函数名或者采取字符串‘函数名()'三种形式。第三种不推荐 延迟的毫秒数省略默认是 0，如果写，必须是毫秒。 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符 &lt;body&gt; &lt;script&gt; // 1. setTimeout // 语法规范：window.setTimeout(调用函数,[延迟的毫秒数]) // 延时时间单位是毫秒，但是可以省略，省略默认为 0 // 页面中可能有很多的定时器，我们经常给定时器加标识符（名字） var timer1 = setTimeout(function() { console.log(11); }, 3000); var timer2 = setTimeout(fn, 5000); function fn() { console.log(22); } &lt;/script&gt; &lt;/body&gt; setTimeout() 这个调用函数我们也称为回调函数 callback 。 普通函数是按照代码顺序直接调用。 而这个函数，需要等待时间，时间到了才去调用这个函数，因此称为回调函数。 简单理解： 回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。 以前我们讲的 element.onclick = function(){} 或者 element.addEventListener(“click”, fn); 里面的 函数也是回调函数。 5秒后关闭广告案例： &lt;style&gt; div { width: 150px; height: 400px; background-color: pink; } &lt;/style&gt; &lt;body&gt; &lt;div&gt;广告&lt;/div&gt; &lt;script&gt; var ad = document.querySelector('div'); setTimeout(function() { ad.style.display = 'none'; }, 5000); &lt;/script&gt; &lt;/body&gt; 3.3 停止 setTimeout() 定时器 window.clearTimeout(timeoutID) clearTimeout()方法取消了先前通过调用 setTimeout() 建立的定时器。timeoutID 为之前定义的标识符。 &lt;body&gt; &lt;button&gt;点击停止定时器&lt;/button&gt; &lt;script&gt; var btn = document.querySelector('button'); var timer1 = setTimeout(() =&gt; { console.log('爆炸了！'); }, 5000); btn.addEventListener('click', function() { clearTimeout(timer1); }) &lt;/script&gt; &lt;/body&gt; 3.4 setInterval() 定时器 window.setInterval(回调函数,[间隔毫秒数]); setInterval() 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。 倒计时案例： &lt;style&gt; span { width: 50px; height: 50px; background-color: pink; display: block; float: left; margin-left: 10px; font-size: 30px; line-height: 50px; text-align: center; } &lt;/style&gt; &lt;body&gt; &lt;div&gt; &lt;span class=&quot;h&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;3&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 1. 获取元素 var hh = document.querySelector('.h'); var mm = document.querySelector('.m'); var ss = document.querySelector('.s'); var inputTime = +new Date('2021-09-26'); // 倒计时函数 function countDown() { var nowTime = +new Date(); var times = (inputTime - nowTime) / 1000; var h = parseInt(times / 60 / 60); var m = parseInt(times / 60 % 60); var s = parseInt(times % 60); hh.innerHTML = h; mm.innerHTML = m; ss.innerHTML = s; } setInterval(countDown, 1000); &lt;/script&gt; &lt;/body&gt; 3.5 停止 setInterval() 定时器 window.clearInterval(intervalID); clearInterval()方法取消了先前通过调用 setInterval()建立的定时器。 发送短信案例： &lt;body&gt; 手机号码：&lt;input type=&quot;number&quot; name=&quot;&quot; id=&quot;&quot;&gt; &lt;button&gt;发送&lt;/button&gt; &lt;script&gt; var time = 10; var btn = document.querySelector('button'); btn.addEventListener('click', function() { btn.disabled = true; var timer1 = setInterval(() =&gt; { if (time) { btn.innerHTML = '还剩余' + time + '秒'; time--; } else { clearInterval(timer1); btn.innerHTML = '发送'; btn.disabled = false; // time 需要重新赋值，以便下次操作 time = 10; } }, 1000); }) &lt;/script&gt; &lt;/body&gt; 3.6 this this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象。 现阶段，我们先了解一下几个this指向 全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window） 方法调用中谁调用this指向谁 构造函数中this指向构造函数的实例 4. JS 执行机制 4.1 JS 是单线程 JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。 4.2 同步和异步 为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步。 同步： 前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。 异步 你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。 他们的本质区别： 这条流水线上各个流程的执行顺序不同。 4.3 同步执行与异步执行 同步任务： 同步任务都在主线程上执行，形成一个执行栈。 异步任务： JS 的异步是通过回调函数实现的。 一般而言，异步任务有以下三种类型: 1、普通事件，如 click、resize 等 2、资源加载，如 load、error 等 3、定时器，包括 setInterval、setTimeout 等 异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）。 4.4 JS 执行机制 先执行执行栈中的同步任务。 异步任务（回调函数）放入任务队列中。 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。 由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop）。 5. location 对象 5.1 什么是 localtion 对象 window 对象给我们提供了一个 location 属性用于获取或设置窗体的 URL，并且可以用于解析 URL 。 因为这个属性返回的是一个对象，所以我们将这个属性也称为 location 对象。 5.2 URL 统一资源定位符 (Uniform Resource Locator, URL) 是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 protocol://host[:port]/path/[?query]#fragment http://www.itcast.cn/index.html?name=andy&amp;age=18#link 5.3 location 对象的属性 重点记住： href 和 search &lt;body&gt; &lt;button&gt;点击&lt;/button&gt; &lt;script&gt; var btn = document.querySelector('button'); btn.addEventListener('click', function() { console.log(location.href); // 打印当前 URL location.href = 'http://blog.gitnote.cn'; // 去往新的URL }) &lt;/script&gt; &lt;/body&gt; 5秒后跳转首页案例： &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; var div = document.querySelector('div'); var time = 5; setInterval(function() { if (time) { div.innerHTML = '你将在' + time + 's后转到首页'; time--; } else { location.href = 'http://blog.gitnote.cn'; // 去往新的URL time = 5; } }, 1000) &lt;/script&gt; &lt;/body&gt; URL 传参案例： ① 第一个登录页面，里面有提交表单， action 提交到 index.html页面 ② 第二个页面，可以使用第一个页面的参数，这样实现了一个数据不同页面之间的传递效果 ③ 第二个页面之所以可以使用第一个页面的数据，是利用了URL 里面的 location.search参数 ④ 在第二个页面中，需要把这个参数提取。 ⑤ 第一步去掉？ 利用 substr ⑥ 第二步 利用=号分割 键 和 值 split(‘=‘) ⑦ 第一个数组就是键 第二个数组就是值 // # login.html &lt;body&gt; &lt;form action=&quot;index.html&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;uname&quot; id=&quot;&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;&quot; id=&quot;&quot;&gt; &lt;/form&gt; &lt;/body&gt; // # index.html &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; console.log(location.search); // 1. 先去掉 ？ substr(起始的位置,截取几个字符) var params = location.search.substr(1); console.log(params); // 2. 利用 = 分割字符串 split('=') var arr = params.split('='); console.log(arr); var div = document.querySelector('div'); div.innerHTML = arr[1] + '欢迎你！'; &lt;/script&gt; &lt;/body&gt; 5.4 location 对象的方法 location.assign('URL'); // 实现链接跳转，记录浏览历史，可以实现前进后退 location.replace('URL'); // 实现链接跳转，不记录浏览历史，不能实现前进后退 6. navigator 对象 navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。 下面前端代码可以判断用户那个终端打开页面，实现跳转: if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android| Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS |Symbian|Windows Phone)/i))) { window.location.href = &quot;&quot;; //手机 } else { window.location.href = &quot;&quot;; //电脑 } 7. history 对象 window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的 URL。 ","link":"https://blog.zhawenwen.cn/post/javascript-webapi_3_bom/"},{"title":"javascript学习笔记——webapi_2_事件高级","content":"本文是本人最近学习 javascript 的笔记，内容尚不完善，正在学习补充中！ 事件高级 1. 注册事件（绑定事件） 1.1 注册事件概述 给元素添加事件，称为注册事件或者绑定事件。 注册事件有两种方式：传统方式和方法监听注册方式。 传统注册方式： 利用 on 开头的事件 onclick &lt;button onclick=”alret('hi~')“&gt; btn.onclick=function(){} 特点：注册事件的唯一性 方法监听注册方式: w3c 标准推荐方式 addEventListener() 它是一个方法 IE9 之前的 IE 不支持此方法，可使用 attachEvent() 代替 特点：同一个元素同一个事件可以注册多个监听器 按注册顺序依次执行 1.2 addEventListener eventTarget.addEventListener(type,listener[,useCapture]) eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。 该方法接收三个参数： type：事件类型字符串，比如 click 、mouseover ，注意这里不要带 on listener：事件处理函数，事件发生时，会调用该监听函数 useCapture：可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习 &lt;body&gt; &lt;button&gt;传统注册事件&lt;/button&gt; &lt;button&gt;方法监听注册实践&lt;/button&gt; &lt;script&gt; var btns = document.querySelectorAll('button'); // 1. 传统方式注册事件 只执行绑定的最后一个事件处理程序 btns[0].onclick = function() { alert('hi~') } btns[0].onclick = function() { alert('R U ok~') } // 2. 事件侦听注册事件 addEventListener 里面的事件类型是字符串 // 同一个元素，同一个事件可以添加多个侦听器（事件处理程序） btns[1].addEventListener('click', function() { alert('22'); }) btns[1].addEventListener('click', function() { alert('33'); }) &lt;/script&gt; &lt;/body&gt; 1.3 attachEvent 事件监听方式(非标准) eventTarget.attachEvent(eventNameWithOn, callback) eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 该方法接收两个参数： eventNameWithOn：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on callback： 事件处理函数，当目标触发事件时回调函数被调用 注意：IE8 及早期版本支持 2. 删除事件（解绑事件） 2.1 删除事件的方式 传统注册方式 eventTarget.onclick = null; 方法监听注册方式 eventTarget.removeEventListener(type, listener[, useCapture]); eventTarget.detachEvent(eventNameWithOn, callback); // ie8以前 &lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;script&gt; var divs = document.querySelectorAll('div'); divs[0].onclick = function() { alert('11'); // 1. 传统方式删除事件 divs[0].onclick = null; } //2. 方法监听注册方式删除事件 注：这里不能用匿名函数 divs[1].addEventListener('click', fn); function fn() { alert('22'); divs[1].removeEventListener('click', fn); } &lt;/script&gt; &lt;/body&gt; 3. DOM 事件流 事件流描述的是从页面中接收事件的顺序。 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。 DOM 事件流分为3个阶段: 捕获阶段 当前目标阶段 冒泡阶段 事件冒泡： IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。 事件捕获： 网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。 我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。 注意 JS 代码中只能执行捕获或者冒泡其中的一个阶段。 onclick 和 attachEvent 只能得到冒泡阶段。 addEventListener(type, listener[, useCapture])第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false（不写默认就是false），表示在事件冒泡阶段调用事件处理程序。 实际开发中我们很少使用事件捕获，我们更关注事件冒泡。 有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave 事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解。 &lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // DOM 事件流的三个阶段 // 1. JS 代码只能执行捕获或者冒泡其中的一个阶段。 // 2. onclick 和 attachEvent (ie) 只能得到冒泡阶段。 // 3. 捕获阶段 如果 addEventListener 第三个参数为 true ，那么则处于捕获阶段 // document -&gt; html -&gt; body -&gt; father -&gt; son var son = document.querySelector('.son'); son.addEventListener('click', function() { console.log('son'); }, true); var father = document.querySelector('.father'); father.addEventListener('click', function() { console.log('father'); }, true); // 4. 冒泡阶段 如果 addEventListener 第三个参数为 false 或者省略 ，那么则处于冒泡阶段 // son -&gt; father -&gt; body -&gt; html -&gt;document var son = document.querySelector('.son'); son.addEventListener('click', function() { console.log('son'); }, false); var father = document.querySelector('.father'); father.addEventListener('click', function() { console.log('father'); }, false); &lt;/script&gt; &lt;/body&gt; 4. 事件对象 4.1 什么是事件对象 官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。 简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象 event，它有很多属性和方法。 &lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;div&gt;123&lt;/div&gt; &lt;script&gt; // 事件对象 var divs = document.querySelectorAll('div'); // 1. event 就是一个事件对象 写到我们监听函数的括号里 // 2. 事件对象只有有了事件才会存在，它是系统自动创建的，不需要传递参数 // 3. 事件对象是我们事件的一系列相关数据的集合 跟事件相关的 比如鼠标点击里面就包含了鼠标的相关信息， // 4. 事件对象我们可以自己命名，比如 event、e // 5. 事件对象也有兼容性问题 ie678 通过 window.event divs[0].onclick = function(event) { console.log(event); } divs[1].addEventListener('click', function(event) { console.log(event); }) &lt;/script&gt; &lt;/body&gt; 4.2 事件对象的常见属性和方法 e.target 与 this 的区别： &lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;ul&gt; &lt;li&gt;abc&lt;/li&gt; &lt;li&gt;abc&lt;/li&gt; &lt;li&gt;abc&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 常见事件对象的属性和方法 // 1. e.target 返回的是触发事件的对象（元素） // this 返回的是绑定事件的对象（元素） var div = document.querySelector('div'); div.addEventListener('click', function(e) { console.log(e.target); console.log(this); }) var ul = document.querySelector('ul'); ul.addEventListener('click', function(e) { // 我们给 ul 绑定了事件，那么 this 就指向 ul console.log(this); // ul // e.target 指向我们点击的那个对象 谁触发了这个事件 console.log(e.target); //li }) &lt;/script&gt; &lt;/body&gt; 事件对象阻止默认行为： &lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;form action=&quot;http://www.baidu.com&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;sub&quot;&gt; &lt;/form&gt; &lt;script&gt; // 常见事件对象的属性和方法 // 1. 返回事件类型 var div = document.querySelector('div'); div.addEventListener('click', fn); function fn(e) { console.log(e.type); // click } // 2. 阻止默认行为（事件） 让链接不跳转 或 让提交按钮不提交 var a = document.querySelector('a'); a.addEventListener('click', function(e) { e.preventDefault(); // 该方法阻止默认事件行为，如不让链接跳转等 }) a.onclick = function() { // 我们可以利用 return false 也能阻止默认行为，没有兼容性问题，但return 后的代码不再执行 return false; } &lt;/script&gt; &lt;/body&gt; 5. 阻止事件冒泡 5.1 阻止事件冒泡的两种方式 事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点。 事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握. 阻止事件冒泡 标准写法：利用事件对象里面的 stopPropagation()方法 e.stopPropagation() 非标准写法：IE 6-8 利用事件对象 cancelBubble 属性 e.cancelBubble = true; &lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 常见事件对象的属性和方法 // 阻止冒泡 DOM 推荐的标准 stopPropagation() var son = document.querySelector('.son'); son.addEventListener('click', function(e) { console.log('son'); e.stopPropagation(); //阻止冒泡 }, false); var father = document.querySelector('.father'); father.addEventListener('click', function() { console.log('father'); }, false); document.addEventListener('click', function() { console.log('document'); }) &lt;/script&gt; &lt;/body&gt; 6. 事件委托（代理、委派） 事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。生活中有如下场景： 咱们班有100个学生， 快递员有100个快递， 如果一个个的送花费时间较长。同时每个学生领取的时候，也需要排队领取，也花费时间较长，何如？ 解决方案： 快递员把100个快递，委托给班主任，班主任把这些快递放到办公室，同学们下课自行领取即可。 优势： 快递员省事，委托 给班主任就可以走了。 同学们领取也方便，因为相信班主任。 事件委托 事件委托也称为事件代理， 在 jQuery 里面称为事件委派。 事件委托的原理 不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。 以上案例：给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li，因为点击 li，事件会冒泡到 ul 上，ul 有注册事件，就会触发事件监听器。 事件委托的作用 我们只操作了一次 DOM ，提高了程序的性能。 &lt;body&gt; &lt;ul&gt; &lt;li&gt;之乎者也&lt;/li&gt; &lt;li&gt;之乎者也&lt;/li&gt; &lt;li&gt;之乎者也&lt;/li&gt; &lt;li&gt;之乎者也&lt;/li&gt; &lt;li&gt;之乎者也&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 事件委托的核心原理：给父节点添加监听器，利用事件冒泡影响每个子节点 var ul = document.querySelector('ul'); ul.addEventListener('click', function(e) { console.log('123'); e.target.style.backgroundColor = 'pink'; }) &lt;/script&gt; &lt;/body&gt; 7. 常用鼠标事件 7.1 常用鼠标事件 禁止鼠标右键菜单 contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单。 &lt;body&gt; 我是一段不愿意分享的文字 &lt;script&gt; // 1. contextmenu 我们可以禁用右键 document.addEventListener('contextmenu', function(e) { e.preventDefault(); //取消默认事件 }) &lt;/script&gt; &lt;/body&gt; 禁用鼠标选中（selectstart 开始选中） &lt;body&gt; 我是一段不愿意分享的文字 &lt;script&gt; // 2. 禁止选中文字 selectstart document.addEventListener('selectstart', function(e) { e.preventDefault(); }) &lt;/script&gt; &lt;/body&gt; 7.2 鼠标事件对象 event对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象 MouseEvent 和键盘事件对象 KeyboardEvent。 &lt;body&gt; &lt;script&gt; // 鼠标事件对象 MouseEvent document.addEventListener('click', function(e) { // 1. client 鼠标在可视区的 X Y 坐标 console.log(e.clientX); console.log(e.clientY); // 2. page 鼠标在页面文档的 X Y 坐标 console.log(e.pageX); console.log(e.pageY); }) &lt;/script&gt; &lt;/body&gt; 跟随鼠标的案例： 鼠标不断的移动，使用鼠标移动事件： mousemove 在页面中移动，给document注册事件 图片要移动距离，而且不占位置，我们使用绝对定位即可 核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 把这个x和y坐标做为图片的top和left 值就可以移动图片 &lt;style&gt; img { position: absolute; } &lt;/style&gt; &lt;body&gt; &lt;img src=&quot;http://md.gitnote.cn/WebApi笔记_2_事件高级-2021924104851.png&quot; alt=&quot;&quot;&gt; &lt;script&gt; var pic = document.querySelector('img'); document.addEventListener('mousemove', function(e) { // mousemove 只要鼠标移动就触发 var x = e.pageX; var y = e.pageY; pic.style.left = x - 50 + 'px'; pic.style.top = y - 50 + 'px'; }) &lt;/script&gt; &lt;/body&gt; 8. 常用键盘事件 8.1 常用键盘事件 事件除了使用鼠标触发，还可以使用键盘触发。 &lt;body&gt; &lt;script&gt; // 常用的键盘事件 // 1. keyup 按键弹起的时候触发 document.onkeyup = function() { console.log('我弹起了！'); } // 2. keydown 按键按下的时候触发 document.onkeydown = function() { console.log('我按下了！'); } // 3. keypress 按键按下的时候触发 不能识别功能键 ctrl shift document.onkeypress = function() { console.log('我按下了press！'); } // 4. 三个事件的执行顺序 keydown keypress keyup &lt;/script&gt; &lt;/body&gt; 8.2 键盘事件对象 注意： onkeydown 和 onkeyup 不区分字母大小写，onkeypress 区分字母大小写。 在我们实际开发中，我们更多的使用keydown和keyup， 它能识别所有的键（包括功能键） Keypress 不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCII值 &lt;body&gt; &lt;script&gt; // 键盘事件对象中的 keyCode 属性,返回按下键的 ASCII 码值 document.addEventListener('keyup', function(e) { console.log(e); console.log(e.keyCode); // 1. 我们的 keyup 和 keydown 事件不区分字母大小写 a 和 A 得到的都是 A:65 // 2. 我们的 keypress 事件区分字母大小写 a:97 A:65 }) &lt;/script&gt; &lt;/body&gt; 模拟京东按键输入案例： 核心思路： 检测用户是否按下了s 键，如果按下s 键，就把光标定位到搜索框里面 使用键盘事件对象里面的keyCode 判断用户按下的是否是s键 搜索框获得焦点： 使用 js 里面的 focus() 方法 &lt;body&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot;&gt; &lt;script&gt; var search = document.querySelector('input'); document.addEventListener('keyup', function(e) { if (e.keyCode === 83) { search.focus(); } }) &lt;/script&gt; &lt;/body&gt; ","link":"https://blog.zhawenwen.cn/post/javascript-webapi_2/"},{"title":"javascript学习笔记——webapi_1_DOM基础","content":"本文是本人最近学习 javascript 的笔记，内容尚不完善，正在学习补充中！ 一、WebApi 编程 目标： 能说出WebApi 与 JavaScript 的关联 能说出什么是API 能说出什么是WebApi 1. WebApis 和 JS 基础关联性 1.1 JS 的组成 1.2 JS 基础阶段以及WebAPIs阶段 JS 基础阶段： 学习 ECMAScript 标准规定的基本语法 要求掌握 JS 基础语法 只学习基础语法，做不了常见的网页交互效果 目的是为了 JS 后面的课程打基础、做铺垫 Web APIs 阶段 webapis 是 W3C 组织的标准 webapis 我们主要学习DOM和BOM webapis 是我们JS所独有的部分 我们主要学习页面交互功能 需要使用JS基础的课程内容做基础 js 学习基础语法为后面作铺垫，WebAPIs 是JS 的应用，大量使用JS基础语法做交互效果 2.api 和 webapi 2.1 api api是一些预先定义的函数，目的是提供应用程序与开发人员给予某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 简单理解：api是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能。 2.2 webapi webapi 是浏览器提供的一套操作浏览器功能和页面元素的API(BOM和DOM)。 MDN详细API：https://developer.mozilla.org/zh-CN/docs/Web/API 二、DOM（文档对象模型） 1.DOM 简介 1.1 什么是 DOM 文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口。 W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式 1.2 DOM 树 文档：一个页面就是一个文档，DOM 中使用 document 表示 元素：页面中的所有标签都是元素，DOM 中使用 element 表示 节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM 中使用 node 表示 2.获取元素 2.1 如何获取页面元素 获取页面中的元素可以使用以下几种方式： 根据 ID 获取 根据标签名获取 通过HTML5新增的方法获取 特殊元素获取 2.2 根据 ID 获取 getElementById() &lt;body&gt; &lt;div id=&quot;time&quot;&gt;2021-09-19&lt;/div&gt; &lt;script&gt; //1. 因为文档页面从上到下加载，所以要先有标签，所以script要写到下面 //2. 参数 id 大小写敏感的字符串 //3. 返回的是一个元素对象 var timer = document.getElementById('time'); console.log(timer); console.log(typeof timer); //4. console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法 console.dir(timer); &lt;/script&gt; &lt;/body&gt; 2.2 根据 标签名 获取 getElementsByTagName() # 返回带有指定标签名的对象的集合 &lt;body&gt; &lt;ul&gt; &lt;li&gt;知否知否&lt;/li&gt; &lt;li&gt;知否知否&lt;/li&gt; &lt;li&gt;知否知否&lt;/li&gt; &lt;li&gt;知否知否&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;知否知否&lt;/li&gt; &lt;li&gt;知否知否&lt;/li&gt; &lt;li&gt;知否知否&lt;/li&gt; &lt;li&gt;知否知否&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; // 1. 返回的是 获取过来元素对象的集合，以伪数组的形式存储的 var lis = document.getElementsByTagName('li'); console.log(lis); console.log(lis[0]); // 2. 依次打印元素对象，采用遍历的方式 for (let i = 0; i &lt; lis.length; i++) { console.log(lis[i]); } // 3. 如果页面中只有一个li，返回的还是伪数组形式 // 4. 如果页面中没有元素，返回的还是伪数组形式 // 5. element.getElementsByTagName() var ol = document.getElementsByTagName('ol'); //[ol] console.log(ol[0].getElementsByTagName('li')); &lt;/script&gt; &lt;/body&gt; 2.3 H5新增获取元素方法 document.getElementByClassName('类名'); //根据类名返回元素对象的集合 document.querySelector('选择器'); //根据指定选择器返回第一个元素对象 document.querySelectorAll('选择器'); //根据指定选择器返回所有元素对象 &lt;body&gt; &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt; &lt;div id=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;产品&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; // 1. getElementByClassName() 根据类名获取某些元素集合 var boxs = document.getElementsByClassName('box'); console.log(boxs); // 2. querySelector() 返回指定选择器的第一个元素对象 var firstBox = document.querySelector('.box'); console.log(firstBox); // 3. querySelectorAll() 返回指定选择器的所有元素对象 var allBox = document.querySelectorAll('.box'); console.log(allBox); &lt;/script&gt; &lt;/body&gt; 2.4 获取特殊元素（body，html） 获取body元素： document.body; 获取html元素： document.documentElement; &lt;body&gt; &lt;script&gt; //1. 获取body元素 var bodyEle = document.body; console.log(bodyEle); console.dir(bodyEle); //2. 获取html元素 var htmlEle = document.documentElement; console.log(htmlEle); &lt;/script&gt; &lt;/body&gt; 3.事件基础 3.1 事件描述 JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。 简单理解： 触发--- 响应机制。 网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。 3.2 事件三要素 事件源 （谁） 事件类型 （什么事件） 事件处理程序 （做啥） &lt;body&gt; &lt;button id=&quot;btn&quot;&gt;唐伯虎&lt;/button&gt; &lt;script&gt; //点击一个按钮，弹出对话框 //1.事件是由三部分组成：事件源，事件类型，事件处理程序。我们也称之为事件的三要素 // (1)事件源：时间被触发的对象 谁 按钮 var btn = document.getElementById('btn'); // (2)事件类型 如何触发 什么事件 如鼠标点击（onclick） // (3)事件处理程序 通过一个函数赋值的方式完成 btn.onclick = function() { alert('点秋香') } &lt;/script&gt; &lt;/body&gt; 3.3 执行事件的步骤 获取事件源 注册事件（绑定事件） 添加事件处理程序（采取函数赋值形式） &lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;script&gt; //执行事件的步骤 //点击div ，控制台输出：我被选中了 //1. 获取事件源 var div = document.querySelector('div'); //2. 绑定事件 注册事件 // div.onclick //2. 添加事件处理程序 div.onclick = function() { console.log('我被选中了！'); } &lt;/script&gt; &lt;/body&gt; 常见的鼠标事件： 4. 操作元素 JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容 、属性等。注意以下都是属性 4.1 改变元素内容 element.innerText 从起始位置到终止位置的内容, 但它去除 html 标签， 同时空格和换行也会去掉 element.innerHTML 起始位置到终止位置的全部内容，包括 html 标签，同时保留空格和换行 &lt;body&gt; &lt;button&gt;显示当前系统时间&lt;/button&gt; &lt;div&gt;某个时间&lt;/div&gt; &lt;script&gt; //当我们点击了按钮，div里面的文字会发生变化 //1. 获取元素 var btn = document.querySelector('button'); var div = document.querySelector('div'); //2. 注册事件 btn.onclick = function() { div.innerText = new Date(); } &lt;/script&gt; &lt;/body&gt; innerText 与 innerHTML 的区别： &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;我是文字 &lt;span&gt;123&lt;/span&gt; &lt;/p&gt; &lt;script&gt; // innerText与innerHTML的区别 // 1. innerText 不识别html标签 非标准 var div = document.querySelectorAll('div'); div[0].innerText = '&lt;strong&gt;今天是：&lt;/strong&gt;2021'; // 2. innerHTML W3C标准 div[1].innerHTML = '&lt;strong&gt;今天是：&lt;/strong&gt;2021'; //这两个属性是可读写的，可以获取元素里面的内容 var p = document.querySelector('p'); console.log(p.innerText); console.log(p.innerHTML); &lt;/script&gt; &lt;/body&gt; 4.2 常用元素的属性操作 innerText、innerHTML 改变元素内容 src、href id、alt、title 修改图片 src &lt;body&gt; &lt;button id=&quot;ldh&quot;&gt;刘&lt;/button&gt; &lt;button id=zxy&gt;张&lt;/button&gt; &lt;img src=&quot;https://pics5.baidu.com/feed/5366d0160924ab1828d302891e29f9c879890b9b.jpeg?token=23927fab33a65e66546edc273084fce3&amp;s=80108F7A58F30686582C69F703005063&quot; alt=&quot;&quot; srcset=&quot;&quot; width=&quot;200px&quot; height=&quot;200px&quot;&gt; &lt;script&gt; //修改元素 src // 1.获取元素 var ldh = document.getElementById('ldh'); var zxy = document.getElementById('zxy'); var img = document.querySelector('img'); // 2.注册事件 zxy.onclick = function() { img.src = 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdingyue.nosdn.127.net%2F3WKmSi9G2oCkRdfU004xJEtTbc%3DPbkZFzLgi08W%3DAr0CR1499226607542.jpg&amp;refer=http%3A%2F%2Fdingyue.nosdn.127.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1634865888&amp;t=b65eb0551c13b0ddf42e8de05069b1c2'; }; ldh.onclick = function() { img.src = 'https://pics5.baidu.com/feed/5366d0160924ab1828d302891e29f9c879890b9b.jpeg?token=23927fab33a65e66546edc273084fce3&amp;s=80108F7A58F30686582C69F703005063'; }; &lt;/script&gt; &lt;/body&gt; &lt;body&gt; &lt;div&gt;上午好&lt;/div&gt; &lt;script&gt; // 根据系统不同时间来判断，所以需要用到日期内置对象 // 利用多分支语句来设置不同的图片 // 需要一个图片，并且根据时间修改图片，就需要用到操作元素src属性 // 需要一个div元素，显示不同问候语，修改元素内容即可 // 1.获取元素 var div = document.querySelector('div'); // 2.获取当前的小时数 var date = new Date(); var h = date.getHours(); // 3.判断 if (h &lt; 12) { div.innerHTML = '上午好'; } else if (h &lt; 18) { div.innerHTML = '下午好'; } else { div.innerHTML = '晚上好'; } &lt;/script&gt; &lt;/body&gt; 4.3 表单元素的属性操作 利用 DOM 可以操作如下表单元素的属性： type、value、checked、selected、disabled &lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;input type=&quot;text&quot; value=&quot;输入内容&quot;&gt; &lt;script&gt; // 1.获取元素 var btn = document.querySelector('button'); var input = document.querySelector('input'); // 2.注册事件，处理程序 btn.onclick = function() { //表单里的值 文字内容是通过 value 来修改的 input.value = '被点击了！'; //如果想要某个表单被禁用 不能再点击 disabled // btn.disabled = true; // this 指向的是事件函数的调用者 btn this.disabled=true; } &lt;/script&gt; &lt;/body&gt; 仿京东显示密码案例： &lt;style&gt; .box { width: 400px; border-bottom: 1px solid #ccc; margin: 100px auto; position: relative; } .box input { width: 370px; height: 30px; border: 0; outline: none; } .box label { position: absolute; top: 8px; right: 10px; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;label for=&quot;&quot;&gt;密&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot;&gt; &lt;/div&gt; &lt;script&gt; //1. 获取元素 var label = document.querySelector('label'); var input = document.querySelector('input'); //2. 注册事件 绑定程序 var flag = 0; label.onclick = function() { if (flag == 0) { input.type = 'text'; label.innerHTML = '明'; flag = 1; } else { input.type = 'password'; label.innerHTML = '密'; flag = 0; } } &lt;/script&gt; &lt;/body&gt; 算法：利用一个flag变量，来判断flag的值，如果是1 就切换为文本框，flag 设置为0，如果是0 就切换为密码框，flag设置为1 。 4.4 样式属性操作 我们可以通过 JS 修改元素的大小、颜色、位置等样式。 element.style 行内样式操作 element.className 类名样式操作 注意： 1.JS 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor。 2.JS 修改 style 样式操作，产生的是行内样式，CSS 权重比较高。 &lt;style&gt; div { width: 200px; height: 200px; background-color: pink; } &lt;/style&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; // 1.获取元素 var div = document.querySelector('div'); // 2.注册事件 处理程序 div.onclick = function() { // div.style 里面的属性采用的是驼峰命名法 this.style.backgroundColor = 'purple'; this.style.width = '250px'; } &lt;/script&gt; &lt;/body&gt; 淘宝关闭二维码案例： 核心思路： 利用样式的显示和隐藏完成， display:none 隐藏元素 display:block 显示元素 点击按钮，就让这个二维码盒子隐藏起来即可 &lt;style&gt; div { width: 150px; height: 150px; background-color: #ccc; position: relative; margin: 100px auto; } div span { position: absolute; top: 0; left: -20px; } &lt;/style&gt; &lt;body&gt; &lt;div&gt; &lt;span&gt;关&lt;/span&gt; &lt;/div&gt; &lt;script&gt; //1.获取元素 var btn = document.querySelector('span'); var div = document.querySelector('div'); //2. 绑定事件 btn.onclick = function() { div.style.display = 'none'; } &lt;/script&gt; &lt;/body&gt; 隐藏文本框内容案例： &lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;手机&quot;&gt; &lt;script&gt; //1.获取元素 var text = document.querySelector('input'); //2.注册事件 获得焦点 onfocus 失去焦点 onblur text.onfocus = function() { if (this.value === '手机') { this.value = ''; } }; text.onblur = function() { if (this.value === '') { this.value = '手机'; } } &lt;/script&gt; &lt;/body&gt; 操作类名方式更改元素样式： &lt;style&gt; div { width: 200px; height: 200px; background-color: pink; } .change { background-color: purple; color: red; font-size: 25px; margin-top: 30px; } &lt;/style&gt; &lt;body&gt; &lt;div&gt;文本&lt;/div&gt; &lt;script&gt; // 1.获取元素 var div = document.querySelector('div'); div.onclick = function() { // 将当前元素的类名改为了 change this.className = 'change'; } &lt;/script&gt; &lt;/body&gt; 如果样式修改较多，可以采取操作类名方式更改元素样式。 class因为是个保留字，因此使用className来操作元素类名属性 className 会直接更改元素的类名，会覆盖原先的类名。 总结：操作元素是 DOM 核心内容 4.5 排他思想 如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法： 所有元素全部清除样式（干掉其他人） 给当前元素设置样式 （留下我自己） 注意顺序不能颠倒，首先干掉其他人，再设置自己 &lt;body&gt; &lt;button&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt; &lt;button&gt;按钮4&lt;/button&gt; &lt;button&gt;按钮5&lt;/button&gt; &lt;script&gt; //1.获取都有按钮元素 var btns = document.getElementsByTagName('button'); for (var i = 0; i &lt; btns.length; i++) { btns[i].onclick = function() { // 1.先将所有的按钮背景颜色去除掉 for (let i = 0; i &lt; btns.length; i++) { btns[i].style.backgroundColor = ''; } // 2.然后才让当前的元素背景颜射为pink this.style.backgroundColor = 'pink'; } } &lt;/script&gt; &lt;/body&gt; 4.6 自定义属性操作 获取属性值 element.属性 获取属性值。 element.getAttribute('属性'); 区别： element.属性 获取内置属性值（元素本身自带的属性） element.getAttribute(‘属性’); 主要获得自定义的属性 （标准） 我们程序员自定义的属性 &lt;body&gt; &lt;div id=&quot;demo&quot; index='1'&gt;&lt;/div&gt; &lt;script&gt; var div = document.querySelector('div'); // 1.获取元素的属性值 // (1) element.属性 console.log(div.id); // undefined console.log(div.index); // (2) element.getAttribute('属性') console.log(div.getAttribute('id')); console.log(div.getAttribute('index')); &lt;/script&gt; &lt;/body&gt; 设置属性值 element.属性 = ‘值’ 设置内置属性值。 element.setAttribute('属性','值'); 区别： element.属性 设置内置属性值 element.setAttribute('属性','值'); 主要设置自定义的属性 （标准） 移除属性 element.removeAttribute('属性'); 4.7 H5自定义属性 自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。 自定义属性获取是通过getAttribute(‘属性’) 获取。 但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。 设置H5自定义属性 H5规定自定义属性 data- 开头做为属性名并且赋值。 比如 &lt;div data-index=&quot;1&quot;&gt;&lt;/div&gt; 或者使用 JS 设置 element.setAttribute(‘data-index’, 2) 获取H5自定义属性 1. 兼容性获取 element.getAttribute(‘data-index’); 2. H5新增 element.dataset.index 或者 element.dataset[‘index’] ie 11才开始支持 5. 节点操作 5.1 为什么学节点操作 获取元素通常使用两种方式： 利用 DOM 提供的方法获取元素 document.getElementById() document.getElementsByTagName() document.querySelector 等 逻辑性不强、繁琐 利用节点层级关系获取元素 利用父子兄节点关系获取元素 逻辑性强， 但是兼容性稍差 这两种方式都可以获取元素节点，我们后面都会使用，但是节点操作更简单。 5.2 节点概述 网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。 HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以 创建或删除。 一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个 基本属性。 元素节点 nodeType 为 1 属性节点 nodeType 为 2 文本节点 nodeType 为 3 （文本节点包含文字、空格、换行等） 5.3 节点层级 利用 DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。 父级节点 node.parentNode &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;erweima&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 1. 父节点 parentNode var erweima = document.querySelector('.erweima'); // 得到的是离元素最近的父节点（亲爸爸），如果找不到就返回为 null console.log(erweima.parentNode); &lt;/script&gt; &lt;/body&gt; 子节点（标准） parentNode.childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合。 注意：返回值里面包含了所有的子节点，包括元素节点，文本节点等。 如果只想要获得里面的元素节点，则需要专门处理。 所以我们一般不提倡使用childNodes 子节点（非标准） parentNode.children parentNode.children 是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回 （这个是我们重点掌握的）。 &lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 2. 子节点 var ul = document.querySelector('ul'); // childNodes 获取的子节点包含 元素节点 文本节点等等 console.log(ul.childNodes); // parentNode.children 只返回子元素节点 console.log(ul.children); &lt;/script&gt; &lt;/body&gt; parentNode.firstChild firstChild 返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。 parentNode.lastChild lastChild 返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。 parentNode.firstElementChild firstElementChild 返回第一个子元素节点，找不到则返回null。 parentNode.lastElementChild lastElementChild 返回最后一个子元素节点，找不到则返回null。 注意：后两个方法有兼容性问题，IE9 以上才支持。 &lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.querySelector('ul'); // 1. firstChild 第一个子节点 文本节点与元素节点 console.log(ul.firstChild); // 2. firstChild 第一个子节点 文本节点与元素节点 console.log(ul.lastChild); // 3. firstElementChild 第一个元素节点 console.log(ul.firstElementChild); // 4. lastElementChild 最后一个元素节点 console.log(ul.lastElementChild); &lt;/script&gt; &lt;/body&gt; 实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？ 解决方案: 如果想要第一个子元素节点，可以使用 parentNode.chilren[0] 如果想要最后一个子元素节点，可以使用 parentNode.chilren[parentNode.chilren.length - 1] node.nextSibling nextSibling 返回当前元素的下一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点。 node.previousSibling previousSibling 返回当前元素上一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点。 node.nextElementSibling nextElementSibling 返回当前元素下一个兄弟元素节点，找不到则返回null。 node.previousElementSibling previousElementSibling 返回当前元素上一个兄弟节点，找不到则返回null。 注意：这两个方法有兼容性问题， IE9 以上才支持。 5.4 创建节点 document.createElement('tagName') document.createElement() 方法创建由 tagName 指定的 HTML 元素。因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为 动态创建元素节点 。 node.appendChild(child) node.appendChild() 方法将一个节点添加到指定父节点的子节点列表末尾。类似于 CSS 里面的 after 伪元素。 node.insertBefore(child, 指定元素) node.insertBefore() 方法将一个节点添加到父节点的指定子节点前面。类似于 CSS 里面的 before 伪元素。 &lt;body&gt; &lt;ul&gt; &lt;li&gt;123&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //1. 创建节点元素节点 var li = document.createElement('li'); //2. 添加节点 node.appendChild(child) 在后面追加元素 var ul = document.querySelector('ul'); ul.appendChild(li); //3. 添加节点 node.insertBefore(child,指定元素); var lili = document.createElement('li'); ul.insertBefore(lili, ul.children[0]); &lt;/script&gt; &lt;/body&gt; 添加留言板案例： &lt;body&gt; &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;button&gt;发布&lt;/button&gt; &lt;ul&gt;&lt;/ul&gt; &lt;script&gt; //1. 获取元素 var text = document.querySelector('textarea'); var btn = document.querySelector('button'); var ul = document.querySelector('ul'); //2. 注册事件 btn.onclick = function() { if (text.value != '') { // 创建元素 var li = document.createElement('li'); li.innerHTML = text.value; // 添加元素 // ul.appendChild(li); ul.insertBefore(li, ul.children[0]) text.value = ''; } else { alert('没有输入内容！'); return false; } } &lt;/script&gt; &lt;/body&gt; 5.5 删除节点 node.removeChild(child) node.removeChild() 方法从 DOM 中删除一个子节点，返回删除的节点。 删除留言板内容案例: &lt;body&gt; &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;button&gt;发布&lt;/button&gt; &lt;ul&gt;&lt;/ul&gt; &lt;script&gt; //1. 获取元素 var text = document.querySelector('textarea'); var btn = document.querySelector('button'); var ul = document.querySelector('ul'); //2. 注册事件 btn.onclick = function() { if (text.value != '') { // 创建元素 var li = document.createElement('li'); li.innerHTML = text.value + &quot;&lt;a href='javascript:;'&gt;删除&lt;/a&gt;&quot;; // 添加元素 // ul.appendChild(li); ul.insertBefore(li, ul.children[0]) text.value = ''; // 3. 删除元素，删除的是当前链接的li var as = document.querySelectorAll('a'); for (let i = 0; i &lt; as.length; i++) { as[i].onclick = function() { //这里要注意 ul.removeChild(this.parentNode); } } } else { alert('没有输入内容！'); return false; } } &lt;/script&gt; &lt;/body&gt; 5.6 复制节点 node.cloneNode() node.cloneNode() 方法返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点。 注意： 如果括号参数为空或者为 false ，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点。 如果括号参数为 true ，则是深度拷贝，会复制节点本身以及里面所有的子节点。 &lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.querySelector('ul'); // 1. node.cloneNode(true); 括号里true为深拷贝，否则为浅拷贝，浅拷贝不拷贝内容 var lili = ul.children[0].cloneNode(true); ul.appendChild(lili); &lt;/script&gt; &lt;/body&gt; 5.8 三种动态创建元素区别 document.write() element.innerHTML document.createElement() 区别: document.write 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘 innerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘 innerHTML 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂 createElement() 创建多个元素效率稍低一点点，但是结构更清晰 总结：不同浏览器下，innerHTML(数组形式) 效率要比 creatElement 高 6. DOM 重点核心 文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口。 对于JavaScript，为了能够使JavaScript操作HTML，JavaScript就有了一套自己的dom编程接口。 对于HTML，dom使得html形成一棵dom树. 包含 文档、元素、节点。 关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。 6.1 创建 document.write innerHTML createElement 6.2 增 appendChild insertBefore 6.3 删 removeChild 6.4 改 修改元素属性：src、href、title 等 修改普通元素内容：innerHTML、innerText 修改表单内容：value、type、disabled 等 修改元素样式：style、className 6.5 查 主要获取查询dom的元素： DOM提供的API 方法： getElementById、getElementsByTagName 古老用法 不太推荐 H5提供的新方法： querySelector、querySelectorAll 提倡 利用节点操作获取元素： 父(parentNode)、子(children)、兄(previousElementSibling、nextElementSibling) 提倡 6.6 属性操作 setAttribute：设置dom的属性值 getAttribute：得到dom的属性值 removeAttribute移除属性 6.7 事件操作 给元素注册事件， 采取 事件源.事件类型 = 事件处理程序 ","link":"https://blog.zhawenwen.cn/post/javascript_webapi_1/"},{"title":"实验室第一天","content":"今天在实验室呆了一天，师兄师姐都很好！ 早上来到实验室就很焦虑，因为之前就通知今天晚上要《机器学习》划重点，《计算机视觉》明天晚上划重点，这个月末考试，机器学习和计算机视觉是暑假的上的两门网课，但由于暑假还在上班，所以课程没怎么学，在加上课程本身也是比较难，所以能焦虑。 上午在实验室就一直在看计算机视觉的网课，发现好难，东西好多，根本记不住，越学越焦虑，看了两个小时之后实在看不下去了，于是就换了一个学习内容——看了下数据结构的基础算法。 这真是不看不知道，一看吓一跳，基础算法题一题都不会了，就连最简单的双链表打印问题，都做不出来，看解析看半天都还看不懂，之前积累的知识完完全全的忘光了........ 下午来到实验室，继续“啃”基础算法，一些简单的双链表、数组、重复数据等算法完完全全一脸懵逼状态，越看越看不下去，感觉自己玩完了。一下午在leetcode看着答案没有搞出来两道题，之前做过了做对的问题在看都要反应半天。 晚上画机器学习的重点，老师把ppt从头翻到尾，没听出来哪里是重点，老师让我们自己体会体会，又无了... 今天的一天是充实且糟糕的一天，我发现自己就是个辣鸡，啥都不会，唉！ ","link":"https://blog.zhawenwen.cn/post/shi-yan-shi-di-yi-tian/"},{"title":"今天开学第一天","content":"今天是研究生开学的第一天，发生了一些比较有意思的事情，这边记录下来。 早上6:00左右就起来咯，在奶奶家吃了一碗肉丝面，然后爷爷就送我去镇上坐公交车。 在火车站因为时间原因从一辆慢车改到了一趟慢慢车，足足花了三个小时才到目的车站，到站时已接近中午12:00。 在出站口就看到了学校的迎新人员，于是等了一会儿就做了校车去了学校报道。 在我们学院报道处叫材料时才发现我少了两份材料——身份证复印件和1寸证件照，于是只好后期补交。之后一名志愿者带着我去了校外公寓，在公寓报道点扫码时发现手机不见了，突然回想起放在报道处忘记拿了，而公寓必须手机扫码后才能进入，我能感觉到宿管阿姨都在笑我，后来还是志愿者小哥哥给我开了个热点，我用ipad操作出二维码才解决进入公寓的问题。 我放好行李后，志愿者小哥哥又带着我通过天桥回去拿手机，顺便在路上和我介绍了校园的一线简单情况。 拿到手机后我又急急忙忙回到宿舍公寓，购买卧具包，铺床铺被子。 之后去拍了证件照、复印了身份证，又赶到迎新点处补交这些材料。 回到宿舍准备休息一下时，发现宿舍少了两把椅子，于是又去找宿管阿姨说明情况，宿管阿姨说没个宿舍都是配的好好的，不可能少的，之后又去拿了两把全是灰的椅子给我。 之后就是收拾宿舍，与舍友相互沟通。 在此特别感谢帮助我的哪位志愿者小哥哥！ 研究生开学第一天就这么结束了！ ","link":"https://blog.zhawenwen.cn/post/jin-tian-kai-xue-di-yi-tian/"},{"title":"Python 实现图片转字符画","content":"使用 pillow、argparse 库实现 一、实验原理 字符画是一系列字符的组合，我们可以把字符看作是比较大块的像素，一个字符能表现一种颜色（为了简化可以这么理解），字符的种类越多，可以表现的颜色也越多，图片也会更有层次感。 问题来了，我们是要转换一张彩色的图片，这么多的颜色，要怎么对应到单色的字符画上去？这里就要介绍灰度值的概念了。 灰度值：指黑白图像中点的颜色深度，范围一般从0到255，白色为255，黑色为0，故黑白图片也称灰度图像。 我们可以使用灰度值公式将像素的 RGB 值映射到灰度值（注意这个公式并不是一个真实的算法，而是简化的 sRGB IEC61966-2.1 公式，真实的公式更复杂一些，不过在我们的这个应用场景下并没有必要）： gray ＝ 0.2126 * r + 0.7152 * g + 0.0722 * b 创建一个不重复的字符列表，灰度值小（暗）的用列表开头的符号，灰度值大（亮）的用列表末尾的符号。 $@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~&lt;&gt;i!lI;:,\\&quot;^`'. # 由暗到亮 二、实验步骤 首先需要安装图形处理库pillow（PIL），使用虚拟环境安装 # 创建v3虚拟环境 mkvirtualenv v3 # 进入v3虚拟环境 workon v3 # 安装图形处理库pillow pip install pillow 这时可能会报错：ModuleNotFoundError: No module named ‘pip’,这是由于虚拟环境的pip没有安装导致 # 执行以下两句修复 pip python -m ensurepip python -m pip install --upgrade pip 然后创建一个文件：ascii.py # 导入相关库 ## PIL 是图形处理库 from PIL import Image ## argparse 是用来管理命令行参数输入 import argparse 我们首先使用 argparse 处理命令行参数，目标是获取输入的图片路径、输出字符画的宽和高以及输出文件的路径： # 首先，构建命令行输入参数处理 ArgumentParser 实例 parser = argparse.ArgumentParser() # 定义输入文件、输出文件、输出字符画的宽和高 parser.add_argument('file') #输入文件 parser.add_argument('-o', '--output') #输出文件 parser.add_argument('--width', type = int, default = 80) #输出字符画宽 parser.add_argument('--height', type = int, default = 80) #输出字符画高 # 解析并获取参数 args = parser.parse_args() # 输入的图片文件路径 IMG = args.file # 输出字符画的宽度 WIDTH = args.width # 输出字符画的高度 HEIGHT = args.height # 输出字符画的路径 OUTPUT = args.output 定义一个明暗字符串，这个字符串将根据RGB值取值，前面较暗，后面较亮： ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~&lt;&gt;i!lI;:,\\&quot;^`'. &quot;) 将RGB值转化为字符： def get_char(r,g,b,alpha = 256): # 判断 alpha 值 if alpha == 0: return ' ' # 获取字符集的长度，这里为 70 length = len(ascii_char) # 将 RGB 值转为灰度值 gray，灰度值范围为 0-255 gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) # 灰度值范围为 0-255，而字符集只有 70 # 需要进行如下处理才能将灰度值映射到指定的字符上 unit = (256.0 + 1)/length # 返回灰度值对应的字符 return ascii_char[int(gray/unit)] 处理图片： 首先使用 PIL 的 Image.open 打开图片文件，获得对象 im 使用 PIL 库的 im.resize() 调整图片大小对应到输出的字符画的宽度和高度，注意这个函数第二个参数使用 Image.NEAREST，表示输出低质量的图片。 遍历提取图片中每行的像素的 RGB 值，调用 getchar 转成对应的字符 将所有的像素对应的字符拼接在一起成为一个字符串 txt 打印输出字符串 txt 如果执行时配置了输出文件，将打开文件将 txt 输出到文件，如果没有，则默认输出到 output.txt 文件 if __name__ == '__main__': # 打开并调整图片的宽和高 im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) # 初始化输出的字符串 txt = &quot;&quot; # 遍历图片中的每一行 for i in range(HEIGHT): # 遍历该行中的每一列 for j in range(WIDTH): # 将 (j,i) 坐标的 RGB 像素转为字符后添加到 txt 字符串 txt += get_char(*im.getpixel((j,i))) # 遍历完一行后需要增加换行符 txt += '\\n' # 输出到屏幕 print(txt) # 字符画输出到文件 if OUTPUT: with open(OUTPUT,'w') as f: f.write(txt) else: with open(&quot;output.txt&quot;,'w') as f: f.write(txt) 最后使用命令执行，转成的字符串会输出到output.txt中。 python ascii.py 1.png 三、相关参考资源文件 完整的Python文件 1.png 参考资料：蓝桥云课-Python 实现图片转字符画 CSDN——无pip模块解决办法 argparse模块简单用法 ","link":"https://blog.zhawenwen.cn/post/python_png2txt/"},{"title":"Windows 下安装配置 Python 的虚拟环境","content":" 在日常使用Python中，我们可能要使用不同的Python版本，安装不同的包，如果只在本地的Python环境中进行这些操作，不方便Python版本的切换；所有的包都安装在同一个环境中，会导致该环境中无用数据过多。由此，Python的虚拟环境就诞生了。 本文通过简单的方法在Windows电脑上配置一个简单的Python虚拟环境。 # 虚拟环境操作常用命令 ## 创建虚拟环境 mkvirtualenv v1 ## 查看虚拟环境 workon ## 进入虚拟环境 workon v1 ## 退出虚拟环境 deactivate 1. 电脑中安装python3.x，请自行安装。 2. 现在本地电脑中创建一个文件夹，用来存放Python虚拟环境。我在D盘根目录下创建了一个名为PythonEnvs的目录。 3. 安装Python虚拟环境 # 在D:/PythonEnvs 目录下输入以下命令安装Pytohn虚拟环境 pip install virtualenv 新建虚拟环境 # virtualenv+虚拟环境名 创建虚拟环境 virtualenv v1 启动环境变量 # 环境变量目录Scripts下的 activate 和 deactivate 是启动和退出命令 ./Scripts/activate.bat 4. 安装虚拟环境管理 # 以上的虚拟环境依然不方便管理 # 可以安装一个 virtualenvwrapper # 安装 pip install virtualenvwrapper-win 创建虚拟环境 # 创建的虚拟环境默认在 C:\\Users\\&lt;userName&gt;\\Envs\\ 目录下 mkvirtualenv v1 新建一个系统变量，然后再创建的虚拟环境就到了系统变量配置的那个目录里，即D:/PythonEnvs 。 查看启用的虚拟环境 workon 进入虚拟环境 # workon+虚拟环境名 workon v2 退出虚拟环境 # 虚拟环境Scripts目录下的 activate 与 deactivate 是启动和退出虚拟环境的命令 deactivate 5. Vscode 中使用虚拟环境 打开一个python文件，左下角可以切换python环境，见截图。 6. 参考文章： Python 3.9.7 文档-venv创建虚拟环境; 博客园-windows安装Python虚拟环境 博客园-Windows下Python的虚拟环境 ","link":"https://blog.zhawenwen.cn/post/python_env/"},{"title":"将阿里云盘映射到电脑本地磁盘——用 CloudDrive 实现","content":" 首先贴上链接：Windows版：https://www.aliyundrive.com/s/wLQfjyVMUq3 1.下载 CloudDrive 并安装 打开上面的链接，找到CloudDrive安装包，如下图所示，选择自己电脑对应的版本下载即可。 下载好后安装点击下一步，建议不要安装在C盘默认位置，选择D盘任意位置即可。 安装好后会自动在浏览器打开网址 http://localhost:9798/ CloudDrive支持115云盘、沃家云盘、天翼云盘、阿里云盘等。 2.配置阿里云盘映射 在浏览器网页 http://localhost:9798/ 中，点击云状图标，选中阿里云 这时会跳出二维码要求扫码登陆，用手机扫码登陆即可 登陆完成之后，会让你选择一个盘符，一般默认即可。 这样我的电脑里就会新增一个盘，盘的容量就是你的阿里云盘的容量，该盘与其他盘操作方式完全一样，只是拷贝速度受到网速的限制。 至此，阿里云盘映射到本地硬盘的步骤基本完成⚓️。 3.注意事项 1、上传默认缓存文件到C盘，网页可以查看上传任务，上传完自动删除缓存（网页可以设置缓存位置） 2、最好不要直接从网上下载资源到本地挂载的磁盘里（包括百度设置下载目录到挂载磁盘） 3、不适合用来打游戏或者在线编辑文档（为了防止文件丢失记得做好备份） 4、旧版本可以正常使用就不建议更新新版本了（尝鲜的可以忽视） 5、挂载的盘可以选择挂载为本地或者网络盘，自己觉得哪种好用就选哪种(网页设置挂载盘符类型) 4.参考链接 吾爱破解网-阿里云盘变本地硬盘 软件世界-CloudDrive - 将阿里云网盘变成电脑本地硬盘 ","link":"https://blog.zhawenwen.cn/post/CloudDrive/"},{"title":"搭建 Gride 静态网站","content":" 今天是2021年9月6日，星期一，突发奇想搭建一个自己的博客，用来记录自己将要到来的研究生生活！ 使用Gridea搭建静态网站时也遇到了一些问题： 打开 Gridea 软件时不显示 配置远程时不能使用 Gitee ，只能使用 Github 主题介绍不清晰 希望未来我能完善这些问题！ ","link":"https://blog.zhawenwen.cn/post/da-jian-gride-jing-tai-wang-zhan/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://blog.zhawenwen.cn/post/hello-gridea/"}]}